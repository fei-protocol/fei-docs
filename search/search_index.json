{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Welcome to the Fei Protocol documentation guide! The docs are organized into 3 categories: * User * Developer * Operator For a high level overview of Fei v2 check out our introduction post ! User Docs Developer Docs Operator Docs","title":"Overview"},{"location":"#overview","text":"Welcome to the Fei Protocol documentation guide! The docs are organized into 3 categories: * User * Developer * Operator For a high level overview of Fei v2 check out our introduction post !","title":"Overview"},{"location":"#user-docs","text":"","title":"User Docs"},{"location":"#developer-docs","text":"","title":"Developer Docs"},{"location":"#operator-docs","text":"","title":"Operator Docs"},{"location":"developers/addresses/","text":"Core Name Address tribeMinter 0xFC3532b443383d9022b1B2c6FD5Fd0895943360A pcvGuardian 0x2D1b1b509B6432A73e3d798572f0648f6453a5D9 feiTribeLBPSwapper 0x16ef9601076d45e8cc564cDD91E5dF3Ae83dD3B3 pcvEquityMinter 0x904Deb2Dac1EdfCBBb69b9c279aE5F75E57Cf5E9 collateralizationOracleGuardian 0x81De6bA8df84A4B679061952E171a27F096F3eAe core 0x8d5ED43dCa8C2F7dFB20CF7b53CC7E593635d7b9 fei 0x956F47F50A910163D8BF957Cf5846D573E7f87CA optimisticMinter 0xE66c4De480Bd317054B5a3CF8E8689649d0728c9 proxyAdmin 0xf8c2b645988b7658E7748BA637fE25bdD46A704A ratioPCVController 0xB1410aeCe2c65fE9e107c58b5aa32e91B18f0BC7 tribe 0xc7283b66Eb1EB5FB86327f08e1B5816b0720212B Governance Name Address tribeRariDAO 0x637deEED4e4deb1D222650bD4B64192abf002c00 rariTimelock 0x8ace03Fc45139fDDba944c6A4082b604041d19FC feiDAO 0x0BEF27FEB58e857046d630B2c03dFb7bae567494 feiDAOTimelock 0xd51dbA7a94e1adEa403553A8235C302cEbF41a3c guardian 0xB8f482539F2d3Ae2C9ea6076894df36D1f632775 optimisticTimelock 0xbC9C084a12678ef5B516561df902fdc426d95483 timelock 0x639572471f2f318464dc01066a56867130e45E25 optimisticMultisig 0x35ED000468f397AA943009bD60cc6d2d9a7d32fF Peg Name Address daiPCVDripController 0x3e0f66c5687FF917809A3F7fA7096e1Bc409fB03 tribeReserveStabilizer 0xE1A468418f4D8D3F070A06d49b3575A9562b6CfD daiPSM 0x210300C158f95E1342fD008aE417ef68311c49C2 aaveEthPCVDripController 0xb3D63876d95d3a5e591D4DE536dC410b97244086 bondingCurve 0xB783c0E21763bEf9F2d04E6499abFbe23AdB7e1F compoundEthPCVDripController 0xa84C8be28f3d560059339f06C6b6c5B23f53C58C daiBondingCurve 0xC0afe0E649e32528666F993ce63822c3840e941a ethReserveStabilizer 0x17305f0e18318994a57b494078CAC866A857F7b6 raiBondingCurve 0x25d60212D47Dd8F6Ff0469367E4c6C98Cd3411A5 PCV Name Address agEurAngleUniswapPCVDeposit 0x7AC2Ab8143634419c5bc230A9f9955C3e29f64Ef d3poolCurvePCVDeposit 0x24F663c69Cd4B263cf5685A49013Ff5f1C898D24 d3poolConvexPCVDeposit 0x5ae217dE26f6Ff5F481C6e10ec48b2cf2fc857C8 aaveEthPCVDeposit 0x5B86887e171bAE0C2C826e87E34Df8D558C079B9 aaveFeiPCVDeposit 0xaFBd7Bd91B4c1Dd289EE47a4F030FBeDfa7ABc12 aaveRaiPCVDeposit 0xd2174d78637a40448112aa6B30F9B19e6CF9d1F9 compoundDaiPCVDeposit 0xe0f73b8d76D2Ad33492F995af218b03564b8Ce20 compoundEthPCVDeposit 0x4fCB1435fD42CE7ce7Af3cB2e98289F79d2962b3 creamFeiPCVDeposit 0x243C601CC5DaA3Ac250B14509804188347bd2aFB dpiUniswapPCVDeposit 0x902199755219A9f8209862d09F1891cfb34F59a3 ethLidoPCVDeposit 0xac38ee05c0204a1e119c625d0a560d6731478880 indexCoopFusePoolDpiPCVDeposit 0x3dD3d945C4253bAc5B4Cc326a001B7d3f9C4DD66 indexCoopFusePoolFeiPCVDeposit 0xD6960adba53212bBE96E54a7AFeDA2066437D000 indexDelegator 0x0ee81df08B20e4f9E0F534e50da437D24491c4ee liquityFusePoolLusdPCVDeposit 0x8C51E4532CC745cF3DFec5CEBd835D07E7BA1002 feiLusdLBPSwapper 0x5fc76F8Fc3AF2b19D45AC841252dcE711ed448ff poolPartyFeiPCVDeposit 0x5A8CB4556e5D5935Af06beab8292905f48131479 rariPool19DpiPCVDeposit 0x3dD3d945C4253bAc5B4Cc326a001B7d3f9C4DD66 rariPool18FeiPCVDeposit 0x5A8CB4556e5D5935Af06beab8292905f48131479 rariPool19FeiPCVDeposit 0xD6960adba53212bBE96E54a7AFeDA2066437D000 rariPool22FeiPCVDeposit 0x7CeBaB7b4B4399343f6D0D36B550EE097F60d7fE rariPool24FeiPCVDeposit 0x1434F99EDB2bD03DECCCFe21288767b8324B7403 rariPool25FeiPCVDeposit 0xe1662531aA5de1DAD8ab5B5756b8F6c8F3C759Ca rariPool26FeiPCVDeposit 0xFdCc96967C86250f333cE52Ba706Ec2961c3302f rariPool27FeiPCVDeposit 0x91f50E3183a8CC30D2A981C3aFA85A2Bf6691c67 rariPool28FeiPCVDeposit 0xb0D5eBA35E1cecE568096064Ed68A49C6A24d961 rariPool31FeiPCVDeposit 0x81DCB06eA4db474D1506Ca6275Ff7D870bA3A1Be rariPool54FeiPCVDeposit 0x9d28B8Cb17c3E25b6Cce17f88B259f75174b69f4 rariPool6FeiPCVDeposit 0xB51f09B6F103D697dc5d64DC904Ad6a2Dad39987 rariPool7FeiPCVDeposit 0x74B235Fef146cDB5BE0D3786a9f3774674b3615E rariPool7LusdPCVDeposit 0x6026a1559CDd44a63C5CA9A078CC996a9eb68ABB rariPool72FeiPCVDeposit 0x4A5Af5A124E672C156241b76CAd4E41D09dd4883 rariPool79FeiPCVDeposit 0x76dFcf06E7D7B8248094DC319b284fB244f06309 rariPool8FeiPCVDeposit 0x37349d9cc523D28e6aBFC03fc5F44879bC8BfFD9 rariPool9FeiPCVDeposit 0xF2D8beE45f29A779cFB9F04ac233E703974a2C53 rariPool9RaiPCVDeposit 0x9aAdFfe00eAe6d8e59bB4F7787C6b99388A6960D rariPool90FeiPCVDeposit 0x61d26126D2F8A44b41c1D8E1B1F276551DC8EEc6 rariPool91FeiPCVDeposit 0x2296a2417D1f02d394ab22aF794a0f426eD53436 reflexerStableAssetFusePoolRaiPCVDeposit 0x9aAdFfe00eAe6d8e59bB4F7787C6b99388A6960D ethTokemakPCVDeposit 0x0961d2a545e0c1201B313d14C57023682a546b9D tokeTokemakPCVDeposit 0x45C8FaB07B64C78d03006591132Ac51DE82a4B22 uniswapPCVDeposit 0x15958381E9E6dc98bD49655e36f524D2203a28bD Collateralization Name Address feiLusdLens 0x1F05b337cB16CeA2a1C638Ba9b9571F0Cf4a5612 aaveFeiPCVDepositWrapper 0xFAc571b6054619053ac311dA8112939C9a374A85 creamDepositWrapper 0x3a1838Ac9EcA864054bebB82C32455Dd7d7Fc89c balDepositWrapper 0x7E28BA7a2D52Af88242E588d868E927119BA45dB staticPcvDepositWrapper2 0xe72EB93de743F819fe91277582d7d0Fa9bb9b023 feiBuybackLens 0x107460564896377BA6CdcC7516c7eAb65E32E360 collateralizationOracleKeeper 0x62378C316a6161A613D02E11F65290aED79B3eD5 staticPcvDepositWrapper 0x8B41DcEfAe6064E6bc2A9B3ae20141d23EFD6cbd ethReserveStabilizerWrapper 0xB24570Bc46efDf97b4Aa7f008B4268005Eb7A27E daiBondingCurveWrapper 0x2547d76E2447E67F29d6bFeE5d46FDd2183c88E4 raiBondingCurveWrapper 0xc42e155788f9f599Fd437C7455F63810A395a81f dpiBondingCurveWrapper 0x60B63eF8f461355207fE1d8102dda938bbd8c3fB rariPool19DpiPCVDepositWrapper 0x9a774a1B1208C323EDeD05E6Daf592E6E59cAa55 ethLidoPCVDepositWrapper 0xA271fF86426c7fdAaAE72603e6Ce68c892d69ED7 compoundDaiPCVDepositWrapper 0xfDe7077AAEcDaf2C4B85261Aa858c96A7E737a61 compoundEthPCVDepositWrapper 0x0735e14D28eD395048d5Fa4a8dbe6e6EB9fc0470 aaveRaiPCVDepositWrapper 0x1267B39c93711Dd374DEAB15e0127e4adB259BE0 aaveEthPCVDepositWrapper 0x43Ef03755991056681F01EE2182234eF6aF1f658 rariPool9RaiPCVDepositWrapper 0xCCe230c087F31032fc17621a2CF5E425A0b80C96 creamFeiPCVDepositWrapper 0xFf419Bc27483edb94b7Ad5c97b7FaB5DB323c7E0 rariPool8FeiPCVDepositWrapper 0xD6598a23418c7FEf7c0Dc863265515B623B720F9 rariPool9FeiPCVDepositWrapper 0x96A657eE40A79A964c6b4eA551c895D98e885a75 rariPool7FeiPCVDepositWrapper 0xb13C755107301eBFeD6A93190aCdE09281b2f8A5 rariPool6FeiPCVDepositWrapper 0x7aA4b1558C3e219cFFFd6a356421C071F71966e7 rariPool19FeiPCVDepositWrapper 0x7e39bBA9D0d967Ee55524fAe9e54900B02d9889a rariPool24FeiPCVDepositWrapper 0x508f6fbd78B6569C29E9D75986a51558dE9E5865 rariPool25FeiPCVDepositWrapper 0xB4FFD10C4C290Dc13E8e30BF186F1509001515fD rariPool26FeiPCVDepositWrapper 0x82aebeE64a52180d8541eB601A8381e012A1eD04 rariPool27FeiPCVDepositWrapper 0xe2e35097638F0Ff2EeCA2EF70F352Be37431945f rariPool18FeiPCVDepositWrapper 0x07F2DD7E6A78D96c08D0a8212f4097dCC129d629 rariPool28FeiPCVDepositWrapper 0x4E119714f625B2E82e5fB5A7E297978f020Ea51E rariPool31FeiPCVDepositWrapper 0x05E2e93CFb0B53D36A3151ee727Bb581D4B918Ce feiOATimelockWrapper 0x7Eb88140af813294aEDce981b6aC08fcd139d408 collateralizationOracle 0xFF6f59333cfD8f4Ebc14aD0a0E181a83e655d257 collateralizationOracleWrapperImpl 0x656aA9c9875eB089b11869d4730d6963D25E76ad collateralizationOracleWrapper 0xd1866289B4Bd22D453fFF676760961e0898EE9BF Oracle Name Address chainlinkLUSDOracle 0xe61d11ec732d556A26fb863B192052BEa03eF8B5 chainlinkCREAMEthOracle 0xDE02522cDc4959117fe839a7326D80F9858f383C chainlinkBALEthOracle 0x7261D245454Daa070C77B2a26eA192E3a4c8F655 balUsdCompositeOracle 0xDe0407851AEC6F073A63D27C7D29805CCD59D3e0 creamUsdCompositeOracle 0x2BDca027c7f57eD9AC1769Ba3a3D64600578bA49 chainlinkEurUsdOracleWrapper 0xFb3a062236A7E08b572F17bc9Ad2bBc2becB87b1 chainlinkTribeEthOracleWrapper 0x061118ccabF0c2c62f05a2e3C2bd4379c0C70079 tribeUsdCompositeOracle 0xD7B8207f8644ee5cc60095023a8fcb8BdCF54732 oneConstantOracle 0x2374800337c6BE8B935f96AA6c10b33f9F12Bd40 zeroConstantOracle 0x43b99923CF06D6D9101110b595234670f73A4934 chainlinkDaiUsdOracleWrapper 0x231aDa12E273eDf3fA54CbD90c5C1a73129D5bb9 chainlinkDpiUsdOracleWrapper 0xB594d2bd55Ede471e16b92AE6F7651648DA871c3 chainlinkEthUsdOracleWrapper 0xCd3c40AE1256922BA16C7872229385E20Bc8351e chainlinkFeiEthOracleWrapper 0x060Be7B51F78DFFd04749332fd306BA1228e7444 chainlinkRaiEthOracleWrapper 0x3d49573ee6aFCBDe606F8a1c2AA1C498048E7190 chainlinkRaiUsdCompositOracle 0x392b1d29eDab680c5CA778D3A32b8284859BFBB0 chainlinkTribeEthOracle 0x84a24deCA415Acc0c395872a9e6a63E27D6225c8 compositeOracle 0x8721f9EAba0B9081069970bCBce38763D3D4f28E Keeper Name Address Rewards Name Address aaveTribeIncentivesController 0xDee5c1662bBfF8f80f7c572D8091BF251b3B0dAB aaveTribeIncentivesControllerProxy 0xDee5c1662bBfF8f80f7c572D8091BF251b3B0dAB aaveTribeIncentivesControllerImpl 0xFF865335401F12B88fa3FF5A3a51685A7f224191 erc20Dripper 0x3Fe0EAD3500e767F0F8bC2d3B5AF7755B1b21A6a rewardsDistributorAdmin 0x4e979E8b136Cd7BdEBB83ea50a599C3BED1e15c0 autoRewardsDistributor 0x61be49dfbd869a601fea076e1a1379903e61a895 rariRewardsDistributorDelegator 0x73F16f0c0Cd1A078A54894974C5C054D8dC1A3d7 rariRewardsDistributorDelegate 0x220f93183a69d1598e8405310cB361CFF504146F stakingTokenWrapperRari 0xd81Be1B9A7895C996704A8DDa794BbA4454EeB90 tribalChief 0x9e1076cC0d19F9B0b8019F384B0a29E48Ee46f7f tribalChiefImpl 0x2d91362e8bcAA8826b482B531dcb170FC9d17777 tribalChiefSync 0x7A883825caA45fcbDcd76991C5972Baf1551aa3d stakingTokenWrapperGROLaaS 0x508629e8E0B96986Df4D0F1F60aadeF1d0FbaE96 stakingTokenWrapperFOXLaaS 0x3CD384ff1Fa1cbA8f06DF326AF4cbDA634aF94e8 stakingTokenWrapperUMALaaS 0x90B336dFF819b9e4b3D9A32cabdcAB0E92836065 stakingTokenWrapperSYNLaaS 0x5Db85e395735Bb42eEB720Fe2EE69627d246e300 stakingTokenWrapperNEARLaaS 0x3b3591a4f7FD386E9987Eb48d898e29b57c30c47 stakingTokenWrapperKYLINLaaS 0xFe266d143dB42a9835e2B1AB43B64a46278398cc stakingTokenWrapperMStableLaaS 0x9B9ad20Cd99Cac3B536b94497A18346d66db0379 stakingTokenWrapperPoolTogetherLaaS 0x6b018170311F3DA23c3fA62AFe1b2D0638522CCD FeiRari Name Address rariPool8Comptroller 0xc54172e34046c1653d1920d40333dd358c7a1af4 rariPool8Dai 0x7e9cE3CAa9910cc048590801e64174957Ed41d43 rariPool8DaiIrm 0xede47399e2aa8f076d40dc52896331cba8bd40f7 rariPool8Eth 0xbB025D470162CC5eA24daF7d4566064EE7f5F111 rariPool8EthIrm 0xbab47e4b692195bf064923178a90ef999a15f819 rariPool8Fei 0xd8553552f8868C1Ef160eEdf031cF0BCf9686945 rariPool8FeiIrm 0x8f47be5692180079931e2f983db6996647aba0a5 rariPool8Tribe 0xFd3300A9a74b3250F1b2AbC12B47611171910b07 rariPool8TribeIrm 0x075538650a9c69ac8019507a7dd1bd879b12c1d7","title":"Addresses"},{"location":"developers/addresses/#core","text":"Name Address tribeMinter 0xFC3532b443383d9022b1B2c6FD5Fd0895943360A pcvGuardian 0x2D1b1b509B6432A73e3d798572f0648f6453a5D9 feiTribeLBPSwapper 0x16ef9601076d45e8cc564cDD91E5dF3Ae83dD3B3 pcvEquityMinter 0x904Deb2Dac1EdfCBBb69b9c279aE5F75E57Cf5E9 collateralizationOracleGuardian 0x81De6bA8df84A4B679061952E171a27F096F3eAe core 0x8d5ED43dCa8C2F7dFB20CF7b53CC7E593635d7b9 fei 0x956F47F50A910163D8BF957Cf5846D573E7f87CA optimisticMinter 0xE66c4De480Bd317054B5a3CF8E8689649d0728c9 proxyAdmin 0xf8c2b645988b7658E7748BA637fE25bdD46A704A ratioPCVController 0xB1410aeCe2c65fE9e107c58b5aa32e91B18f0BC7 tribe 0xc7283b66Eb1EB5FB86327f08e1B5816b0720212B","title":"Core"},{"location":"developers/addresses/#governance","text":"Name Address tribeRariDAO 0x637deEED4e4deb1D222650bD4B64192abf002c00 rariTimelock 0x8ace03Fc45139fDDba944c6A4082b604041d19FC feiDAO 0x0BEF27FEB58e857046d630B2c03dFb7bae567494 feiDAOTimelock 0xd51dbA7a94e1adEa403553A8235C302cEbF41a3c guardian 0xB8f482539F2d3Ae2C9ea6076894df36D1f632775 optimisticTimelock 0xbC9C084a12678ef5B516561df902fdc426d95483 timelock 0x639572471f2f318464dc01066a56867130e45E25 optimisticMultisig 0x35ED000468f397AA943009bD60cc6d2d9a7d32fF","title":"Governance"},{"location":"developers/addresses/#peg","text":"Name Address daiPCVDripController 0x3e0f66c5687FF917809A3F7fA7096e1Bc409fB03 tribeReserveStabilizer 0xE1A468418f4D8D3F070A06d49b3575A9562b6CfD daiPSM 0x210300C158f95E1342fD008aE417ef68311c49C2 aaveEthPCVDripController 0xb3D63876d95d3a5e591D4DE536dC410b97244086 bondingCurve 0xB783c0E21763bEf9F2d04E6499abFbe23AdB7e1F compoundEthPCVDripController 0xa84C8be28f3d560059339f06C6b6c5B23f53C58C daiBondingCurve 0xC0afe0E649e32528666F993ce63822c3840e941a ethReserveStabilizer 0x17305f0e18318994a57b494078CAC866A857F7b6 raiBondingCurve 0x25d60212D47Dd8F6Ff0469367E4c6C98Cd3411A5","title":"Peg"},{"location":"developers/addresses/#pcv","text":"Name Address agEurAngleUniswapPCVDeposit 0x7AC2Ab8143634419c5bc230A9f9955C3e29f64Ef d3poolCurvePCVDeposit 0x24F663c69Cd4B263cf5685A49013Ff5f1C898D24 d3poolConvexPCVDeposit 0x5ae217dE26f6Ff5F481C6e10ec48b2cf2fc857C8 aaveEthPCVDeposit 0x5B86887e171bAE0C2C826e87E34Df8D558C079B9 aaveFeiPCVDeposit 0xaFBd7Bd91B4c1Dd289EE47a4F030FBeDfa7ABc12 aaveRaiPCVDeposit 0xd2174d78637a40448112aa6B30F9B19e6CF9d1F9 compoundDaiPCVDeposit 0xe0f73b8d76D2Ad33492F995af218b03564b8Ce20 compoundEthPCVDeposit 0x4fCB1435fD42CE7ce7Af3cB2e98289F79d2962b3 creamFeiPCVDeposit 0x243C601CC5DaA3Ac250B14509804188347bd2aFB dpiUniswapPCVDeposit 0x902199755219A9f8209862d09F1891cfb34F59a3 ethLidoPCVDeposit 0xac38ee05c0204a1e119c625d0a560d6731478880 indexCoopFusePoolDpiPCVDeposit 0x3dD3d945C4253bAc5B4Cc326a001B7d3f9C4DD66 indexCoopFusePoolFeiPCVDeposit 0xD6960adba53212bBE96E54a7AFeDA2066437D000 indexDelegator 0x0ee81df08B20e4f9E0F534e50da437D24491c4ee liquityFusePoolLusdPCVDeposit 0x8C51E4532CC745cF3DFec5CEBd835D07E7BA1002 feiLusdLBPSwapper 0x5fc76F8Fc3AF2b19D45AC841252dcE711ed448ff poolPartyFeiPCVDeposit 0x5A8CB4556e5D5935Af06beab8292905f48131479 rariPool19DpiPCVDeposit 0x3dD3d945C4253bAc5B4Cc326a001B7d3f9C4DD66 rariPool18FeiPCVDeposit 0x5A8CB4556e5D5935Af06beab8292905f48131479 rariPool19FeiPCVDeposit 0xD6960adba53212bBE96E54a7AFeDA2066437D000 rariPool22FeiPCVDeposit 0x7CeBaB7b4B4399343f6D0D36B550EE097F60d7fE rariPool24FeiPCVDeposit 0x1434F99EDB2bD03DECCCFe21288767b8324B7403 rariPool25FeiPCVDeposit 0xe1662531aA5de1DAD8ab5B5756b8F6c8F3C759Ca rariPool26FeiPCVDeposit 0xFdCc96967C86250f333cE52Ba706Ec2961c3302f rariPool27FeiPCVDeposit 0x91f50E3183a8CC30D2A981C3aFA85A2Bf6691c67 rariPool28FeiPCVDeposit 0xb0D5eBA35E1cecE568096064Ed68A49C6A24d961 rariPool31FeiPCVDeposit 0x81DCB06eA4db474D1506Ca6275Ff7D870bA3A1Be rariPool54FeiPCVDeposit 0x9d28B8Cb17c3E25b6Cce17f88B259f75174b69f4 rariPool6FeiPCVDeposit 0xB51f09B6F103D697dc5d64DC904Ad6a2Dad39987 rariPool7FeiPCVDeposit 0x74B235Fef146cDB5BE0D3786a9f3774674b3615E rariPool7LusdPCVDeposit 0x6026a1559CDd44a63C5CA9A078CC996a9eb68ABB rariPool72FeiPCVDeposit 0x4A5Af5A124E672C156241b76CAd4E41D09dd4883 rariPool79FeiPCVDeposit 0x76dFcf06E7D7B8248094DC319b284fB244f06309 rariPool8FeiPCVDeposit 0x37349d9cc523D28e6aBFC03fc5F44879bC8BfFD9 rariPool9FeiPCVDeposit 0xF2D8beE45f29A779cFB9F04ac233E703974a2C53 rariPool9RaiPCVDeposit 0x9aAdFfe00eAe6d8e59bB4F7787C6b99388A6960D rariPool90FeiPCVDeposit 0x61d26126D2F8A44b41c1D8E1B1F276551DC8EEc6 rariPool91FeiPCVDeposit 0x2296a2417D1f02d394ab22aF794a0f426eD53436 reflexerStableAssetFusePoolRaiPCVDeposit 0x9aAdFfe00eAe6d8e59bB4F7787C6b99388A6960D ethTokemakPCVDeposit 0x0961d2a545e0c1201B313d14C57023682a546b9D tokeTokemakPCVDeposit 0x45C8FaB07B64C78d03006591132Ac51DE82a4B22 uniswapPCVDeposit 0x15958381E9E6dc98bD49655e36f524D2203a28bD","title":"PCV"},{"location":"developers/addresses/#collateralization","text":"Name Address feiLusdLens 0x1F05b337cB16CeA2a1C638Ba9b9571F0Cf4a5612 aaveFeiPCVDepositWrapper 0xFAc571b6054619053ac311dA8112939C9a374A85 creamDepositWrapper 0x3a1838Ac9EcA864054bebB82C32455Dd7d7Fc89c balDepositWrapper 0x7E28BA7a2D52Af88242E588d868E927119BA45dB staticPcvDepositWrapper2 0xe72EB93de743F819fe91277582d7d0Fa9bb9b023 feiBuybackLens 0x107460564896377BA6CdcC7516c7eAb65E32E360 collateralizationOracleKeeper 0x62378C316a6161A613D02E11F65290aED79B3eD5 staticPcvDepositWrapper 0x8B41DcEfAe6064E6bc2A9B3ae20141d23EFD6cbd ethReserveStabilizerWrapper 0xB24570Bc46efDf97b4Aa7f008B4268005Eb7A27E daiBondingCurveWrapper 0x2547d76E2447E67F29d6bFeE5d46FDd2183c88E4 raiBondingCurveWrapper 0xc42e155788f9f599Fd437C7455F63810A395a81f dpiBondingCurveWrapper 0x60B63eF8f461355207fE1d8102dda938bbd8c3fB rariPool19DpiPCVDepositWrapper 0x9a774a1B1208C323EDeD05E6Daf592E6E59cAa55 ethLidoPCVDepositWrapper 0xA271fF86426c7fdAaAE72603e6Ce68c892d69ED7 compoundDaiPCVDepositWrapper 0xfDe7077AAEcDaf2C4B85261Aa858c96A7E737a61 compoundEthPCVDepositWrapper 0x0735e14D28eD395048d5Fa4a8dbe6e6EB9fc0470 aaveRaiPCVDepositWrapper 0x1267B39c93711Dd374DEAB15e0127e4adB259BE0 aaveEthPCVDepositWrapper 0x43Ef03755991056681F01EE2182234eF6aF1f658 rariPool9RaiPCVDepositWrapper 0xCCe230c087F31032fc17621a2CF5E425A0b80C96 creamFeiPCVDepositWrapper 0xFf419Bc27483edb94b7Ad5c97b7FaB5DB323c7E0 rariPool8FeiPCVDepositWrapper 0xD6598a23418c7FEf7c0Dc863265515B623B720F9 rariPool9FeiPCVDepositWrapper 0x96A657eE40A79A964c6b4eA551c895D98e885a75 rariPool7FeiPCVDepositWrapper 0xb13C755107301eBFeD6A93190aCdE09281b2f8A5 rariPool6FeiPCVDepositWrapper 0x7aA4b1558C3e219cFFFd6a356421C071F71966e7 rariPool19FeiPCVDepositWrapper 0x7e39bBA9D0d967Ee55524fAe9e54900B02d9889a rariPool24FeiPCVDepositWrapper 0x508f6fbd78B6569C29E9D75986a51558dE9E5865 rariPool25FeiPCVDepositWrapper 0xB4FFD10C4C290Dc13E8e30BF186F1509001515fD rariPool26FeiPCVDepositWrapper 0x82aebeE64a52180d8541eB601A8381e012A1eD04 rariPool27FeiPCVDepositWrapper 0xe2e35097638F0Ff2EeCA2EF70F352Be37431945f rariPool18FeiPCVDepositWrapper 0x07F2DD7E6A78D96c08D0a8212f4097dCC129d629 rariPool28FeiPCVDepositWrapper 0x4E119714f625B2E82e5fB5A7E297978f020Ea51E rariPool31FeiPCVDepositWrapper 0x05E2e93CFb0B53D36A3151ee727Bb581D4B918Ce feiOATimelockWrapper 0x7Eb88140af813294aEDce981b6aC08fcd139d408 collateralizationOracle 0xFF6f59333cfD8f4Ebc14aD0a0E181a83e655d257 collateralizationOracleWrapperImpl 0x656aA9c9875eB089b11869d4730d6963D25E76ad collateralizationOracleWrapper 0xd1866289B4Bd22D453fFF676760961e0898EE9BF","title":"Collateralization"},{"location":"developers/addresses/#oracle","text":"Name Address chainlinkLUSDOracle 0xe61d11ec732d556A26fb863B192052BEa03eF8B5 chainlinkCREAMEthOracle 0xDE02522cDc4959117fe839a7326D80F9858f383C chainlinkBALEthOracle 0x7261D245454Daa070C77B2a26eA192E3a4c8F655 balUsdCompositeOracle 0xDe0407851AEC6F073A63D27C7D29805CCD59D3e0 creamUsdCompositeOracle 0x2BDca027c7f57eD9AC1769Ba3a3D64600578bA49 chainlinkEurUsdOracleWrapper 0xFb3a062236A7E08b572F17bc9Ad2bBc2becB87b1 chainlinkTribeEthOracleWrapper 0x061118ccabF0c2c62f05a2e3C2bd4379c0C70079 tribeUsdCompositeOracle 0xD7B8207f8644ee5cc60095023a8fcb8BdCF54732 oneConstantOracle 0x2374800337c6BE8B935f96AA6c10b33f9F12Bd40 zeroConstantOracle 0x43b99923CF06D6D9101110b595234670f73A4934 chainlinkDaiUsdOracleWrapper 0x231aDa12E273eDf3fA54CbD90c5C1a73129D5bb9 chainlinkDpiUsdOracleWrapper 0xB594d2bd55Ede471e16b92AE6F7651648DA871c3 chainlinkEthUsdOracleWrapper 0xCd3c40AE1256922BA16C7872229385E20Bc8351e chainlinkFeiEthOracleWrapper 0x060Be7B51F78DFFd04749332fd306BA1228e7444 chainlinkRaiEthOracleWrapper 0x3d49573ee6aFCBDe606F8a1c2AA1C498048E7190 chainlinkRaiUsdCompositOracle 0x392b1d29eDab680c5CA778D3A32b8284859BFBB0 chainlinkTribeEthOracle 0x84a24deCA415Acc0c395872a9e6a63E27D6225c8 compositeOracle 0x8721f9EAba0B9081069970bCBce38763D3D4f28E","title":"Oracle"},{"location":"developers/addresses/#keeper","text":"Name Address","title":"Keeper"},{"location":"developers/addresses/#rewards","text":"Name Address aaveTribeIncentivesController 0xDee5c1662bBfF8f80f7c572D8091BF251b3B0dAB aaveTribeIncentivesControllerProxy 0xDee5c1662bBfF8f80f7c572D8091BF251b3B0dAB aaveTribeIncentivesControllerImpl 0xFF865335401F12B88fa3FF5A3a51685A7f224191 erc20Dripper 0x3Fe0EAD3500e767F0F8bC2d3B5AF7755B1b21A6a rewardsDistributorAdmin 0x4e979E8b136Cd7BdEBB83ea50a599C3BED1e15c0 autoRewardsDistributor 0x61be49dfbd869a601fea076e1a1379903e61a895 rariRewardsDistributorDelegator 0x73F16f0c0Cd1A078A54894974C5C054D8dC1A3d7 rariRewardsDistributorDelegate 0x220f93183a69d1598e8405310cB361CFF504146F stakingTokenWrapperRari 0xd81Be1B9A7895C996704A8DDa794BbA4454EeB90 tribalChief 0x9e1076cC0d19F9B0b8019F384B0a29E48Ee46f7f tribalChiefImpl 0x2d91362e8bcAA8826b482B531dcb170FC9d17777 tribalChiefSync 0x7A883825caA45fcbDcd76991C5972Baf1551aa3d stakingTokenWrapperGROLaaS 0x508629e8E0B96986Df4D0F1F60aadeF1d0FbaE96 stakingTokenWrapperFOXLaaS 0x3CD384ff1Fa1cbA8f06DF326AF4cbDA634aF94e8 stakingTokenWrapperUMALaaS 0x90B336dFF819b9e4b3D9A32cabdcAB0E92836065 stakingTokenWrapperSYNLaaS 0x5Db85e395735Bb42eEB720Fe2EE69627d246e300 stakingTokenWrapperNEARLaaS 0x3b3591a4f7FD386E9987Eb48d898e29b57c30c47 stakingTokenWrapperKYLINLaaS 0xFe266d143dB42a9835e2B1AB43B64a46278398cc stakingTokenWrapperMStableLaaS 0x9B9ad20Cd99Cac3B536b94497A18346d66db0379 stakingTokenWrapperPoolTogetherLaaS 0x6b018170311F3DA23c3fA62AFe1b2D0638522CCD","title":"Rewards"},{"location":"developers/addresses/#feirari","text":"Name Address rariPool8Comptroller 0xc54172e34046c1653d1920d40333dd358c7a1af4 rariPool8Dai 0x7e9cE3CAa9910cc048590801e64174957Ed41d43 rariPool8DaiIrm 0xede47399e2aa8f076d40dc52896331cba8bd40f7 rariPool8Eth 0xbB025D470162CC5eA24daF7d4566064EE7f5F111 rariPool8EthIrm 0xbab47e4b692195bf064923178a90ef999a15f819 rariPool8Fei 0xd8553552f8868C1Ef160eEdf031cF0BCf9686945 rariPool8FeiIrm 0x8f47be5692180079931e2f983db6996647aba0a5 rariPool8Tribe 0xFd3300A9a74b3250F1b2AbC12B47611171910b07 rariPool8TribeIrm 0x075538650a9c69ac8019507a7dd1bd879b12c1d7","title":"FeiRari"},{"location":"developers/bug-bounty/","text":"Bug Bounty Bug Bounties Program overview Fei Protocol's goal is to maintain a liquid market in which ETH/FEI trades closely to the ETH/USD price. FEI achieves this via a new stability mechanism known as direct incentives. Direct incentive stable coins use dynamic mint rewards and burn penalties on DEX trade volume to maintain the peg. Governance can add and update DEX integrations and other incentives as needed, which uses the TRIBE governance token. The bug bounty program is focused on its smart contracts and website and the prevention of the loss of user funds and the disruption of the governance system. All bug submissions must go through Immunefi's bug submission process on the Fei bug bounty page The Fei bug bounty page can be viewed at https://immunefi.com/bounty/feiprotocol . When a hacker hits the \"Submit bug report\" button, they will be sent to bugs.immunefi.com which will guide them through the process of creating a bug report. Rewards by threat level Rewards are distributed according to the impact of the vulnerability based on the Immunefi Vulnerability Severity Classification System . This is a simplified 5-level scale, with separate scales for websites/apps and smart contracts/blockchains, encompassing everything from a consequence of exploitation to privilege required to the likelihood of a successful exploit. Smart Contracts and Blockchain Critical* Up to USD 1 000 000 High USD 7 500 Medium USD 3 250 Low USD 1 000 Websites and Apps Critical USD 15 000 High USD 10 000 Medium USD 1 000 Low USD 200 Payouts are handled by the Fei Protocol team directly and are denominated in USD. However, payouts are done in TRIBE or FEI . *Critical-level smart contract vulnerabilities that result in the loss of user funds will have rewards additionally capped at 10% of the funds potentially affected based on the vulnerability that was identified. These rewards are additionally only payable in TRIBE and have a vesting schedule lasting between 6-12 months with a minimum of 6 months for rewards up to USD 400 000, with an additional month added for every USD 100,000 tranche, rounded up. Assets in Scope Prioritized vulnerabilities We are especially interested in receiving and rewarding vulnerabilities of the following types: Smart Contracts and Blockchain Re-entrancy Logic errors including user authentication errors Solidity/EVM details not considered including integer over-/under-flow including unhandled exceptions Trusting trust/dependency vulnerabilities including composability vulnerabilities Oracle failure/manipulation Novel governance attacks Economic/financial attacks including flash loan attacks Congestion and scalability including running out of gas including block stuffing including susceptibility to frontrunning Consensus failures Cryptography problems Signature malleability Susceptibility to replay attacks Weak randomness Weak encryption Susceptibility to block timestamp manipulation Missing access controls / unprotected internal or debugging interfaces Websites and Apps Remote Code Execution Trusting trust/dependency vulnerabilities Vertical Privilege Escalation XML External Entities Injection SQL Injection LFI/RFI Horizontal Privilege Escalation Stored XSS Reflective XSS with impact CSRF CSRF with impact Direct object reference Internal SSRF Session fixation Insecure Deserialization Direct object reference Path Traversal DOM XSS SSL misconfigurations SPF configuration problems SSL/TLS issues (weak crypto, improper setup) URL redirect Clickjacking Misleading Unicode text (e.g., using right to left override characters) Coercing the application to display/return specific text to other users Out of Scope & Rules The following vulnerabilities are excluded from the rewards for this bug bounty program: All Programs Attacks that the reporter has already exploited themselves, leading to damage Attacks requiring access to leaked keys/credentials Attacks requiring access to privileged addresses (governance, strategist) Smart Contracts and Blockchain Incorrect data supplied by third party oracles Not to exclude oracle manipulation/flash loan attacks Basic economic governance attacks (e.g. 51% attack) Lack of liquidity Best practice critiques Sybil attacks Websites and Apps Theoretical vulnerabilities without any proof or demonstration Content spoofing / Text injection issues Self-XSS Captcha bypass using OCR CSRF with no security impact (logout CSRF, change language, etc.) Missing HTTP Security Headers (such as X-FRAME-OPTIONS) or cookie security flags (such as \u201chttponly\u201d) Server-side information disclosure such as IPs, server names, and most stack traces Vulnerabilities used to enumerate or confirm the existence of users or tenants Vulnerabilities requiring unlikely user actions URL Redirects (unless combined with another vulnerability to produce a more severe vulnerability) Lack of SSL/TLS best practices DDoS vulnerabilities Attacks requiring privileged access from within the organization The bug bounty program prohibits the following activities: Any testing with mainnet or public testnet contracts; all testing should be done on private testnets Any testing with pricing oracles or third party smart contracts Attempting phishing or other social engineering attacks against our employees and/or customers Any testing with third-party systems and applications (e.g., browser extensions) as well as websites (e.g., SSO providers, advertising networks) Any denial of service attacks Automated testing of services that generates significant amounts of traffic Public disclosure of an unpatched vulnerability in an embargoed bounty","title":"Bug Bounty"},{"location":"developers/bug-bounty/#bug-bounty","text":"","title":"Bug Bounty"},{"location":"developers/bug-bounty/#bug-bounties","text":"Program overview Fei Protocol's goal is to maintain a liquid market in which ETH/FEI trades closely to the ETH/USD price. FEI achieves this via a new stability mechanism known as direct incentives. Direct incentive stable coins use dynamic mint rewards and burn penalties on DEX trade volume to maintain the peg. Governance can add and update DEX integrations and other incentives as needed, which uses the TRIBE governance token. The bug bounty program is focused on its smart contracts and website and the prevention of the loss of user funds and the disruption of the governance system. All bug submissions must go through Immunefi's bug submission process on the Fei bug bounty page The Fei bug bounty page can be viewed at https://immunefi.com/bounty/feiprotocol . When a hacker hits the \"Submit bug report\" button, they will be sent to bugs.immunefi.com which will guide them through the process of creating a bug report. Rewards by threat level Rewards are distributed according to the impact of the vulnerability based on the Immunefi Vulnerability Severity Classification System . This is a simplified 5-level scale, with separate scales for websites/apps and smart contracts/blockchains, encompassing everything from a consequence of exploitation to privilege required to the likelihood of a successful exploit. Smart Contracts and Blockchain Critical* Up to USD 1 000 000 High USD 7 500 Medium USD 3 250 Low USD 1 000 Websites and Apps Critical USD 15 000 High USD 10 000 Medium USD 1 000 Low USD 200 Payouts are handled by the Fei Protocol team directly and are denominated in USD. However, payouts are done in TRIBE or FEI . *Critical-level smart contract vulnerabilities that result in the loss of user funds will have rewards additionally capped at 10% of the funds potentially affected based on the vulnerability that was identified. These rewards are additionally only payable in TRIBE and have a vesting schedule lasting between 6-12 months with a minimum of 6 months for rewards up to USD 400 000, with an additional month added for every USD 100,000 tranche, rounded up. Assets in Scope Prioritized vulnerabilities We are especially interested in receiving and rewarding vulnerabilities of the following types: Smart Contracts and Blockchain Re-entrancy Logic errors including user authentication errors Solidity/EVM details not considered including integer over-/under-flow including unhandled exceptions Trusting trust/dependency vulnerabilities including composability vulnerabilities Oracle failure/manipulation Novel governance attacks Economic/financial attacks including flash loan attacks Congestion and scalability including running out of gas including block stuffing including susceptibility to frontrunning Consensus failures Cryptography problems Signature malleability Susceptibility to replay attacks Weak randomness Weak encryption Susceptibility to block timestamp manipulation Missing access controls / unprotected internal or debugging interfaces Websites and Apps Remote Code Execution Trusting trust/dependency vulnerabilities Vertical Privilege Escalation XML External Entities Injection SQL Injection LFI/RFI Horizontal Privilege Escalation Stored XSS Reflective XSS with impact CSRF CSRF with impact Direct object reference Internal SSRF Session fixation Insecure Deserialization Direct object reference Path Traversal DOM XSS SSL misconfigurations SPF configuration problems SSL/TLS issues (weak crypto, improper setup) URL redirect Clickjacking Misleading Unicode text (e.g., using right to left override characters) Coercing the application to display/return specific text to other users Out of Scope & Rules The following vulnerabilities are excluded from the rewards for this bug bounty program: All Programs Attacks that the reporter has already exploited themselves, leading to damage Attacks requiring access to leaked keys/credentials Attacks requiring access to privileged addresses (governance, strategist) Smart Contracts and Blockchain Incorrect data supplied by third party oracles Not to exclude oracle manipulation/flash loan attacks Basic economic governance attacks (e.g. 51% attack) Lack of liquidity Best practice critiques Sybil attacks Websites and Apps Theoretical vulnerabilities without any proof or demonstration Content spoofing / Text injection issues Self-XSS Captcha bypass using OCR CSRF with no security impact (logout CSRF, change language, etc.) Missing HTTP Security Headers (such as X-FRAME-OPTIONS) or cookie security flags (such as \u201chttponly\u201d) Server-side information disclosure such as IPs, server names, and most stack traces Vulnerabilities used to enumerate or confirm the existence of users or tenants Vulnerabilities requiring unlikely user actions URL Redirects (unless combined with another vulnerability to produce a more severe vulnerability) Lack of SSL/TLS best practices DDoS vulnerabilities Attacks requiring privileged access from within the organization The bug bounty program prohibits the following activities: Any testing with mainnet or public testnet contracts; all testing should be done on private testnets Any testing with pricing oracles or third party smart contracts Attempting phishing or other social engineering attacks against our employees and/or customers Any testing with third-party systems and applications (e.g., browser extensions) as well as websites (e.g., SSO providers, advertising networks) Any denial of service attacks Automated testing of services that generates significant amounts of traffic Public disclosure of an unpatched vulnerability in an embargoed bounty","title":"Bug Bounties"},{"location":"developers/developers/","text":"Fei Developer Documentation Table of Contents Changelog - TODO Addresses Protocol - TODO Development and Testing - TODO Bug Bounty","title":"Developer"},{"location":"developers/developers/#fei-developer-documentation","text":"","title":"Fei Developer Documentation"},{"location":"developers/developers/#table-of-contents","text":"Changelog - TODO Addresses Protocol - TODO Development and Testing - TODO Bug Bounty","title":"Table of Contents"},{"location":"old/SUMMARY/","text":"Table of contents Overview White Paper Audits Bug Bounty User Guides Staking FEI:TRIBE LP Steps for Staking Unstaking FIP-2 FEI Redemption Guide DAO Voting and Delegation Connect Your Wallet Delegate Votes Vote on an Active Proposal Disconnect Your Wallet Protocol Contract Addresses Access Control Core Permissions Fei Stablecoin FEI (Fei USD) UniswapIncentive Protocol Controlled Value EthReserveStabilizer EthPCVDepositAdapter RatioPCVController EthPCVDripper EthUniswapPCVDeposit UniswapPCVDeposit EthUniswapPCVController Bonding Curves EthBondingCurve BondingCurve Trading FeiRouter Oracles BondingCurveOracle UniswapOracle Staking FeiRewardsDistributor FeiStakingRewards Genesis GenesisGroup IDO TimelockedDelegator References/Utils LinearTokenTimelock Timed CoreRef OracleRef UniRef Changelog Governance Fei DAO Tribe Fei Guardian Snapshot Voting","title":"Table of contents"},{"location":"old/SUMMARY/#table-of-contents","text":"Overview White Paper Audits Bug Bounty","title":"Table of contents"},{"location":"old/SUMMARY/#user-guides","text":"Staking FEI:TRIBE LP Steps for Staking Unstaking FIP-2 FEI Redemption Guide DAO Voting and Delegation Connect Your Wallet Delegate Votes Vote on an Active Proposal Disconnect Your Wallet","title":"User Guides"},{"location":"old/SUMMARY/#protocol","text":"Contract Addresses Access Control Core Permissions Fei Stablecoin FEI (Fei USD) UniswapIncentive Protocol Controlled Value EthReserveStabilizer EthPCVDepositAdapter RatioPCVController EthPCVDripper EthUniswapPCVDeposit UniswapPCVDeposit EthUniswapPCVController Bonding Curves EthBondingCurve BondingCurve Trading FeiRouter Oracles BondingCurveOracle UniswapOracle Staking FeiRewardsDistributor FeiStakingRewards Genesis GenesisGroup IDO TimelockedDelegator References/Utils LinearTokenTimelock Timed CoreRef OracleRef UniRef Changelog","title":"Protocol"},{"location":"old/SUMMARY/#governance","text":"Fei DAO Tribe Fei Guardian Snapshot Voting","title":"Governance"},{"location":"old/audit/","text":"Audits OpenZeppelin OpenZeppelin conducted Fei Protocol's primary audit. The audit was performed by 3 auditors over 5 weeks. The final outcome of the report: openzeppelin_audit ConsenSys Diligence ConsenSys audit reviewed the most critical contracts including the Genesis Group and additional contracts that were out of scope for the primary audit. The audit was performed by 3 auditors over 1 week. The final outcome of the report: diligence_audit","title":"Audits"},{"location":"old/audit/#audits","text":"","title":"Audits"},{"location":"old/audit/#openzeppelin","text":"OpenZeppelin conducted Fei Protocol's primary audit. The audit was performed by 3 auditors over 5 weeks. The final outcome of the report: openzeppelin_audit","title":"OpenZeppelin"},{"location":"old/audit/#consensys-diligence","text":"ConsenSys audit reviewed the most critical contracts including the Genesis Group and additional contracts that were out of scope for the primary audit. The audit was performed by 3 auditors over 1 week. The final outcome of the report: diligence_audit","title":"ConsenSys Diligence"},{"location":"old/development-guide/","text":"Development Guide Protocol Development Fei Protocol is controlled by the DAO at launch. The Fei Core Team suggests this workflow for making protocol changes: Introduce idea in #development in Discord Informal discussion in Discord Formal proposal on our forum Snapshot voting on snapshot.page If required, pull request to fei-protocol-core DAO proposal Pull Requests To make a pull request with changes, create a branch with the name format: FIP-<number>-<description> . Members of the Fei Core Team and the growing Fei community should review all proposed changes. Upon review, major features will be considered for audit reviews by our audit partners. Audits can be initiated and sponsored by the Fei Core Team and would enable our contributors to collaborate directly with the best auditors in the space. Ecosystem Development Our goal is to enable as many two-way integrations with other DeFi platforms including lending platforms, derivatives platforms, and AMMs. We expect and encourage the development of community-led bots, tooling, dashboards, and even supporting features directly on Ethereum. Platform integrations should follow respective platform governance procedures and community engagement. The Fei Core Team is excited at the opportunity to collaborate and sponsor community-led integrations with resources and tokens.","title":"Development Guide"},{"location":"old/development-guide/#development-guide","text":"","title":"Development Guide"},{"location":"old/development-guide/#protocol-development","text":"Fei Protocol is controlled by the DAO at launch. The Fei Core Team suggests this workflow for making protocol changes: Introduce idea in #development in Discord Informal discussion in Discord Formal proposal on our forum Snapshot voting on snapshot.page If required, pull request to fei-protocol-core DAO proposal","title":"Protocol Development"},{"location":"old/development-guide/#pull-requests","text":"To make a pull request with changes, create a branch with the name format: FIP-<number>-<description> . Members of the Fei Core Team and the growing Fei community should review all proposed changes. Upon review, major features will be considered for audit reviews by our audit partners. Audits can be initiated and sponsored by the Fei Core Team and would enable our contributors to collaborate directly with the best auditors in the space.","title":"Pull Requests"},{"location":"old/development-guide/#ecosystem-development","text":"Our goal is to enable as many two-way integrations with other DeFi platforms including lending platforms, derivatives platforms, and AMMs. We expect and encourage the development of community-led bots, tooling, dashboards, and even supporting features directly on Ethereum. Platform integrations should follow respective platform governance procedures and community engagement. The Fei Core Team is excited at the opportunity to collaborate and sponsor community-led integrations with resources and tokens.","title":"Ecosystem Development"},{"location":"old/fip-2-fei-redemption-guide/","text":"FIP-2 FEI Redemption Guide If you own FEI and would like to redeem it at $0.95 USD for ETH, you can go to the Fei app Redeem tab . Redemption Steps: Connect your wallet Enter the amount of FEI you would like to redeem and submit transaction Initiate transaction by pressing Redeem button The redemption contract receives a 5000 ETH hourly drip from the 300,000 ETH allocation as long as there is less than 5000 ETH in the redemption contract. {% hint style=\"info\" %} Current amount of ETH in the redemption contract (EthReserveStabilizer): Current ETH Available Balance of ETH redeemable: Total ETH Available {% endhint %} If there is an insufficient amount of ETH in the redemption contract to fully redeem your FEI you will be notified: You can consider a partial redemption or attempt again at a later time. {% hint style=\"info\" %} It is likely that there will be some initial frontrunning of the redemption process. If you don\u2019t want to execute partial redemptions or wait for the redemption contract to refill to the required amount of ETH needed for your complete redemption, you can check Fei app Exchange or secondary markets as an alternative. {% endhint %} ****","title":"FIP-2 FEI Redemption Guide"},{"location":"old/fip-2-fei-redemption-guide/#fip-2-fei-redemption-guide","text":"If you own FEI and would like to redeem it at $0.95 USD for ETH, you can go to the Fei app Redeem tab . Redemption Steps: Connect your wallet Enter the amount of FEI you would like to redeem and submit transaction Initiate transaction by pressing Redeem button The redemption contract receives a 5000 ETH hourly drip from the 300,000 ETH allocation as long as there is less than 5000 ETH in the redemption contract. {% hint style=\"info\" %} Current amount of ETH in the redemption contract (EthReserveStabilizer): Current ETH Available Balance of ETH redeemable: Total ETH Available {% endhint %} If there is an insufficient amount of ETH in the redemption contract to fully redeem your FEI you will be notified: You can consider a partial redemption or attempt again at a later time. {% hint style=\"info\" %} It is likely that there will be some initial frontrunning of the redemption process. If you don\u2019t want to execute partial redemptions or wait for the redemption contract to refill to the required amount of ETH needed for your complete redemption, you can check Fei app Exchange or secondary markets as an alternative. {% endhint %} ****","title":"FIP-2 FEI Redemption Guide"},{"location":"old/testing-guide/","text":"Testing Guide Setup Fei Protocol Core uses the following tools for testing, development, and coverage: Truffle Ganache-cli OpenZeppelin CLI Mocha To install, run npm install Unit Tests There are extensive unit tests covering the protocol code, with the exception of forked and external contracts. To run the unit tests, run npm run test Here is a sample output: {% file src=\"../.gitbook/assets/fei_tests (1).txt\" caption=\"Unit Tests\" %} {% file src=\"../.gitbook/assets/fei_coverage (1).txt\" caption=\"Test Coverage\" %} Integration Tests There are several integration tests which go deeper into various functionality of the protocol, using a mainnet fork and fully deployed and linked contracts. The following configurations need to be in place: create an Alchemy mainnet project and add export MAINNET_ALCHEMY_API_KEY=\"<KEY>\" to your .bashrc or .bash_profile run ganache-cli with mainnet fork: ganache-cli -e 10000000 -g 200000000 -l 8000000 -f https://eth-mainnet.alchemyapi.io/v2/$MAINNET_ALCHEMY_API_KEY@11895000 -i 5777 -p 7545 In a separate terminal, open a truffle console by running truffle console --network ganache In the truffle console, run migrate {% hint style=\"info\" %} Keep ganache-cli and the truffle console running, and execute the following tests within the truffle console {% endhint %} End-to-end To run this test, within the truffle console run exec scripts/test/e2e.js This test will go through all of the main user flows, log some related info and gas price","title":"Testing Guide"},{"location":"old/testing-guide/#testing-guide","text":"","title":"Testing Guide"},{"location":"old/testing-guide/#setup","text":"Fei Protocol Core uses the following tools for testing, development, and coverage: Truffle Ganache-cli OpenZeppelin CLI Mocha To install, run npm install","title":"Setup"},{"location":"old/testing-guide/#unit-tests","text":"There are extensive unit tests covering the protocol code, with the exception of forked and external contracts. To run the unit tests, run npm run test Here is a sample output: {% file src=\"../.gitbook/assets/fei_tests (1).txt\" caption=\"Unit Tests\" %} {% file src=\"../.gitbook/assets/fei_coverage (1).txt\" caption=\"Test Coverage\" %}","title":"Unit Tests"},{"location":"old/testing-guide/#integration-tests","text":"There are several integration tests which go deeper into various functionality of the protocol, using a mainnet fork and fully deployed and linked contracts. The following configurations need to be in place: create an Alchemy mainnet project and add export MAINNET_ALCHEMY_API_KEY=\"<KEY>\" to your .bashrc or .bash_profile run ganache-cli with mainnet fork: ganache-cli -e 10000000 -g 200000000 -l 8000000 -f https://eth-mainnet.alchemyapi.io/v2/$MAINNET_ALCHEMY_API_KEY@11895000 -i 5777 -p 7545 In a separate terminal, open a truffle console by running truffle console --network ganache In the truffle console, run migrate {% hint style=\"info\" %} Keep ganache-cli and the truffle console running, and execute the following tests within the truffle console {% endhint %}","title":"Integration Tests"},{"location":"old/testing-guide/#end-to-end","text":"To run this test, within the truffle console run exec scripts/test/e2e.js This test will go through all of the main user flows, log some related info and gas price","title":"End-to-end"},{"location":"old/whitepaper/","text":"White Paper The Fei Protocol white paper is a static document explaining the concept and inspiration for v1 of the protocol. White Paper: {% embed url=\"https://fei.money/whitepaper\" caption=\"\" %} Changes to the protocol functionality are chronicled in the changelog: {% page-ref page=\"protocol/changelog.md\" %} Features with major functionality changes to the protocol could be published as individual feature white papers or articles as well.","title":"White Paper"},{"location":"old/whitepaper/#white-paper","text":"The Fei Protocol white paper is a static document explaining the concept and inspiration for v1 of the protocol. White Paper: {% embed url=\"https://fei.money/whitepaper\" caption=\"\" %} Changes to the protocol functionality are chronicled in the changelog: {% page-ref page=\"protocol/changelog.md\" %} Features with major functionality changes to the protocol could be published as individual feature white papers or articles as well.","title":"White Paper"},{"location":"old/dao-voting-and-delegation/","text":"DAO Voting and Delegation You can participate in governance through the Fei Protocol governance page through Tally by delegating your voting power or voting on active proposals directly. To access these features, start by connecting your Metamask wallet. {% page-ref page=\"connect-your-wallet.md\" %} {% page-ref page=\"delegate-votes.md\" %} {% page-ref page=\"vote-on-an-active-proposal.md\" %} Steps to disconnect your wallet or change between addresses are shown here. {% page-ref page=\"disconnect-your-wallet.md\" %}","title":"DAO Voting and Delegation"},{"location":"old/dao-voting-and-delegation/#dao-voting-and-delegation","text":"You can participate in governance through the Fei Protocol governance page through Tally by delegating your voting power or voting on active proposals directly. To access these features, start by connecting your Metamask wallet. {% page-ref page=\"connect-your-wallet.md\" %} {% page-ref page=\"delegate-votes.md\" %} {% page-ref page=\"vote-on-an-active-proposal.md\" %} Steps to disconnect your wallet or change between addresses are shown here. {% page-ref page=\"disconnect-your-wallet.md\" %}","title":"DAO Voting and Delegation"},{"location":"old/dao-voting-and-delegation/connect-your-wallet/","text":"Connect Your Wallet From the Fei Protocol Governance page on Tally, select the \"connect wallet\" button in the top right corner. On the pop up window, select the wallet you'd like to connect and click \"next\". Then click \"connect\" to confirm. You can view your connected wallet in the top right corner of the site. Your wallet has been connected successfully, and you can now participate in governance through the Tally app.","title":"Connect Your Wallet"},{"location":"old/dao-voting-and-delegation/connect-your-wallet/#connect-your-wallet","text":"From the Fei Protocol Governance page on Tally, select the \"connect wallet\" button in the top right corner. On the pop up window, select the wallet you'd like to connect and click \"next\". Then click \"connect\" to confirm. You can view your connected wallet in the top right corner of the site. Your wallet has been connected successfully, and you can now participate in governance through the Tally app.","title":"Connect Your Wallet"},{"location":"old/dao-voting-and-delegation/delegate-votes/","text":"Delegate Votes Before getting started, ensure that you have connected your wallet. You can delegate votes to yourself or to another address. This only must be done once. {% hint style=\"warning\" %} Note tokens you own are not active for voting until you delegate. You must delegate to yourself if you wish to vote on proposals directly with your own tokens. {% endhint %} First, navigate to the Fei Protocol governance page: https://www.withtally.com/governance/fei . Delegate to yourself (set up wallet for direct voting): Click on the button to \"delegate to self\". Select \"direct delegation\", and then click the \"delegate\" button. Confirm and sign the transaction via Metamask. Delegate votes to another address: Navigate to the delegate leaderboard at the bottom of the Fei Protocol governance page. If your preferred delegate is not in the top 10 addresses by voting power, click on the \"view all\" link to view additional delegates. Click on the address you'd like to support to view their voter page. Then click on the \"delegate vote\" button on the right hand side. Select \"direct delegation\", and then click the \"delegate\" button. Confirm and sign the transaction via Metamask. Confirm your delegation status: Start by navigating to your address's voter page. If you are among the top 100 addresses by voting power, you can link to your voter page through the \"top voters\" table at the bottom of the governance page. Alternatively, you can view your address's voter page by pasting the following link into your browser with the relevant details. https://www.withtally.com/voter/[your ethereum address]/governance/fei `` Once you've accessed your voter page, review the \"delegating to\" section on the right hand side. If you delegated votes to yourself (set up your address for direct voting), you should see \"self delegation\". If you delegated votes to another address, this section will display a link to that address's voter page.","title":"Delegate Votes"},{"location":"old/dao-voting-and-delegation/delegate-votes/#delegate-votes","text":"Before getting started, ensure that you have connected your wallet. You can delegate votes to yourself or to another address. This only must be done once. {% hint style=\"warning\" %} Note tokens you own are not active for voting until you delegate. You must delegate to yourself if you wish to vote on proposals directly with your own tokens. {% endhint %} First, navigate to the Fei Protocol governance page: https://www.withtally.com/governance/fei .","title":"Delegate Votes"},{"location":"old/dao-voting-and-delegation/delegate-votes/#delegate-to-yourself-set-up-wallet-for-direct-voting","text":"Click on the button to \"delegate to self\". Select \"direct delegation\", and then click the \"delegate\" button. Confirm and sign the transaction via Metamask.","title":"Delegate to yourself (set up wallet for direct voting):"},{"location":"old/dao-voting-and-delegation/delegate-votes/#delegate-votes-to-another-address","text":"Navigate to the delegate leaderboard at the bottom of the Fei Protocol governance page. If your preferred delegate is not in the top 10 addresses by voting power, click on the \"view all\" link to view additional delegates. Click on the address you'd like to support to view their voter page. Then click on the \"delegate vote\" button on the right hand side. Select \"direct delegation\", and then click the \"delegate\" button. Confirm and sign the transaction via Metamask.","title":"Delegate votes to another address:"},{"location":"old/dao-voting-and-delegation/delegate-votes/#confirm-your-delegation-status","text":"Start by navigating to your address's voter page. If you are among the top 100 addresses by voting power, you can link to your voter page through the \"top voters\" table at the bottom of the governance page. Alternatively, you can view your address's voter page by pasting the following link into your browser with the relevant details. https://www.withtally.com/voter/[your ethereum address]/governance/fei `` Once you've accessed your voter page, review the \"delegating to\" section on the right hand side. If you delegated votes to yourself (set up your address for direct voting), you should see \"self delegation\". If you delegated votes to another address, this section will display a link to that address's voter page.","title":"Confirm your delegation status:"},{"location":"old/dao-voting-and-delegation/disconnect-your-wallet/","text":"Disconnect Your Wallet If you wish to disconnect your wallet from Tally, or switch to an alternate wallet address, you can do this through your Metamask extension. Open the extension in your browser, then select the \"connected\" link in the upper left. On the pop up, choose your currently connected wallet and select the option to \"disconnect this account\". You can confirm your wallet has been disconnected by checking the top right corner of the Tally App, which should now show the option to \"connect wallet\".","title":"Disconnect Your Wallet"},{"location":"old/dao-voting-and-delegation/disconnect-your-wallet/#disconnect-your-wallet","text":"If you wish to disconnect your wallet from Tally, or switch to an alternate wallet address, you can do this through your Metamask extension. Open the extension in your browser, then select the \"connected\" link in the upper left. On the pop up, choose your currently connected wallet and select the option to \"disconnect this account\". You can confirm your wallet has been disconnected by checking the top right corner of the Tally App, which should now show the option to \"connect wallet\".","title":"Disconnect Your Wallet"},{"location":"old/dao-voting-and-delegation/vote-on-an-active-proposal/","text":"Vote on an Active Proposal Before getting started, ensure that you have connected your wallet. {% page-ref page=\"connect-your-wallet.md\" %} Also confirm you have voting power delegated to your address. {% hint style=\"warning\" %} Note that tokens you own are not active for voting until you delegate. You must delegate to yourself if you wish to vote on proposals directly with your own tokens. {% endhint %} {% page-ref page=\"delegate-votes.md\" %} How to Vote: Select the active proposal that you'd like to vote on. You can access this from the Fei Protocol Governance page, and then scroll down below the delegate voting power chart. Click on the \"vote\" button in the upper right corner of the page. On the voting pop up, select your preferred option and click the \"submit your vote\" button. Confirm and sign the transaction via Metamask. Confirm your vote status: Start by navigating to your address's voter page. If you are among the top 100 addresses by voting power, you can link to your voter page through the \"top voters\" table at the bottom of the Fei Protocol governance page. Alternatively, you can view your address's voter page by pasting the following link into your browser with the relevant details. https://www.withtally.com/voter/[your ethereum address]/Governance/Fei On your address's voting page, scroll down to the recent vote section. Your most recent vote will be displayed at the top of the table.","title":"Vote on an Active Proposal"},{"location":"old/dao-voting-and-delegation/vote-on-an-active-proposal/#vote-on-an-active-proposal","text":"Before getting started, ensure that you have connected your wallet. {% page-ref page=\"connect-your-wallet.md\" %} Also confirm you have voting power delegated to your address. {% hint style=\"warning\" %} Note that tokens you own are not active for voting until you delegate. You must delegate to yourself if you wish to vote on proposals directly with your own tokens. {% endhint %} {% page-ref page=\"delegate-votes.md\" %}","title":"Vote on an Active Proposal"},{"location":"old/dao-voting-and-delegation/vote-on-an-active-proposal/#how-to-vote","text":"Select the active proposal that you'd like to vote on. You can access this from the Fei Protocol Governance page, and then scroll down below the delegate voting power chart. Click on the \"vote\" button in the upper right corner of the page. On the voting pop up, select your preferred option and click the \"submit your vote\" button. Confirm and sign the transaction via Metamask.","title":"How to Vote:"},{"location":"old/dao-voting-and-delegation/vote-on-an-active-proposal/#confirm-your-vote-status","text":"Start by navigating to your address's voter page. If you are among the top 100 addresses by voting power, you can link to your voter page through the \"top voters\" table at the bottom of the Fei Protocol governance page. Alternatively, you can view your address's voter page by pasting the following link into your browser with the relevant details. https://www.withtally.com/voter/[your ethereum address]/Governance/Fei On your address's voting page, scroll down to the recent vote section. Your most recent vote will be displayed at the top of the table.","title":"Confirm your vote status:"},{"location":"old/governance/fei-dao/","text":"Fei DAO A core principle of Fei Protocol is its fully decentralized design and minimal dependence on any centralized assets or protocols on Ethereum. Fei Protocol has a DAO called the Fei DAO from the start. The DAO is responsible for utilizing all of the flexible and powerful features of Fei Protocol to continually enhance the protocol in an ever-evolving DeFi space. Responsibilities Fei Protocol design and implementation minimize the governance for peg maintenance related activities. Beyond the inherent need for the initial protocol tuning, the Fei DAO is primarily responsible for two things: upgrades and integrations. Parameter tuning and changes that the Fei DAO can make: grant/revoke roles add/remove incentive contracts for FEI exempt addresses from direct incentives Set the peg support incentive growth rate change PCV allocations update bonding curve buffer and Scale target adjust rewards from the staking pool upgrade oracles and other contracts throughout the system Design The Fei DAO is forked from the Compound Governor Alpha and Timelock . Parameter modifications from Compound implementation: 2.5% Quorum .25% proposal threshold 12 hour voting delay (3333 blocks) 36 hour voting period (10000 blocks) 24 hour timelock delay Instead of the COMP token, the Fei DAO is controlled by TRIBE The Guardian can transfer the Guardian role {% embed url=\"https://www.diffchecker.com/kXPkUHOo\" caption=\"Fei DAO vs Compound DAO\" %} Fei Protocol implementation enables a flexible access control system. The Timelock is appointed as a Governor\u2696\ufe0f, but it doesn't have to be the only one. It also doesn't have to be a Governor forever. Fei Protocol can appoint autonomous governors to adjust parameters and PCV based on market conditions. Additionally, a tiered governance structure can be implemented where certain changes require higher quorum thresholds and longer timelocks. Ultimately the Fei DAO makes all of these decisions as the protocol evolves.","title":"Fei DAO"},{"location":"old/governance/fei-dao/#fei-dao","text":"A core principle of Fei Protocol is its fully decentralized design and minimal dependence on any centralized assets or protocols on Ethereum. Fei Protocol has a DAO called the Fei DAO from the start. The DAO is responsible for utilizing all of the flexible and powerful features of Fei Protocol to continually enhance the protocol in an ever-evolving DeFi space.","title":"Fei DAO"},{"location":"old/governance/fei-dao/#responsibilities","text":"Fei Protocol design and implementation minimize the governance for peg maintenance related activities. Beyond the inherent need for the initial protocol tuning, the Fei DAO is primarily responsible for two things: upgrades and integrations. Parameter tuning and changes that the Fei DAO can make: grant/revoke roles add/remove incentive contracts for FEI exempt addresses from direct incentives Set the peg support incentive growth rate change PCV allocations update bonding curve buffer and Scale target adjust rewards from the staking pool upgrade oracles and other contracts throughout the system","title":"Responsibilities"},{"location":"old/governance/fei-dao/#design","text":"The Fei DAO is forked from the Compound Governor Alpha and Timelock . Parameter modifications from Compound implementation: 2.5% Quorum .25% proposal threshold 12 hour voting delay (3333 blocks) 36 hour voting period (10000 blocks) 24 hour timelock delay Instead of the COMP token, the Fei DAO is controlled by TRIBE The Guardian can transfer the Guardian role {% embed url=\"https://www.diffchecker.com/kXPkUHOo\" caption=\"Fei DAO vs Compound DAO\" %} Fei Protocol implementation enables a flexible access control system. The Timelock is appointed as a Governor\u2696\ufe0f, but it doesn't have to be the only one. It also doesn't have to be a Governor forever. Fei Protocol can appoint autonomous governors to adjust parameters and PCV based on market conditions. Additionally, a tiered governance structure can be implemented where certain changes require higher quorum thresholds and longer timelocks. Ultimately the Fei DAO makes all of these decisions as the protocol evolves.","title":"Design"},{"location":"old/governance/fei-guardian/","text":"Fei Guardian The Fei Guardian is the single address to be granted the Guardian\ud83d\udee1role at Genesis. Initially held by the Fei Core Team in a multi-sig, with the intention of either renouncing the role or transitioning to a community held multi-sig within a few months of launch. The rationale for a Guardian is that there could be issues in the protocol which are time sensitive. The minimum 3 day window between a proposal and execution for a fix coming through the Fei DAO could be too long. For instance, if there is a bug in the incentive calculation where an attacker can systematically make a profit, this functionality should be shut down as quickly as possible. The Guardian would step in and revoke the Minter\ud83d\udcb0role from the UniswapIncentive contract. The Guardian can only revoke or pause functionality, with the additional ability to force a reweight. {% hint style=\"info\" %} The Governor\u2696\ufe0f can revoke the Guardian\ud83d\udee1ability at any time {% endhint %} Responsibilities revoke any role from any contract, except Governor\u2696\ufe0f pause and unpause contracts force a reweight Pausability Any contract implementing CoreRef has the ability to be pausable. Any external method marked as pausable would revert when the contract is in the paused state. List of pausable methods by contract: EthBondingCurve allocate() purchase(address to, uint256 amountIn) Pause would prevent both purchasing FEI and allocating PCV from the bonding curve EthUniswapPCVDeposit deposit(uint256 ethAmount) withdraw(uint256 ethAmount) Pause would prevent new PCV from being provided as liquidity to Uniswap or withdrawn EthUniswapPCVController reweight() Pause would prevent external actors from triggering reweights when the criteria are met. {% hint style=\"info\" %} The forceReweight() function would still be available for the Guardian to manually support the peg {% endhint %} Fei burnFrom() mint() Pause would render all Minter\ud83d\udcb0and Burner\ud83d\udd25contracts unable to mint and burn FEI, respectively UniswapOracle read() update() Pause would render all Fei Protocol contracts which rely on this oracle unable to successfully execute function calls BondingCurveOracle read() Pause would render all Fei Protocol contracts which rely on this oracle unable to successfully execute function calls FeiRewardsDistributor drip() Pause would stop any future TRIBE reward distributions to FeiStakingRewards but leave the current reward cycle unchanged.","title":"Fei Guardian"},{"location":"old/governance/fei-guardian/#fei-guardian","text":"The Fei Guardian is the single address to be granted the Guardian\ud83d\udee1role at Genesis. Initially held by the Fei Core Team in a multi-sig, with the intention of either renouncing the role or transitioning to a community held multi-sig within a few months of launch. The rationale for a Guardian is that there could be issues in the protocol which are time sensitive. The minimum 3 day window between a proposal and execution for a fix coming through the Fei DAO could be too long. For instance, if there is a bug in the incentive calculation where an attacker can systematically make a profit, this functionality should be shut down as quickly as possible. The Guardian would step in and revoke the Minter\ud83d\udcb0role from the UniswapIncentive contract. The Guardian can only revoke or pause functionality, with the additional ability to force a reweight. {% hint style=\"info\" %} The Governor\u2696\ufe0f can revoke the Guardian\ud83d\udee1ability at any time {% endhint %}","title":"Fei Guardian"},{"location":"old/governance/fei-guardian/#responsibilities","text":"revoke any role from any contract, except Governor\u2696\ufe0f pause and unpause contracts force a reweight","title":"Responsibilities"},{"location":"old/governance/fei-guardian/#pausability","text":"Any contract implementing CoreRef has the ability to be pausable. Any external method marked as pausable would revert when the contract is in the paused state. List of pausable methods by contract:","title":"Pausability"},{"location":"old/governance/fei-guardian/#ethbondingcurve","text":"allocate() purchase(address to, uint256 amountIn) Pause would prevent both purchasing FEI and allocating PCV from the bonding curve","title":"EthBondingCurve"},{"location":"old/governance/fei-guardian/#ethuniswappcvdeposit","text":"deposit(uint256 ethAmount) withdraw(uint256 ethAmount) Pause would prevent new PCV from being provided as liquidity to Uniswap or withdrawn","title":"EthUniswapPCVDeposit"},{"location":"old/governance/fei-guardian/#ethuniswappcvcontroller","text":"reweight() Pause would prevent external actors from triggering reweights when the criteria are met. {% hint style=\"info\" %} The forceReweight() function would still be available for the Guardian to manually support the peg {% endhint %}","title":"EthUniswapPCVController"},{"location":"old/governance/fei-guardian/#fei","text":"burnFrom() mint() Pause would render all Minter\ud83d\udcb0and Burner\ud83d\udd25contracts unable to mint and burn FEI, respectively","title":"Fei"},{"location":"old/governance/fei-guardian/#uniswaporacle","text":"read() update() Pause would render all Fei Protocol contracts which rely on this oracle unable to successfully execute function calls","title":"UniswapOracle"},{"location":"old/governance/fei-guardian/#bondingcurveoracle","text":"read() Pause would render all Fei Protocol contracts which rely on this oracle unable to successfully execute function calls","title":"BondingCurveOracle"},{"location":"old/governance/fei-guardian/#feirewardsdistributor","text":"drip() Pause would stop any future TRIBE reward distributions to FeiStakingRewards but leave the current reward cycle unchanged.","title":"FeiRewardsDistributor"},{"location":"old/governance/snapshot-voting/","text":"Snapshot Voting What are Snapshot votes? Snapshot voting is a way to vote off-chain without spending any ETH to signal support for a given proposal or path forward for a DAO vote. {% hint style=\"warning\" %} Snapshot votes are NOT binding, all on-chain proposals must pass through the Fei DAO {% endhint %} Snapshot votes can calculate voting power at a certain point in time (block) and customized token balances, including delegations or tokens held in staked LP tokens, for example. How to Vote Head to https://snapshot.fei.money/#/ Click on \u201c Connect wallet \u201d button in top right corner. Connect with wallet provider where you hold TRIBE and/or FEI-TRIBE staked LP tokens Select the active proposal you wish to vote on After reading the proposal, select your preferred choice and \"vote\" Your wallet will prompt you to sign a message, this does not cost any ETH and will submit your vote. How Voting weight is calculated Voting weight is equal to the sum of your delegated, held, and staked TRIBE. For held TRIBE, if it is delegated, then it is not double-counted. The contract used to determine delegated + held balances is here . For staked FEI-TRIBE LP, only the TRIBE portion is counted and the unclaimed TRIBE does not count. How to make a proposal Anyone can make a proposal if their voting weight is more than 1000 TRIBE. Simply follow the snapshot guidelines to do so: https://docs.snapshot.org/proposals/create","title":"Snapshot Voting"},{"location":"old/governance/snapshot-voting/#snapshot-voting","text":"","title":"Snapshot Voting"},{"location":"old/governance/snapshot-voting/#what-are-snapshot-votes","text":"Snapshot voting is a way to vote off-chain without spending any ETH to signal support for a given proposal or path forward for a DAO vote. {% hint style=\"warning\" %} Snapshot votes are NOT binding, all on-chain proposals must pass through the Fei DAO {% endhint %} Snapshot votes can calculate voting power at a certain point in time (block) and customized token balances, including delegations or tokens held in staked LP tokens, for example.","title":"What are Snapshot votes?"},{"location":"old/governance/snapshot-voting/#how-to-vote","text":"Head to https://snapshot.fei.money/#/ Click on \u201c Connect wallet \u201d button in top right corner. Connect with wallet provider where you hold TRIBE and/or FEI-TRIBE staked LP tokens Select the active proposal you wish to vote on After reading the proposal, select your preferred choice and \"vote\" Your wallet will prompt you to sign a message, this does not cost any ETH and will submit your vote.","title":"How to Vote"},{"location":"old/governance/snapshot-voting/#how-voting-weight-is-calculated","text":"Voting weight is equal to the sum of your delegated, held, and staked TRIBE. For held TRIBE, if it is delegated, then it is not double-counted. The contract used to determine delegated + held balances is here . For staked FEI-TRIBE LP, only the TRIBE portion is counted and the unclaimed TRIBE does not count.","title":"How Voting weight is calculated"},{"location":"old/governance/snapshot-voting/#how-to-make-a-proposal","text":"Anyone can make a proposal if their voting weight is more than 1000 TRIBE. Simply follow the snapshot guidelines to do so: https://docs.snapshot.org/proposals/create","title":"How to make a proposal"},{"location":"old/governance/tribe/","text":"Tribe The TRIBE governance token is collectively responsible for managing the Fei DAO . Design TRIBE's total initial supply is 1 billion. The minting capability is controlled by an appointed minter address (this is different from the Minter\ud83d\udcb0 role). The minter is originally set to the Fei DAO Timelock. The code for TRIBE is forked from the Uniswap UNI token . The main difference is that UNI can only inflate 2% per year, whereas TRIBE has uncapped inflation. {% embed url=\"https://www.diffchecker.com/9OUwJBFS\" caption=\"TRIBE vs UNI diff\" %} Distribution The Fei Core team wants TRIBE to have a balanced distribution between Community, Team, and Investors while prioritizing the Community. We embedded both capital favoring and non-capital favoring distribution mechanisms, and emphasize equal opportunity through the Genesis Group. High-level TRIBE distribution: 40% DAO treasury 20% Initial DEX Offering 13% Fei Core Team 10% Genesis Group 10% Staking Rewards 5% Fei Core Team investors 2% Grants Medium announcement provides more details regarding the distribution. {% embed url=\"https://medium.com/fei-protocol/the-tribe-token-distribution-887f26169e44\" caption=\"\" %}","title":"Tribe"},{"location":"old/governance/tribe/#tribe","text":"The TRIBE governance token is collectively responsible for managing the Fei DAO .","title":"Tribe"},{"location":"old/governance/tribe/#design","text":"TRIBE's total initial supply is 1 billion. The minting capability is controlled by an appointed minter address (this is different from the Minter\ud83d\udcb0 role). The minter is originally set to the Fei DAO Timelock. The code for TRIBE is forked from the Uniswap UNI token . The main difference is that UNI can only inflate 2% per year, whereas TRIBE has uncapped inflation. {% embed url=\"https://www.diffchecker.com/9OUwJBFS\" caption=\"TRIBE vs UNI diff\" %}","title":"Design"},{"location":"old/governance/tribe/#distribution","text":"The Fei Core team wants TRIBE to have a balanced distribution between Community, Team, and Investors while prioritizing the Community. We embedded both capital favoring and non-capital favoring distribution mechanisms, and emphasize equal opportunity through the Genesis Group. High-level TRIBE distribution: 40% DAO treasury 20% Initial DEX Offering 13% Fei Core Team 10% Genesis Group 10% Staking Rewards 5% Fei Core Team investors 2% Grants Medium announcement provides more details regarding the distribution. {% embed url=\"https://medium.com/fei-protocol/the-tribe-token-distribution-887f26169e44\" caption=\"\" %}","title":"Distribution"},{"location":"old/protocol/changelog/","text":"Changelog FIP-5: Bonding Curve Allocation Update - May 18, 2021 FIP-5 updates the bonding curve allocation to send funds to the EthReserveStabilizer via the EthPCVDripper instead of to the EthUniswapPCVDeposit as before. It also includes an update to the EthUniswapPCVDeposit where deposits can only occur when the FEI-ETH spot price is within 1% of the oracle price. EthPCVDepositAdapter An adapter contract that allows ETH transfers to conform to the IPCVDeposit interface. {% page-ref page=\"protocol-controlled-value/ethpcvdepositadapter.md\" %} RatioPCVController A PCV controller that allows for withdrawals of a percentage rather than a raw amount of PCV. This is useful for contracts like the EthUniswapPCVDeposit where the ETH amount held varies based on market conditions. {% page-ref page=\"protocol-controlled-value/ratiopcvcontroller.md\" %} The code for these changes can be found here: https://github.com/fei-protocol/fei-protocol-core/pull/98 FIP-2: FEI Redemption and TRIBE Staking Rewards - April 29, 2021 FIP-2 allows FEI redemption at $0.95 and doubles the FEI-TRIBE LP staking rewards EthReserveStabilizer Responsible for exchanging FEI for ETH at $0.95 relative to the UniswapOracle price. Has the Burner\ud83d\udd25role so that approval is not needed to interact with it. ****Receives ETH in 5k batches from the EthPCVDripper every hour. {% page-ref page=\"protocol-controlled-value/ethreservestabilizer.md\" %} EthPCVDripper Drips ETH to the EthReserveStabilizer in 5k increments every hour. The dripper prevents the EthReserveStabilizer from holding more than 10k ETH allowing a smoother and safer release of potentially large amounts of ETH to target contracts. The drip can be called by any address and is not incentivized directly with FEI 300k ETH are sent to the EthPCVDripper from the EthUniswapPCVDeposit {% page-ref page=\"protocol-controlled-value/ethpcvdripper.md\" %} TribeDripper When the FeiRewardsDistributor receives new TRIBE, it allocates an amount proportional to all prior drips to the very first drip, frontloading the distribution. If the 100 million TRIBE are sent directly to the distributor then the following week would have 6x rewards (1x base rewards + 100% boost x 5 drips). To smoothen out the front-loading, the TribeDripper sends the 100 million TRIBE to the FeiRewardsDistributor over 3 weeks using 47m, 31m, and 22m TRIBE respectively. Week 1: 1x base rewards + 47% boost x 5 drips = ~3.35x Week 2: 1.47x base rewards + 31% x 6 drips = ~3.33x Week 3: 1.78x base rewards + 22% x 7 drips = ~3.32x Week 4+: 2x base rewards The TribeDripper is at https://etherscan.io/address/0x65b3Ea26c492de0c2f2D8Abe84eB831796d6eDb1 with an unincentivized function drip() that can be called weekly for 3 drips Pre-Launch - Feb 2021 Guardian\ud83d\udee1Role The Guardian maintains the ability to revoke roles, and pause certain contracts and methods. It can also force reweights. {% page-ref page=\"../governance/fei-guardian.md\" %} Thawing The white paper specification for the Genesis Group doesn\u2019t address the unintended effect that the average price paid is always lower than the \"next price\" which is the price that is listed on Uniswap. This creates a perverse incentive to participate in the Genesis Group to arbitrage the group. To solve this we have implemented \"thawing\" where the list price of FEI/ETH starts at the average genesis price and thaws up to the target peg over 2 weeks. {% page-ref page=\"oracles/\" %} Allocation In the white paper, bonding curve purchases of FEI directly fund (ETH) the PCV. Thanks to a recommendation from Ashwin Ramachandran, we are splitting this allocation to Uniswap into a separate flow available for keepers. This lowers bonding curve purchases to around 100k gas, a 66% reduction, making it cheaper than most Uniswap purchases! These batched transactions are always available and incentivized once a day for 500 FEI. {% page-ref page=\"bondingcurve/\" %} Reweight Reward PCV reweights receive a flat reward in FEI rather than the percentage approach mentioned in the white paper. {% page-ref page=\"protocol-controlled-value/\" %} Escape Genesis In the unlikely event that the GenesisGroup launch function is frozen in a bad state, we\u2019ve added a way to exit back into ETH. This opens 3 days post Genesis. {% page-ref page=\"genesis/\" %} Pre-Swap TRIBE To mitigate frontrunning of TRIBE in the DEX offering, we allow users to pre-swap a portion of their Genesis Group FEI stake to buy TRIBE. This gives users the ability to participate in the very first TRIBE purchase at the best IDO price. {% page-ref page=\"genesis/\" %} IDO Normalization Given that the pre-swap creates a large slippage and back-running opportunity, a trader could arbitrage the group by joining Genesis and pre-swapping 100% of the FEI for TRIBE with the intention of immediately selling back out. We now normalize the IDO price to what the Genesis Group pays including slippage by burning directly from the pool to prevent this backrunning opportunity. {% page-ref page=\"genesis/ido.md\" %} Bonding Curve Shift In the white paper, the bonding curve starts at a 0 price and approaches the peg at the scale target. To achieve lower undercollateralization in the PCV, we\u2019ve added a \u201ck\u201d shift to initiate the bonding curve higher up at an elevated starting price. {% page-ref page=\"bondingcurve/\" %} Sell Disincentive (Burn) Calculation The current implementation integrates the burn function from the white paper with respect to the distance from the peg. {% page-ref page=\"fei-stablecoin/uniswapincentive.md\" %} Router A custom Uniswap router that allows the user to bound their buy rewards or sell penalties when trading on the incentivized uniswap pool. {% page-ref page=\"trading/\" %} White paper - Jan 11, 2021 {% page-ref page=\"../whitepaper.md\" %}","title":"Changelog"},{"location":"old/protocol/changelog/#changelog","text":"","title":"Changelog"},{"location":"old/protocol/changelog/#fip-5-bonding-curve-allocation-update-may-18-2021","text":"FIP-5 updates the bonding curve allocation to send funds to the EthReserveStabilizer via the EthPCVDripper instead of to the EthUniswapPCVDeposit as before. It also includes an update to the EthUniswapPCVDeposit where deposits can only occur when the FEI-ETH spot price is within 1% of the oracle price. EthPCVDepositAdapter An adapter contract that allows ETH transfers to conform to the IPCVDeposit interface. {% page-ref page=\"protocol-controlled-value/ethpcvdepositadapter.md\" %} RatioPCVController A PCV controller that allows for withdrawals of a percentage rather than a raw amount of PCV. This is useful for contracts like the EthUniswapPCVDeposit where the ETH amount held varies based on market conditions. {% page-ref page=\"protocol-controlled-value/ratiopcvcontroller.md\" %} The code for these changes can be found here: https://github.com/fei-protocol/fei-protocol-core/pull/98","title":"FIP-5: Bonding Curve Allocation Update - May 18, 2021"},{"location":"old/protocol/changelog/#fip-2-fei-redemption-and-tribe-staking-rewards-april-29-2021","text":"FIP-2 allows FEI redemption at $0.95 and doubles the FEI-TRIBE LP staking rewards EthReserveStabilizer Responsible for exchanging FEI for ETH at $0.95 relative to the UniswapOracle price. Has the Burner\ud83d\udd25role so that approval is not needed to interact with it. ****Receives ETH in 5k batches from the EthPCVDripper every hour. {% page-ref page=\"protocol-controlled-value/ethreservestabilizer.md\" %}","title":"FIP-2: FEI Redemption and TRIBE Staking Rewards - April 29, 2021"},{"location":"old/protocol/changelog/#ethpcvdripper","text":"Drips ETH to the EthReserveStabilizer in 5k increments every hour. The dripper prevents the EthReserveStabilizer from holding more than 10k ETH allowing a smoother and safer release of potentially large amounts of ETH to target contracts. The drip can be called by any address and is not incentivized directly with FEI 300k ETH are sent to the EthPCVDripper from the EthUniswapPCVDeposit {% page-ref page=\"protocol-controlled-value/ethpcvdripper.md\" %}","title":"EthPCVDripper"},{"location":"old/protocol/changelog/#tribedripper","text":"When the FeiRewardsDistributor receives new TRIBE, it allocates an amount proportional to all prior drips to the very first drip, frontloading the distribution. If the 100 million TRIBE are sent directly to the distributor then the following week would have 6x rewards (1x base rewards + 100% boost x 5 drips). To smoothen out the front-loading, the TribeDripper sends the 100 million TRIBE to the FeiRewardsDistributor over 3 weeks using 47m, 31m, and 22m TRIBE respectively. Week 1: 1x base rewards + 47% boost x 5 drips = ~3.35x Week 2: 1.47x base rewards + 31% x 6 drips = ~3.33x Week 3: 1.78x base rewards + 22% x 7 drips = ~3.32x Week 4+: 2x base rewards The TribeDripper is at https://etherscan.io/address/0x65b3Ea26c492de0c2f2D8Abe84eB831796d6eDb1 with an unincentivized function drip() that can be called weekly for 3 drips","title":"TribeDripper"},{"location":"old/protocol/changelog/#pre-launch-feb-2021","text":"","title":"Pre-Launch - Feb 2021"},{"location":"old/protocol/changelog/#guardianrole","text":"The Guardian maintains the ability to revoke roles, and pause certain contracts and methods. It can also force reweights. {% page-ref page=\"../governance/fei-guardian.md\" %}","title":"Guardian\ud83d\udee1Role"},{"location":"old/protocol/changelog/#thawing","text":"The white paper specification for the Genesis Group doesn\u2019t address the unintended effect that the average price paid is always lower than the \"next price\" which is the price that is listed on Uniswap. This creates a perverse incentive to participate in the Genesis Group to arbitrage the group. To solve this we have implemented \"thawing\" where the list price of FEI/ETH starts at the average genesis price and thaws up to the target peg over 2 weeks. {% page-ref page=\"oracles/\" %}","title":"Thawing"},{"location":"old/protocol/changelog/#allocation","text":"In the white paper, bonding curve purchases of FEI directly fund (ETH) the PCV. Thanks to a recommendation from Ashwin Ramachandran, we are splitting this allocation to Uniswap into a separate flow available for keepers. This lowers bonding curve purchases to around 100k gas, a 66% reduction, making it cheaper than most Uniswap purchases! These batched transactions are always available and incentivized once a day for 500 FEI. {% page-ref page=\"bondingcurve/\" %}","title":"Allocation"},{"location":"old/protocol/changelog/#reweight-reward","text":"PCV reweights receive a flat reward in FEI rather than the percentage approach mentioned in the white paper. {% page-ref page=\"protocol-controlled-value/\" %}","title":"Reweight Reward"},{"location":"old/protocol/changelog/#escape-genesis","text":"In the unlikely event that the GenesisGroup launch function is frozen in a bad state, we\u2019ve added a way to exit back into ETH. This opens 3 days post Genesis. {% page-ref page=\"genesis/\" %}","title":"Escape Genesis"},{"location":"old/protocol/changelog/#pre-swap-tribe","text":"To mitigate frontrunning of TRIBE in the DEX offering, we allow users to pre-swap a portion of their Genesis Group FEI stake to buy TRIBE. This gives users the ability to participate in the very first TRIBE purchase at the best IDO price. {% page-ref page=\"genesis/\" %}","title":"Pre-Swap TRIBE"},{"location":"old/protocol/changelog/#ido-normalization","text":"Given that the pre-swap creates a large slippage and back-running opportunity, a trader could arbitrage the group by joining Genesis and pre-swapping 100% of the FEI for TRIBE with the intention of immediately selling back out. We now normalize the IDO price to what the Genesis Group pays including slippage by burning directly from the pool to prevent this backrunning opportunity. {% page-ref page=\"genesis/ido.md\" %}","title":"IDO Normalization"},{"location":"old/protocol/changelog/#bonding-curve-shift","text":"In the white paper, the bonding curve starts at a 0 price and approaches the peg at the scale target. To achieve lower undercollateralization in the PCV, we\u2019ve added a \u201ck\u201d shift to initiate the bonding curve higher up at an elevated starting price. {% page-ref page=\"bondingcurve/\" %}","title":"Bonding Curve Shift"},{"location":"old/protocol/changelog/#sell-disincentive-burn-calculation","text":"The current implementation integrates the burn function from the white paper with respect to the distance from the peg. {% page-ref page=\"fei-stablecoin/uniswapincentive.md\" %}","title":"Sell Disincentive (Burn) Calculation"},{"location":"old/protocol/changelog/#router","text":"A custom Uniswap router that allows the user to bound their buy rewards or sell penalties when trading on the incentivized uniswap pool. {% page-ref page=\"trading/\" %}","title":"Router"},{"location":"old/protocol/changelog/#white-paper-jan-11-2021","text":"{% page-ref page=\"../whitepaper.md\" %}","title":"White paper - Jan 11, 2021"},{"location":"old/protocol/contract-addresses/","text":"Contract Addresses {% hint style=\"info\" %} The contracts marked with \ud83d\udd04can be changed by governance, which would mean new addresses. {% endhint %} Contract Mainnet Address Core 0x8d5ED43dCa8C2F7dFB20CF7b53CC7E593635d7b9 Tribe 0xc7283b66Eb1EB5FB86327f08e1B5816b0720212B \ud83d\udd04 Fei DAO 0xE087F94c3081e1832dC7a22B48c6f2b5fAaE579B \ud83d\udd04 Fei DAO Timelock 0x639572471f2f318464dc01066a56867130e45E25 Fei 0x956F47F50A910163D8BF957Cf5846D573E7f87CA \ud83d\udd04 UniswapIncentive 0xfe5b6c2a87A976dCe20130c423C679f4d6044cD7 \ud83d\udd04 EthBondingCurve 0xe1578B4a32Eaefcd563a9E6d0dc02a4213f673B7 \ud83d\udd04 EthUniswapPCVDeposit 0x5d6446880fcd004c851ea8920a628c70ca101117 \ud83d\udd04 EthUniswapPCVController 0x7a165F8518A9Ec7d5DA15f4B77B1d7128B5D9188 \ud83d\udd04 UniswapOracle 0x087F35bd241e41Fc28E43f0E8C58d283DD55bD65 \ud83d\udd04 BondingCurveOracle 0x89714d3AC9149426219a3568543200D1964101C4 FeiRewardsDistributor 0xEf1a94AF192A88859EAF3F3D8C1B9705542174C5 FeiStakingRewards 0x18305DaAe09Ea2F4D51fAa33318be5978D251aBd GenesisGroup 0xBFfB152b9392e38CdDc275D818a3Db7FE364596b FeiRouter 0x9271D303b57c204636C38Df0eD339b18Bf98f909 \ud83d\udd04 EthReserveStabilizer 0xa08A721dFB595753FFf335636674D76C455B275C \ud83d\udd04 EthPCVDripper 0xDa079A280FC3e33Eb11A78708B369D5Ca2da54fE \ud83d\udd04 RatioPCVController 0xfC1aD6eb84351597cD3b9B65179633697d65B920 \ud83d\udd04 EthPCVDepositAdapter 0xB72dDeD4Fa321e093E2083B596404A56ffC5b574 External Addresses Contract Mainnet Address FEI-ETH UniV2 Pair 0x94B0A3d511b6EcDb17eBF877278Ab030acb0A878 FEI-TRIBE UniV2 Pair 0x9928e4046d7c6513326cCeA028cD3e7a91c7590A","title":"Contract Addresses"},{"location":"old/protocol/contract-addresses/#contract-addresses","text":"{% hint style=\"info\" %} The contracts marked with \ud83d\udd04can be changed by governance, which would mean new addresses. {% endhint %} Contract Mainnet Address Core 0x8d5ED43dCa8C2F7dFB20CF7b53CC7E593635d7b9 Tribe 0xc7283b66Eb1EB5FB86327f08e1B5816b0720212B \ud83d\udd04 Fei DAO 0xE087F94c3081e1832dC7a22B48c6f2b5fAaE579B \ud83d\udd04 Fei DAO Timelock 0x639572471f2f318464dc01066a56867130e45E25 Fei 0x956F47F50A910163D8BF957Cf5846D573E7f87CA \ud83d\udd04 UniswapIncentive 0xfe5b6c2a87A976dCe20130c423C679f4d6044cD7 \ud83d\udd04 EthBondingCurve 0xe1578B4a32Eaefcd563a9E6d0dc02a4213f673B7 \ud83d\udd04 EthUniswapPCVDeposit 0x5d6446880fcd004c851ea8920a628c70ca101117 \ud83d\udd04 EthUniswapPCVController 0x7a165F8518A9Ec7d5DA15f4B77B1d7128B5D9188 \ud83d\udd04 UniswapOracle 0x087F35bd241e41Fc28E43f0E8C58d283DD55bD65 \ud83d\udd04 BondingCurveOracle 0x89714d3AC9149426219a3568543200D1964101C4 FeiRewardsDistributor 0xEf1a94AF192A88859EAF3F3D8C1B9705542174C5 FeiStakingRewards 0x18305DaAe09Ea2F4D51fAa33318be5978D251aBd GenesisGroup 0xBFfB152b9392e38CdDc275D818a3Db7FE364596b FeiRouter 0x9271D303b57c204636C38Df0eD339b18Bf98f909 \ud83d\udd04 EthReserveStabilizer 0xa08A721dFB595753FFf335636674D76C455B275C \ud83d\udd04 EthPCVDripper 0xDa079A280FC3e33Eb11A78708B369D5Ca2da54fE \ud83d\udd04 RatioPCVController 0xfC1aD6eb84351597cD3b9B65179633697d65B920 \ud83d\udd04 EthPCVDepositAdapter 0xB72dDeD4Fa321e093E2083B596404A56ffC5b574","title":"Contract Addresses"},{"location":"old/protocol/contract-addresses/#external-addresses","text":"Contract Mainnet Address FEI-ETH UniV2 Pair 0x94B0A3d511b6EcDb17eBF877278Ab030acb0A878 FEI-TRIBE UniV2 Pair 0x9928e4046d7c6513326cCeA028cD3e7a91c7590A","title":"External Addresses"},{"location":"old/protocol/access-control/","text":"Access Control Fei Protocol uses access control to define the system's contracts responsibilities. System Roles: Governor \u2696\ufe0f Minter \ud83d\udcb0 Burner \ud83d\udd25 PCV Controller \u2699\ufe0f Guardian \ud83d\udee1\ufe0f The Fei Core contract manages access control. {% page-ref page=\"core.md\" %} Governor \u2696\ufe0f The Governor role is the most powerful role in Fei Protocol. It grants and revokes all other roles in the platform. It manages a multitude of protocol parameters unique to each contract (bonding curve targets, incentive formulas, oracle windows, and more). Implementing Governor as a role and not a single contract grants Fei Protocol flexibility to appoint automated governance contracts or different tiers of governance with varying degrees of difficulty for execution criteria. While the role technically belongs to the Timelock, it is valuable to think of the Fei DAO as the only Governor at launch, since the Fei DAO is the admin of the Timelock. {% page-ref page=\"../../governance/fei-dao.md\" %} Minter \ud83d\udcb0 Minters create (mint) Fei USD and add it to any address. Minting can be a reward for the actions of supporting the peg, or an issuance mechanism for funding PCV on a bonding curve. Minter Examples: {% page-ref page=\"../protocol-controlled-value/ethuniswappcvdeposit.md\" %} {% page-ref page=\"../bondingcurve/ethbondingcurve.md\" %} Burner \ud83d\udd25 Burners remove (burn) portions of Fei USD from any address. Burning occurs as a disincentive for the actions of hurting the peg. Burner Example: {% page-ref page=\"../fei-stablecoin/uniswapincentive.md\" %} PCV Controller \u2699\ufe0f PCV Controllers can move PCV from any contract and redeploy it elsewhere. This is done to reweight the peg, facilitate integrations, or protect against adverse conditions. PCV Controller Example: {% page-ref page=\"../protocol-controlled-value/ethuniswappcvcontroller.md\" %} Guardian \ud83d\udee1\ufe0f The Guardian enables quick feature shutdowns during unforeseen events. It can revoke any role from the above described role types. It can also shut off additional protocol functionality, and force reweights. It cannot manage PCV or mint FEI. {% page-ref page=\"../../governance/fei-guardian.md\" %}","title":"Access Control"},{"location":"old/protocol/access-control/#access-control","text":"Fei Protocol uses access control to define the system's contracts responsibilities. System Roles: Governor \u2696\ufe0f Minter \ud83d\udcb0 Burner \ud83d\udd25 PCV Controller \u2699\ufe0f Guardian \ud83d\udee1\ufe0f The Fei Core contract manages access control. {% page-ref page=\"core.md\" %}","title":"Access Control"},{"location":"old/protocol/access-control/#governor","text":"The Governor role is the most powerful role in Fei Protocol. It grants and revokes all other roles in the platform. It manages a multitude of protocol parameters unique to each contract (bonding curve targets, incentive formulas, oracle windows, and more). Implementing Governor as a role and not a single contract grants Fei Protocol flexibility to appoint automated governance contracts or different tiers of governance with varying degrees of difficulty for execution criteria. While the role technically belongs to the Timelock, it is valuable to think of the Fei DAO as the only Governor at launch, since the Fei DAO is the admin of the Timelock. {% page-ref page=\"../../governance/fei-dao.md\" %}","title":"Governor \u2696\ufe0f"},{"location":"old/protocol/access-control/#minter","text":"Minters create (mint) Fei USD and add it to any address. Minting can be a reward for the actions of supporting the peg, or an issuance mechanism for funding PCV on a bonding curve. Minter Examples: {% page-ref page=\"../protocol-controlled-value/ethuniswappcvdeposit.md\" %} {% page-ref page=\"../bondingcurve/ethbondingcurve.md\" %}","title":"Minter \ud83d\udcb0"},{"location":"old/protocol/access-control/#burner","text":"Burners remove (burn) portions of Fei USD from any address. Burning occurs as a disincentive for the actions of hurting the peg. Burner Example: {% page-ref page=\"../fei-stablecoin/uniswapincentive.md\" %}","title":"Burner \ud83d\udd25"},{"location":"old/protocol/access-control/#pcv-controller","text":"PCV Controllers can move PCV from any contract and redeploy it elsewhere. This is done to reweight the peg, facilitate integrations, or protect against adverse conditions. PCV Controller Example: {% page-ref page=\"../protocol-controlled-value/ethuniswappcvcontroller.md\" %}","title":"PCV Controller \u2699\ufe0f"},{"location":"old/protocol/access-control/#guardian","text":"The Guardian enables quick feature shutdowns during unforeseen events. It can revoke any role from the above described role types. It can also shut off additional protocol functionality, and force reweights. It cannot manage PCV or mint FEI. {% page-ref page=\"../../governance/fei-guardian.md\" %}","title":"Guardian \ud83d\udee1\ufe0f"},{"location":"old/protocol/access-control/core/","text":"Core Contract Core.sol implements ICore , Permissions Description The Core contract responsibilities: Access control Pointing to FEI , TRIBE , and GenesisGroup contracts Stores whether GenesisGroup has completed Escrowing DAO TRIBE treasury The access control module is managed by Permissions. {% page-ref page=\"permissions.md\" %} Most other Fei Protocol contracts should refer to Core by implementing the CoreRef contract. When Core is constructed and initialized it does the following: Set sender as governor Create and reference FEI and TRIBE contracts The governor will then set the genesis group contract. When the genesis group conditions are met, the GenesisGroup contract should complete the genesis group by calling completeGenesisGroup() Access Control Governor \u2696\ufe0f Events {% tabs %} {% tab title=\"FeiUpdate\" %} Governance change of FEI token address type param description address indexed _fei new FEI address {% endtab %} {% tab title=\"TribeUpdate\" %} Governance change of TRIBE token address type param description address indexed _tribe new TRIBE address {% endtab %} {% tab title=\"GenesisGroupUpdate\" %} Governance change of GenesisGroup address type param description address indexed _genesisGroup new Genesis Group address {% endtab %} {% tab title=\"TribeAllocation\" %} Governance deployment of TRIBE tokens from treasury type param description address indexed _to The address to receive TRIBE uint256 _amount The amount of TRIBE distributed {% endtab %} {% tab title=\"GenesisPeriodComplete\" %} Signals completion of Genesis Period and full launch of FEI protocol type param description uint256 _timestamp The block timestamp at Genesis completion {% endtab %} {% endtabs %} Read-Only Functions fei function fei() external view returns (IFei); returns the address of the FEI contract as an interface for consumption tribe function tribe() external view returns (IERC20); returns the address of the TRIBE contract as an interface for consumption genesisGroup function genesisGroup() external view returns (address); returns the address of the GenesisGroup contract hasGenesisGroupCompleted function hasGenesisGroupCompleted() external view returns (bool); returns true if after genesis period and launched, false otherwise Governor-Only\u2696\ufe0f State-Changing Functions setFei function setFei(address token) external; sets the reference FEI contract emits FeiUpdate setTribe function setTribe(address token) external; sets the reference TRIBE contract emits TribeUpdate setGenesisGroup function setGenesisGroup(address _genesisGroup) external; sets the reference GenesisGroup contract to _genesisGroup emits GenesisGroupUpdate allocateTribe function allocateTribe(address to, uint256 amount) external; distribute amount TRIBE from Core to an external address to emits TribeAllocation GenesisGroup-Only\ud83d\ude80 State-Changing Functions completeGenesisGroup function completeGenesisGroup() external; called during Fei Protocol launch to unlock the remaining protocol functionality emits GenesisPeriodComplete {% page-ref page=\"../genesis/genesisgroup.md\" %} ABIs {% file src=\"../../.gitbook/assets/core.json\" caption=\"Core ABI\" %} {% file src=\"../../.gitbook/assets/icore.json\" caption=\"Core Interface ABI\" %}","title":"Core"},{"location":"old/protocol/access-control/core/#core","text":"","title":"Core"},{"location":"old/protocol/access-control/core/#contract","text":"Core.sol implements ICore , Permissions","title":"Contract"},{"location":"old/protocol/access-control/core/#description","text":"The Core contract responsibilities: Access control Pointing to FEI , TRIBE , and GenesisGroup contracts Stores whether GenesisGroup has completed Escrowing DAO TRIBE treasury The access control module is managed by Permissions. {% page-ref page=\"permissions.md\" %} Most other Fei Protocol contracts should refer to Core by implementing the CoreRef contract. When Core is constructed and initialized it does the following: Set sender as governor Create and reference FEI and TRIBE contracts The governor will then set the genesis group contract. When the genesis group conditions are met, the GenesisGroup contract should complete the genesis group by calling completeGenesisGroup()","title":"Description"},{"location":"old/protocol/access-control/core/#access-control","text":"Governor \u2696\ufe0f","title":"Access Control"},{"location":"old/protocol/access-control/core/#events","text":"{% tabs %} {% tab title=\"FeiUpdate\" %} Governance change of FEI token address type param description address indexed _fei new FEI address {% endtab %} {% tab title=\"TribeUpdate\" %} Governance change of TRIBE token address type param description address indexed _tribe new TRIBE address {% endtab %} {% tab title=\"GenesisGroupUpdate\" %} Governance change of GenesisGroup address type param description address indexed _genesisGroup new Genesis Group address {% endtab %} {% tab title=\"TribeAllocation\" %} Governance deployment of TRIBE tokens from treasury type param description address indexed _to The address to receive TRIBE uint256 _amount The amount of TRIBE distributed {% endtab %} {% tab title=\"GenesisPeriodComplete\" %} Signals completion of Genesis Period and full launch of FEI protocol type param description uint256 _timestamp The block timestamp at Genesis completion {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/access-control/core/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/access-control/core/#fei","text":"function fei() external view returns (IFei); returns the address of the FEI contract as an interface for consumption","title":"fei"},{"location":"old/protocol/access-control/core/#tribe","text":"function tribe() external view returns (IERC20); returns the address of the TRIBE contract as an interface for consumption","title":"tribe"},{"location":"old/protocol/access-control/core/#genesisgroup","text":"function genesisGroup() external view returns (address); returns the address of the GenesisGroup contract","title":"genesisGroup"},{"location":"old/protocol/access-control/core/#hasgenesisgroupcompleted","text":"function hasGenesisGroupCompleted() external view returns (bool); returns true if after genesis period and launched, false otherwise","title":"hasGenesisGroupCompleted"},{"location":"old/protocol/access-control/core/#governor-only-state-changing-functions","text":"","title":"Governor-Only\u2696\ufe0f State-Changing Functions"},{"location":"old/protocol/access-control/core/#setfei","text":"function setFei(address token) external; sets the reference FEI contract emits FeiUpdate","title":"setFei"},{"location":"old/protocol/access-control/core/#settribe","text":"function setTribe(address token) external; sets the reference TRIBE contract emits TribeUpdate","title":"setTribe"},{"location":"old/protocol/access-control/core/#setgenesisgroup","text":"function setGenesisGroup(address _genesisGroup) external; sets the reference GenesisGroup contract to _genesisGroup emits GenesisGroupUpdate","title":"setGenesisGroup"},{"location":"old/protocol/access-control/core/#allocatetribe","text":"function allocateTribe(address to, uint256 amount) external; distribute amount TRIBE from Core to an external address to emits TribeAllocation","title":"allocateTribe"},{"location":"old/protocol/access-control/core/#genesisgroup-only-state-changing-functions","text":"","title":"GenesisGroup-Only\ud83d\ude80 State-Changing Functions"},{"location":"old/protocol/access-control/core/#completegenesisgroup","text":"function completeGenesisGroup() external; called during Fei Protocol launch to unlock the remaining protocol functionality emits GenesisPeriodComplete {% page-ref page=\"../genesis/genesisgroup.md\" %}","title":"completeGenesisGroup"},{"location":"old/protocol/access-control/core/#abis","text":"{% file src=\"../../.gitbook/assets/core.json\" caption=\"Core ABI\" %} {% file src=\"../../.gitbook/assets/icore.json\" caption=\"Core Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/access-control/permissions/","text":"Permissions Contract Permissions.sol implements IPermissions , AccessControl Description The access control module of the Core contract. It maintains which roles exist, role admins, and which addresses have which roles. The contract expands the OpenZeppelin Access Control contract with additional Fei Protocol-specific roles and functionality. {% embed url=\"https://docs.openzeppelin.com/contracts/3.x/api/access#AccessControl\" %} Granting and revoking roles is gated for only Governor \u2696\ufe0f access. The Guardian\ud83d\udee1role can also revoke roles in certain circumstances. Read-Only Functions isBurner function isBurner(address _address) external view returns (bool); returns true if _address has the Burner\ud83d\udd25role isMinter function isMinter(address _address) external view returns (bool); returns true if _address has the Minter\ud83d\udcb0role isGovernor function isGovernor(address _address) external view returns (bool); returns true if _address has the Governor\u2696\ufe0frole isGuardian function isGuardian(address _address) external view returns (bool); returns true if _address has the Guardian\ud83d\udee1role isPCVController function isPCVController(address _address) external view returns (bool); returns true if _address has the PCV Controller\u2699\ufe0frole Governor-Only\u2696\ufe0f State-Changing Functions createRole function createRole(bytes32 role, bytes32 adminRole) external; assigns role role a new admin role adminRole This function can be used either to create a new access control role or reassign an admin for an existing role. grantMinter function grantMinter(address minter) external; assigns Minter\ud83d\udcb0role to minter grantBurner function grantBurner(address burner) external; assigns Burner\ud83d\udd25role to burner grantPCVController function grantPCVController(address pcvController) external; assigns PCV Controller\u2699\ufe0f role to pcvController grantGovernor function grantGovernor(address governor) external; assigns Governor\u2696\ufe0frole to governor grantGuardian function grantGuardian(address guardian) external; assigns Guardian\ud83d\udee1role to guardian revokeMinter function revokeMinter(address minter) external; revokes Minter\ud83d\udcb0role from minter revokeBurner function revokeBurner(address burner) external; revokes Burner\ud83d\udd25role from burner revokePCVController function revokePCVController(address pcvController) external; revokes PCV Controller\u2699\ufe0f role from pcvController revokeGovernor function revokeGovernor(address governor) external; revokes Governor\u2696\ufe0frole from governor revokeGuardian function revokeGuardian(address guardian) external; revokes Guardian\ud83d\udee1role from guardian Guardian-Only\ud83d\udee1State-Changing Functions revokeOverride function revokeOverride(bytes32 role, address account) external; revokes role from account fails if role is equal to Governor\u2696\ufe0f ABIs {% file src=\"../../.gitbook/assets/permissions.json\" caption=\"Permissions ABI\" %} {% file src=\"../../.gitbook/assets/ipermissions.json\" caption=\"Permissions Interface ABI\" %}","title":"Permissions"},{"location":"old/protocol/access-control/permissions/#permissions","text":"","title":"Permissions"},{"location":"old/protocol/access-control/permissions/#contract","text":"Permissions.sol implements IPermissions , AccessControl","title":"Contract"},{"location":"old/protocol/access-control/permissions/#description","text":"The access control module of the Core contract. It maintains which roles exist, role admins, and which addresses have which roles. The contract expands the OpenZeppelin Access Control contract with additional Fei Protocol-specific roles and functionality. {% embed url=\"https://docs.openzeppelin.com/contracts/3.x/api/access#AccessControl\" %} Granting and revoking roles is gated for only Governor \u2696\ufe0f access. The Guardian\ud83d\udee1role can also revoke roles in certain circumstances.","title":"Description"},{"location":"old/protocol/access-control/permissions/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/access-control/permissions/#isburner","text":"function isBurner(address _address) external view returns (bool); returns true if _address has the Burner\ud83d\udd25role","title":"isBurner"},{"location":"old/protocol/access-control/permissions/#isminter","text":"function isMinter(address _address) external view returns (bool); returns true if _address has the Minter\ud83d\udcb0role","title":"isMinter"},{"location":"old/protocol/access-control/permissions/#isgovernor","text":"function isGovernor(address _address) external view returns (bool); returns true if _address has the Governor\u2696\ufe0frole","title":"isGovernor"},{"location":"old/protocol/access-control/permissions/#isguardian","text":"function isGuardian(address _address) external view returns (bool); returns true if _address has the Guardian\ud83d\udee1role","title":"isGuardian"},{"location":"old/protocol/access-control/permissions/#ispcvcontroller","text":"function isPCVController(address _address) external view returns (bool); returns true if _address has the PCV Controller\u2699\ufe0frole","title":"isPCVController"},{"location":"old/protocol/access-control/permissions/#governor-only-state-changing-functions","text":"","title":"Governor-Only\u2696\ufe0f State-Changing Functions"},{"location":"old/protocol/access-control/permissions/#createrole","text":"function createRole(bytes32 role, bytes32 adminRole) external; assigns role role a new admin role adminRole This function can be used either to create a new access control role or reassign an admin for an existing role.","title":"createRole"},{"location":"old/protocol/access-control/permissions/#grantminter","text":"function grantMinter(address minter) external; assigns Minter\ud83d\udcb0role to minter","title":"grantMinter"},{"location":"old/protocol/access-control/permissions/#grantburner","text":"function grantBurner(address burner) external; assigns Burner\ud83d\udd25role to burner","title":"grantBurner"},{"location":"old/protocol/access-control/permissions/#grantpcvcontroller","text":"function grantPCVController(address pcvController) external; assigns PCV Controller\u2699\ufe0f role to pcvController","title":"grantPCVController"},{"location":"old/protocol/access-control/permissions/#grantgovernor","text":"function grantGovernor(address governor) external; assigns Governor\u2696\ufe0frole to governor","title":"grantGovernor"},{"location":"old/protocol/access-control/permissions/#grantguardian","text":"function grantGuardian(address guardian) external; assigns Guardian\ud83d\udee1role to guardian","title":"grantGuardian"},{"location":"old/protocol/access-control/permissions/#revokeminter","text":"function revokeMinter(address minter) external; revokes Minter\ud83d\udcb0role from minter","title":"revokeMinter"},{"location":"old/protocol/access-control/permissions/#revokeburner","text":"function revokeBurner(address burner) external; revokes Burner\ud83d\udd25role from burner","title":"revokeBurner"},{"location":"old/protocol/access-control/permissions/#revokepcvcontroller","text":"function revokePCVController(address pcvController) external; revokes PCV Controller\u2699\ufe0f role from pcvController","title":"revokePCVController"},{"location":"old/protocol/access-control/permissions/#revokegovernor","text":"function revokeGovernor(address governor) external; revokes Governor\u2696\ufe0frole from governor","title":"revokeGovernor"},{"location":"old/protocol/access-control/permissions/#revokeguardian","text":"function revokeGuardian(address guardian) external; revokes Guardian\ud83d\udee1role from guardian","title":"revokeGuardian"},{"location":"old/protocol/access-control/permissions/#guardian-onlystate-changing-functions","text":"","title":"Guardian-Only\ud83d\udee1State-Changing Functions"},{"location":"old/protocol/access-control/permissions/#revokeoverride","text":"function revokeOverride(bytes32 role, address account) external; revokes role from account fails if role is equal to Governor\u2696\ufe0f","title":"revokeOverride"},{"location":"old/protocol/access-control/permissions/#abis","text":"{% file src=\"../../.gitbook/assets/permissions.json\" caption=\"Permissions ABI\" %} {% file src=\"../../.gitbook/assets/ipermissions.json\" caption=\"Permissions Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/bondingcurve/","text":"Bonding Curves Bonding Curves Bonding curves are price functions for a token that generally involve the token being minted by the bonding curve in exchange for an underlying asset. They can take in the current circulating supply as a parameter in the formula. They are generally monotonically increasing, facilitating greater incentives for early adopters. When coupled with a smart contract, bonding curves can escrow, buy and sell tokens in accordance with the price function. The contract can take fees for buying and selling as a fundraising mechanism for Protocol Controlled Value . Article by Linum Labs with more details: {% embed url=\"https://medium.com/linum-labs/intro-to-bonding-curves-and-shapes-bf326bc4e11a\" %} Fei Protocol Bonding Curves Fei Protocol's primary issuance mechanism for FEI are bonding curves. These bonding curves can have any parameterization but should follow this pattern: Use a curve with a desirable growth rate Have a \"shift\" that determines the starting price Have a \"Scale\" target at which the curve switches to fixed relative to the oracle peg Have a \"buffer\" which is a percentage premium above the peg that the curve trades at post-Scale {% hint style=\"success\" %} The Fei Core Team feels strongly that Fei Protocol should only issue bonding curves denominated in decentralized tokens {% endhint %} Fei Protocol bonding curves have unique features. They are buy-only, meaning that purchasers must go elsewhere to sell their FEI. The Fei Protocol prioritizes PCV liquidity with the assets it receives from the curve. Additionally, the price function of a bonding curve is not based on the total circulating supply of FEI but only based on the amount of FEI purchased on that specific bonding curve. Fei Protocol is launching with a single, ETH denominated bonding curve with plans for more as the protocol scales.","title":"Bonding Curves"},{"location":"old/protocol/bondingcurve/#bonding-curves","text":"","title":"Bonding Curves"},{"location":"old/protocol/bondingcurve/#bonding-curves_1","text":"Bonding curves are price functions for a token that generally involve the token being minted by the bonding curve in exchange for an underlying asset. They can take in the current circulating supply as a parameter in the formula. They are generally monotonically increasing, facilitating greater incentives for early adopters. When coupled with a smart contract, bonding curves can escrow, buy and sell tokens in accordance with the price function. The contract can take fees for buying and selling as a fundraising mechanism for Protocol Controlled Value . Article by Linum Labs with more details: {% embed url=\"https://medium.com/linum-labs/intro-to-bonding-curves-and-shapes-bf326bc4e11a\" %}","title":"Bonding Curves"},{"location":"old/protocol/bondingcurve/#fei-protocol-bonding-curves","text":"Fei Protocol's primary issuance mechanism for FEI are bonding curves. These bonding curves can have any parameterization but should follow this pattern: Use a curve with a desirable growth rate Have a \"shift\" that determines the starting price Have a \"Scale\" target at which the curve switches to fixed relative to the oracle peg Have a \"buffer\" which is a percentage premium above the peg that the curve trades at post-Scale {% hint style=\"success\" %} The Fei Core Team feels strongly that Fei Protocol should only issue bonding curves denominated in decentralized tokens {% endhint %} Fei Protocol bonding curves have unique features. They are buy-only, meaning that purchasers must go elsewhere to sell their FEI. The Fei Protocol prioritizes PCV liquidity with the assets it receives from the curve. Additionally, the price function of a bonding curve is not based on the total circulating supply of FEI but only based on the amount of FEI purchased on that specific bonding curve. Fei Protocol is launching with a single, ETH denominated bonding curve with plans for more as the protocol scales.","title":"Fei Protocol Bonding Curves"},{"location":"old/protocol/bondingcurve/bondingcurve/","text":"BondingCurve Contract BondingCurve.sol implements IBondingCurve , OracleRef , PCVSplitter Description An abstract bonding curve for purchasing FEI and routing of the purchased asset to PCV. The amount of PCV it takes in a purchase transaction to bring the curve to a total amount of FEI issued T is determined by integrating the price function between the current FEI amount issued C by the bonding curve and the target amount T after the transaction. The quantity T-C is the amount of FEI received by the transaction. Since C is a known constant, we solve for T by setting the formula equal to a PCV purchase quantity Q and rearranging terms. Post scale, the price should be $1 + b times the peg, where b is the variance buffer and the peg is reported as X per FEI. In the implementation, we use $1 - b because the peg is inverted so the price relationship is also inverted. Allocation Incoming PCV is held temporarily to allow for batch transactions via the allocate() function. The PCV allocation gets split into a weighted list of PCV deposit contracts, (see PCVSplitter ). While allocations can be called at any time, there is a 500 FEI incentive for calling it after each 24 hour window. To determine eligibility for the incentive, simply call isTimeEnded() on the contract. The time until the next incentive is available is remainingTime() . {% page-ref page=\"../references/timed.md\" %} Access Control Minter\ud83d\udcb0 Events {% tabs %} {% tab title=\"Purchase\" %} Purchase of FEI on bonding curve type param description address indexed _to recipient of FEI uint256 _amountIn amount of purchase asset uint256 _amountOut amount of FEI {% endtab %} {% tab title=\"Allocate\" %} Allocate held PCV type param description address indexed _caller the sender of the allocation transaction uint256 _amount the amount of PCV allocated {% endtab %} {% tab title=\"ScaleUpdate\" %} Governance change of Scale target type param description uint256 _scale new Scale target {% endtab %} {% tab title=\"BufferUpdate\" %} Governance change of Buffer type param description uint256 _buffer new buffer {% endtab %} {% tab title=\"IncentiveAmountUpdate\" %} Changes the FEI reward for calling allocate() type param description uint256 _incentiveAmount new incentive amount {% endtab %} {% endtabs %} Read-Only Functions getCurrentPrice function getCurrentPrice() external view returns (Decimal.D256 memory); Returns current instantaneous bonding curve price. The price reported as FEI per X, with X being the underlying asset. This is analogous to the peg reported by the oracle. {% page-ref page=\"../oracles/\" %} {% hint style=\"warning\" %} Can be inaccurate if outdated, need to call oracle().isOutdated() to check {% endhint %} getAverageUSDPrice function getAverageUSDPrice(uint256 amountIn) external view returns (Decimal.D256 memory); Returns the average price of a transaction of size amountIn ETH along bonding curve. The price here is reported as USD per FEI. {% hint style=\"warning\" %} Can be inaccurate if outdated, need to call oracle().isOutdated() to check {% endhint %} getAmountOut function getAmountOut(uint256 amountIn) external view returns (uint256 amountOut); Returns the amount amountOut of FEI received for a purchase of amountIn ETH. {% hint style=\"warning\" %} Can be inaccurate if outdated, need to call oracle().isOutdated() to check {% endhint %} scale function scale() external view returns (uint256); The target totalPurchased after which the bonding curve price switches to a fixed premium on the peg. atScale function atScale() external view returns (bool); Returns true when totalPurchased() is greater than scale() buffer function buffer() external view returns (uint256); The multiplier applied to the peg price when post-Scale. BUFFER_GRANULARITY function BUFFER_GRANULARITY() external view returns (uint256); The granularity of the buffer. Constant at 10,000. totalPurchased function totalPurchased() external view returns (uint256); Returns the cumulative amount of FEI issued via the bonding curve. Used in the bonding curve formula as the supply amount. getTotalPCVHeld function getTotalPCVHeld() external view returns (uint256); Returns the amount of PCV held in the contract and ready for allocation. incentiveAmount function incentiveAmount() external view returns (uint256); Returns the amount of FEI sent to the keeper who calls allocate() while the incentive is active. Public State-Changing Functions purchase function purchase(address to, uint256 amountIn) external payable returns (uint256 amountOut); Purchase amountOut FEI along the bonding curve for amountIn ETH and send the FEI to address to . emits Purchase {% hint style=\"info\" %} This method is pausable {% endhint %} EOA-Only \ud83d\udc64 State-Changing Functions allocate function allocate() external; Allocate the PCV held by the bonding curve to the weighted PCV allocations returned by getAllocation() . emits Allocate {% hint style=\"info\" %} This method is pausable {% endhint %} Governor-Only \u2696\ufe0f State-Changing Functions setBuffer function setBuffer(uint256 _buffer) external; Sets the buffer to _buffer . Must be less than BUFFER_GRANULARITY emits BufferUpdate setScale function setScale(uint256 _scale) external; Sets the Scale target to _scale emits ScaleUpdate setIncentiveAmount function setIncentiveAmount(uint256 _incentiveAmount) external; Sets the incentiveAmount to _incentiveAmount emits IncentiveAmountUpdate setIncentiveFrequency function setIncentiveFrequency(uint256 _frequency) external; Sets the Timed duration to _frequency emits DurationUpdate setAllocation function setAllocation( address[] calldata pcvDeposits, uint256[] calldata ratios ) external; Sets the PCV allocation to pcvDeposits with weights ratios . The ratios must sum to ALLOCATION_GRANULARITY which is constant at 10,000. ABIs {% file src=\"../../.gitbook/assets/bondingcurve.json\" caption=\"BondingCurve ABI\" %} {% file src=\"../../.gitbook/assets/ibondingcurve.json\" caption=\"BondingCurve Interface ABI\" %}","title":"BondingCurve"},{"location":"old/protocol/bondingcurve/bondingcurve/#bondingcurve","text":"","title":"BondingCurve"},{"location":"old/protocol/bondingcurve/bondingcurve/#contract","text":"BondingCurve.sol implements IBondingCurve , OracleRef , PCVSplitter","title":"Contract"},{"location":"old/protocol/bondingcurve/bondingcurve/#description","text":"An abstract bonding curve for purchasing FEI and routing of the purchased asset to PCV. The amount of PCV it takes in a purchase transaction to bring the curve to a total amount of FEI issued T is determined by integrating the price function between the current FEI amount issued C by the bonding curve and the target amount T after the transaction. The quantity T-C is the amount of FEI received by the transaction. Since C is a known constant, we solve for T by setting the formula equal to a PCV purchase quantity Q and rearranging terms. Post scale, the price should be $1 + b times the peg, where b is the variance buffer and the peg is reported as X per FEI. In the implementation, we use $1 - b because the peg is inverted so the price relationship is also inverted.","title":"Description"},{"location":"old/protocol/bondingcurve/bondingcurve/#allocation","text":"Incoming PCV is held temporarily to allow for batch transactions via the allocate() function. The PCV allocation gets split into a weighted list of PCV deposit contracts, (see PCVSplitter ). While allocations can be called at any time, there is a 500 FEI incentive for calling it after each 24 hour window. To determine eligibility for the incentive, simply call isTimeEnded() on the contract. The time until the next incentive is available is remainingTime() . {% page-ref page=\"../references/timed.md\" %}","title":"Allocation"},{"location":"old/protocol/bondingcurve/bondingcurve/#access-control","text":"Minter\ud83d\udcb0","title":"Access Control"},{"location":"old/protocol/bondingcurve/bondingcurve/#events","text":"{% tabs %} {% tab title=\"Purchase\" %} Purchase of FEI on bonding curve type param description address indexed _to recipient of FEI uint256 _amountIn amount of purchase asset uint256 _amountOut amount of FEI {% endtab %} {% tab title=\"Allocate\" %} Allocate held PCV type param description address indexed _caller the sender of the allocation transaction uint256 _amount the amount of PCV allocated {% endtab %} {% tab title=\"ScaleUpdate\" %} Governance change of Scale target type param description uint256 _scale new Scale target {% endtab %} {% tab title=\"BufferUpdate\" %} Governance change of Buffer type param description uint256 _buffer new buffer {% endtab %} {% tab title=\"IncentiveAmountUpdate\" %} Changes the FEI reward for calling allocate() type param description uint256 _incentiveAmount new incentive amount {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/bondingcurve/bondingcurve/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/bondingcurve/bondingcurve/#getcurrentprice","text":"function getCurrentPrice() external view returns (Decimal.D256 memory); Returns current instantaneous bonding curve price. The price reported as FEI per X, with X being the underlying asset. This is analogous to the peg reported by the oracle. {% page-ref page=\"../oracles/\" %} {% hint style=\"warning\" %} Can be inaccurate if outdated, need to call oracle().isOutdated() to check {% endhint %}","title":"getCurrentPrice"},{"location":"old/protocol/bondingcurve/bondingcurve/#getaverageusdprice","text":"function getAverageUSDPrice(uint256 amountIn) external view returns (Decimal.D256 memory); Returns the average price of a transaction of size amountIn ETH along bonding curve. The price here is reported as USD per FEI. {% hint style=\"warning\" %} Can be inaccurate if outdated, need to call oracle().isOutdated() to check {% endhint %}","title":"getAverageUSDPrice"},{"location":"old/protocol/bondingcurve/bondingcurve/#getamountout","text":"function getAmountOut(uint256 amountIn) external view returns (uint256 amountOut); Returns the amount amountOut of FEI received for a purchase of amountIn ETH. {% hint style=\"warning\" %} Can be inaccurate if outdated, need to call oracle().isOutdated() to check {% endhint %}","title":"getAmountOut"},{"location":"old/protocol/bondingcurve/bondingcurve/#scale","text":"function scale() external view returns (uint256); The target totalPurchased after which the bonding curve price switches to a fixed premium on the peg.","title":"scale"},{"location":"old/protocol/bondingcurve/bondingcurve/#atscale","text":"function atScale() external view returns (bool); Returns true when totalPurchased() is greater than scale()","title":"atScale"},{"location":"old/protocol/bondingcurve/bondingcurve/#buffer","text":"function buffer() external view returns (uint256); The multiplier applied to the peg price when post-Scale.","title":"buffer"},{"location":"old/protocol/bondingcurve/bondingcurve/#buffer_granularity","text":"function BUFFER_GRANULARITY() external view returns (uint256); The granularity of the buffer. Constant at 10,000.","title":"BUFFER_GRANULARITY"},{"location":"old/protocol/bondingcurve/bondingcurve/#totalpurchased","text":"function totalPurchased() external view returns (uint256); Returns the cumulative amount of FEI issued via the bonding curve. Used in the bonding curve formula as the supply amount.","title":"totalPurchased"},{"location":"old/protocol/bondingcurve/bondingcurve/#gettotalpcvheld","text":"function getTotalPCVHeld() external view returns (uint256); Returns the amount of PCV held in the contract and ready for allocation.","title":"getTotalPCVHeld"},{"location":"old/protocol/bondingcurve/bondingcurve/#incentiveamount","text":"function incentiveAmount() external view returns (uint256); Returns the amount of FEI sent to the keeper who calls allocate() while the incentive is active.","title":"incentiveAmount"},{"location":"old/protocol/bondingcurve/bondingcurve/#public-state-changing-functions","text":"","title":"Public State-Changing Functions"},{"location":"old/protocol/bondingcurve/bondingcurve/#purchase","text":"function purchase(address to, uint256 amountIn) external payable returns (uint256 amountOut); Purchase amountOut FEI along the bonding curve for amountIn ETH and send the FEI to address to . emits Purchase {% hint style=\"info\" %} This method is pausable {% endhint %}","title":"purchase"},{"location":"old/protocol/bondingcurve/bondingcurve/#eoa-only-state-changing-functions","text":"","title":"EOA-Only \ud83d\udc64 State-Changing Functions"},{"location":"old/protocol/bondingcurve/bondingcurve/#allocate","text":"function allocate() external; Allocate the PCV held by the bonding curve to the weighted PCV allocations returned by getAllocation() . emits Allocate {% hint style=\"info\" %} This method is pausable {% endhint %}","title":"allocate"},{"location":"old/protocol/bondingcurve/bondingcurve/#governor-only-state-changing-functions","text":"","title":"Governor-Only\u2696\ufe0f State-Changing Functions"},{"location":"old/protocol/bondingcurve/bondingcurve/#setbuffer","text":"function setBuffer(uint256 _buffer) external; Sets the buffer to _buffer . Must be less than BUFFER_GRANULARITY emits BufferUpdate","title":"setBuffer"},{"location":"old/protocol/bondingcurve/bondingcurve/#setscale","text":"function setScale(uint256 _scale) external; Sets the Scale target to _scale emits ScaleUpdate","title":"setScale"},{"location":"old/protocol/bondingcurve/bondingcurve/#setincentiveamount","text":"function setIncentiveAmount(uint256 _incentiveAmount) external; Sets the incentiveAmount to _incentiveAmount emits IncentiveAmountUpdate","title":"setIncentiveAmount"},{"location":"old/protocol/bondingcurve/bondingcurve/#setincentivefrequency","text":"function setIncentiveFrequency(uint256 _frequency) external; Sets the Timed duration to _frequency emits DurationUpdate","title":"setIncentiveFrequency"},{"location":"old/protocol/bondingcurve/bondingcurve/#setallocation","text":"function setAllocation( address[] calldata pcvDeposits, uint256[] calldata ratios ) external; Sets the PCV allocation to pcvDeposits with weights ratios . The ratios must sum to ALLOCATION_GRANULARITY which is constant at 10,000.","title":"setAllocation"},{"location":"old/protocol/bondingcurve/bondingcurve/#abis","text":"{% file src=\"../../.gitbook/assets/bondingcurve.json\" caption=\"BondingCurve ABI\" %} {% file src=\"../../.gitbook/assets/ibondingcurve.json\" caption=\"BondingCurve Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/bondingcurve/ethbondingcurve/","text":"EthBondingCurve Contract EthBondingCurve.sol implements BondingCurve Description A bonding curve implementation for purchasing FEI with ETH. The price function used is: x - the current amount of FEI issued from the bonding curve S - the Scale target O - the oracle price reported as underlying per FEI The \"k\" shift is an additional feature since the white paper release. It shifts the starting price upward so the protocol can retain more PCV . k is initially set to S/3 which makes the starting price $0.50 per FEI. The amount of FEI out for a given quantity of ETH input Q is equal to the following: y is the cumulative amount of FEI sold by the bonding curve after the trade and C is the current cumulative, so their difference is the amount sent to the user. The Scale target is 100,000,000 FEI. \u200c Post-Scale, the Bonding curve sets the exchange rate at $1 + b, where b is a buffer. The buffer is initially set to 1% to allow for variance above $1. Governance can vote to converge b to 0 as the liquidity increases and volatility decreases. The oracle used is the UniswapOracle . Access Control Minter\ud83d\udcb0 ABIs {% file src=\"../../.gitbook/assets/ethbondingcurve.json\" caption=\"EthBondingCurve ABI\" %}","title":"EthBondingCurve"},{"location":"old/protocol/bondingcurve/ethbondingcurve/#ethbondingcurve","text":"","title":"EthBondingCurve"},{"location":"old/protocol/bondingcurve/ethbondingcurve/#contract","text":"EthBondingCurve.sol implements BondingCurve","title":"Contract"},{"location":"old/protocol/bondingcurve/ethbondingcurve/#description","text":"A bonding curve implementation for purchasing FEI with ETH. The price function used is: x - the current amount of FEI issued from the bonding curve S - the Scale target O - the oracle price reported as underlying per FEI The \"k\" shift is an additional feature since the white paper release. It shifts the starting price upward so the protocol can retain more PCV . k is initially set to S/3 which makes the starting price $0.50 per FEI. The amount of FEI out for a given quantity of ETH input Q is equal to the following: y is the cumulative amount of FEI sold by the bonding curve after the trade and C is the current cumulative, so their difference is the amount sent to the user. The Scale target is 100,000,000 FEI. \u200c Post-Scale, the Bonding curve sets the exchange rate at $1 + b, where b is a buffer. The buffer is initially set to 1% to allow for variance above $1. Governance can vote to converge b to 0 as the liquidity increases and volatility decreases. The oracle used is the UniswapOracle .","title":"Description"},{"location":"old/protocol/bondingcurve/ethbondingcurve/#access-control","text":"Minter\ud83d\udcb0","title":"Access Control"},{"location":"old/protocol/bondingcurve/ethbondingcurve/#abis","text":"{% file src=\"../../.gitbook/assets/ethbondingcurve.json\" caption=\"EthBondingCurve ABI\" %}","title":"ABIs"},{"location":"old/protocol/fei-stablecoin/","text":"Fei Stablecoin Design FEI (Fei USD) is designed to allow for flexible upgrades and arbitrary incentive mechanisms to support the $1 peg target. Its issuance is controlled by the Minter\ud83d\udcb0role, and any contract with this role can mint FEI to any address. The Burner\ud83d\udd25 role can burn FEI from any address, and is utilized for deflation and disincentives. Direct Incentives Fei Protocol uses the Direct Incentive approach to peg stability. This means that user actions can lead to a mint or burn of FEI from their wallet. The magnitude and direction of the incentive is based on the action taken and the market conditions at the time. The Direct Incentives are applied only when interacting with an incentivized address . When FEI is transferred to or from an __incentivized address, the corresponding incentive contract is called, which is either a Minter\ud83d\udcb0, a Burner\ud83d\udd25, or both. The only incentivized address at launch is the ETH/FEI Uniswap v2 Pair and its incentive contract is UniswapIncentive . The Governor\u2696\ufe0f can set and unset incentive contracts for any address. It can also exempt addresses from incentives. Inclusive Fee On Transfer Fees applied to incentivized trading or transfers can be either inclusive or exclusive. The inclusive fees are more commonly utilized in DeFi. Inclusive fees are applied \"in-flight\", meaning that the fee is extracted from the transfer or the trade amount itself. Exclusive fees are applied on top of the transfer or trade amount itself. The exclusive fee is commonly applied to the party initiating the transaction. Fei Protocol v1 uses an \"inclusive\" fee on transfers when applying Direct Incentives on Uniswap sells. There are certain considerations with this approach, the main one being that Fei Protocol cannot differentiate between selling and liquidity provision. Therefore the fee applies to all FEI transfers to the pool including providing LP. {% hint style=\"warning\" %} LPing the FEI/ETH Uniswap pool also incurs a burn penalty, because it transfers FEI into the pool like a sell would {% endhint %} Collateralization The FEI stablecoin is collateralized by a PCV reserve. Fei Protocol prioritizes liquidity when deploying this reserve to make sure users are able to trade FEI at high volume. Critically, FEI can be over- or under-collateralized depending on volatility on the PCV and other market conditions. The collateralization ratio of FEI at any time is calculated as follows, with the denominator being \"User controlled FEI\": The formula ignores \"Protocol controlled FEI\" because any FEI that the protocol holds will never be sold for PCV, only burned. Protocol controlled FEI can have second-order, short-term inflationary effects. For instance, FEI deposited into a lending market by Fei Protocol could increase the circulating supply when borrowed. The interest accrued and eventual withdrawal of that FEI ultimately have a net deflationary effect in the long term.","title":"Fei Stablecoin"},{"location":"old/protocol/fei-stablecoin/#fei-stablecoin","text":"","title":"Fei Stablecoin"},{"location":"old/protocol/fei-stablecoin/#design","text":"FEI (Fei USD) is designed to allow for flexible upgrades and arbitrary incentive mechanisms to support the $1 peg target. Its issuance is controlled by the Minter\ud83d\udcb0role, and any contract with this role can mint FEI to any address. The Burner\ud83d\udd25 role can burn FEI from any address, and is utilized for deflation and disincentives.","title":"Design"},{"location":"old/protocol/fei-stablecoin/#direct-incentives","text":"Fei Protocol uses the Direct Incentive approach to peg stability. This means that user actions can lead to a mint or burn of FEI from their wallet. The magnitude and direction of the incentive is based on the action taken and the market conditions at the time. The Direct Incentives are applied only when interacting with an incentivized address . When FEI is transferred to or from an __incentivized address, the corresponding incentive contract is called, which is either a Minter\ud83d\udcb0, a Burner\ud83d\udd25, or both. The only incentivized address at launch is the ETH/FEI Uniswap v2 Pair and its incentive contract is UniswapIncentive . The Governor\u2696\ufe0f can set and unset incentive contracts for any address. It can also exempt addresses from incentives.","title":"Direct Incentives"},{"location":"old/protocol/fei-stablecoin/#inclusive-fee-on-transfer","text":"Fees applied to incentivized trading or transfers can be either inclusive or exclusive. The inclusive fees are more commonly utilized in DeFi. Inclusive fees are applied \"in-flight\", meaning that the fee is extracted from the transfer or the trade amount itself. Exclusive fees are applied on top of the transfer or trade amount itself. The exclusive fee is commonly applied to the party initiating the transaction. Fei Protocol v1 uses an \"inclusive\" fee on transfers when applying Direct Incentives on Uniswap sells. There are certain considerations with this approach, the main one being that Fei Protocol cannot differentiate between selling and liquidity provision. Therefore the fee applies to all FEI transfers to the pool including providing LP. {% hint style=\"warning\" %} LPing the FEI/ETH Uniswap pool also incurs a burn penalty, because it transfers FEI into the pool like a sell would {% endhint %}","title":"Inclusive Fee On Transfer"},{"location":"old/protocol/fei-stablecoin/#collateralization","text":"The FEI stablecoin is collateralized by a PCV reserve. Fei Protocol prioritizes liquidity when deploying this reserve to make sure users are able to trade FEI at high volume. Critically, FEI can be over- or under-collateralized depending on volatility on the PCV and other market conditions. The collateralization ratio of FEI at any time is calculated as follows, with the denominator being \"User controlled FEI\": The formula ignores \"Protocol controlled FEI\" because any FEI that the protocol holds will never be sold for PCV, only burned. Protocol controlled FEI can have second-order, short-term inflationary effects. For instance, FEI deposited into a lending market by Fei Protocol could increase the circulating supply when borrowed. The interest accrued and eventual withdrawal of that FEI ultimately have a net deflationary effect in the long term.","title":"Collateralization"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/","text":"FEI (Fei USD) Contract Fei.sol implements IFei.sol , CoreRef , ERC20Burnable Description FEI is a regular ERC-20 token, based on the OpenZeppelin ERC-20Burnable code with the following modifications: Minting and burning to any address are uncapped and accessible by any address with the Minter\ud83d\udcb0and Burner\ud83d\udd25 role, respectively. At each transfer (or transferFrom) the following addresses are checked for a mapped incentive contract: FEI sender FEI receiver FEI operator (msg.sender) - commonly the same as the sender unless using transferFrom with an approved contract the zero address - represens an incentive to be applied on ALL transfers If an incentive contract is found, it is called with all of the transfer parameters. Any incentive is applied after the token balances update from the transfer. Events {% tabs %} {% tab title=\"Minting\" %} Minting FEI to an address type param description address indexed _to The recipient of the minted FEI address indexed _minter The contract that minted the FEI uint256 _amount The amount of FEI minted {% endtab %} {% tab title=\"Burning\" %} Burning FEI from an address type param description address indexed _to The target of the burned FEI address indexed _burner The contract that burned the FEI uint256 _amount The amount of FEI minted {% endtab %} {% tab title=\"IncentiveContractUpdate\" %} setting or unsetting an incentive contract for an incentivized address type param description address indexed _incentivized The incentivized address address indexed _incentiveContract The new incentive contract. address(0) to unset {% endtab %} {% endtabs %} Read-Only Functions incentiveContract function incentiveContract(address account) external view returns (address); returns the mapped incentive contract if account is an incentivized address, otherwise returns the 0 address. {% hint style=\"info\" %} if the 0 address has a mapped incentive contract, then this incentive contract is called for every single FEI transfer. {% endhint %} Burner-Only\ud83d\udd25 State-Changing Functions burnFrom function burnFrom(address account, uint256 amount) external; Burns amount FEI from account . Reverts if the FEI balance of account is less than amount emits Burning Minter-Only\ud83d\udcb0 State-Changing Functions mint function mint(address account, uint256 amount) external; Mints amount FEI to account emits Minting Governor-Only\u2696\ufe0f State-Changing Functions setIncentiveContract function setIncentiveContract(address account, address incentive) external; Sets the incentive contract incentive for account . If incentive is the 0 address this functions as an unset. emits IncentiveContractUpdate Public State-Changing Functions burn function burn(uint256 amount) external; Burns amount FEI from msg.sender . Reverts if the FEI balance of msg.sender is less than amount emits Burning permit function permit( address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external; Sets the allowance for a spender for value FEI from owner via signature. Reverts if called after deadline ABIs {% file src=\"../../.gitbook/assets/fei.json\" caption=\"Fei ABI\" %} {% file src=\"../../.gitbook/assets/ifei.json\" caption=\"Fei Interface ABI\" %}","title":"FEI \\(Fei USD\\)"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/#fei-fei-usd","text":"","title":"FEI (Fei USD)"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/#contract","text":"Fei.sol implements IFei.sol , CoreRef , ERC20Burnable","title":"Contract"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/#description","text":"FEI is a regular ERC-20 token, based on the OpenZeppelin ERC-20Burnable code with the following modifications: Minting and burning to any address are uncapped and accessible by any address with the Minter\ud83d\udcb0and Burner\ud83d\udd25 role, respectively. At each transfer (or transferFrom) the following addresses are checked for a mapped incentive contract: FEI sender FEI receiver FEI operator (msg.sender) - commonly the same as the sender unless using transferFrom with an approved contract the zero address - represens an incentive to be applied on ALL transfers If an incentive contract is found, it is called with all of the transfer parameters. Any incentive is applied after the token balances update from the transfer.","title":"Description"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/#events","text":"{% tabs %} {% tab title=\"Minting\" %} Minting FEI to an address type param description address indexed _to The recipient of the minted FEI address indexed _minter The contract that minted the FEI uint256 _amount The amount of FEI minted {% endtab %} {% tab title=\"Burning\" %} Burning FEI from an address type param description address indexed _to The target of the burned FEI address indexed _burner The contract that burned the FEI uint256 _amount The amount of FEI minted {% endtab %} {% tab title=\"IncentiveContractUpdate\" %} setting or unsetting an incentive contract for an incentivized address type param description address indexed _incentivized The incentivized address address indexed _incentiveContract The new incentive contract. address(0) to unset {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/#incentivecontract","text":"function incentiveContract(address account) external view returns (address); returns the mapped incentive contract if account is an incentivized address, otherwise returns the 0 address. {% hint style=\"info\" %} if the 0 address has a mapped incentive contract, then this incentive contract is called for every single FEI transfer. {% endhint %}","title":"incentiveContract"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/#burner-only-state-changing-functions","text":"","title":"Burner-Only\ud83d\udd25 State-Changing Functions"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/#burnfrom","text":"function burnFrom(address account, uint256 amount) external; Burns amount FEI from account . Reverts if the FEI balance of account is less than amount emits Burning","title":"burnFrom"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/#minter-only-state-changing-functions","text":"","title":"Minter-Only\ud83d\udcb0 State-Changing Functions"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/#mint","text":"function mint(address account, uint256 amount) external; Mints amount FEI to account emits Minting","title":"mint"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/#governor-only-state-changing-functions","text":"","title":"Governor-Only\u2696\ufe0f State-Changing Functions"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/#setincentivecontract","text":"function setIncentiveContract(address account, address incentive) external; Sets the incentive contract incentive for account . If incentive is the 0 address this functions as an unset. emits IncentiveContractUpdate","title":"setIncentiveContract"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/#public-state-changing-functions","text":"","title":"Public State-Changing Functions"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/#burn","text":"function burn(uint256 amount) external; Burns amount FEI from msg.sender . Reverts if the FEI balance of msg.sender is less than amount emits Burning","title":"burn"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/#permit","text":"function permit( address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s ) external; Sets the allowance for a spender for value FEI from owner via signature. Reverts if called after deadline","title":"permit"},{"location":"old/protocol/fei-stablecoin/fei-fei-usd/#abis","text":"{% file src=\"../../.gitbook/assets/fei.json\" caption=\"Fei ABI\" %} {% file src=\"../../.gitbook/assets/ifei.json\" caption=\"Fei Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/","text":"UniswapIncentive Contract UniswapIncentive.sol implements IUniswapIncentive , UniRef Description {% hint style=\"info\" %} Because this contract can be swapped for a new UniswapIncentive, for integrations we recommend calling incentiveContract(0x94B0A3d511b6EcDb17eBF877278Ab030acb0A878) on the FEI token to always read the currently applied UniswapIncentive on the ETH-FEI pair {% endhint %} The FEI incentive contract applied on transfers involving a Uniswap pair. The UniswapIncentive contract assumes that all transfers involving Uniswap are either a sell or a buy. In either case, the hypothetical start and end price are calculated then compared to the peg to capture the magnitude distance m . See UniRef for more details on how these formulas are derived. {% page-ref page=\"../references/uniref.md\" %} These parameters are fed into the incentive function to produce a mint (in the case of buy) or burn (in the case of sell) action. Any address can be exempted from incentives by governance. {% hint style=\"info\" %} The below incentives only apply to the FEI portion of the trade that would be below the peg. When calculating \"x\", the contract uses the \"distance from peg FEI\" method in UniRef . {% endhint %} Sell (Burn) All FEI transfers going TO the uniswap pool are treated as a sell. This has the counterintuitive effect of treating liquidity provision as a sell. The implementation integrates the burn function from the white paper with respect to the distance from the peg. This creates a nice path independent property where a trader is no better off doing one large trade or many small trades, ignoring fees. The burn formula for sell amount x is: The burn is only applied to trades below the peg when the incentive contract is appointed as a Burner\ud83d\udd25. The burn is taken from the in-flight trade amount. If the burn is 5% on a 100 FEI transfer then the recipient gets 95 FEI. {% hint style=\"info\" %} The entire trade size including the burn is used to calculate the slippage for the end deviation from the peg. This could lead to a higher than expected burn for large trades when below peg. {% endhint %} {% hint style=\"warning\" %} The trade will revert if the burn would be greater than or equal to the entire transfer amount {% endhint %} Buy (Mint) All transfers going FROM the uniswap pool are treated as a buy. This has the counterintuitive effect of treating liquidity withdrawal events as buys. The initial magnitude m deviation from the peg before the hypothetical trade is used to maximize the potential mint amount. w is the time weight we discuss in the next section. The mint formula for buy amount x is: The incentive formula is normally just the right-hand side of the above min function. It is linear in the time weight w(t) and the distance from the peg m When the incentive function for a trade reaches the same level as the burn for the same trade in reverse , the incentive function maxes out. This is because we don't want a trader to be able to profit by buying and selling with a flash loan under any circumstances. The mint should only apply if the trade starts below the peg and if the incentive contract is appointed as a Minter. Incentivized Amount The incentivized amount on Uniswap FEI-ETH trades is only calculated based on the amount that pushes FEI below the peg for a sell or up to the peg for a buy. For example say a trade starts 1% below the peg and ends 1% above, only approximately half of the trade will get the bonus. Time Weight The time weight w is a scaling factor utilized to make the incentive mint structured like an auction. The trader willing to accept the lowest mint will execute a buy before the reward gets higher. The time weight grows linearly at a rate of 75/100,000 per block, which equals 1 after approximately 5 hours. It should only grow while \"active\" and will only be active when the last trade ended below the peg. The rate can be changed by governance. Trades should update the time weight as follows: If ending above peg, set to 0 and deactivate If ending below the peg but starting above, set to 0 and activate If starting and ending below peg, update pro-rata with a buy based on percent towards peg. E.g., if a trade starts at 10% deviation and ends at 1%, time weight should be scaled by 1%/10% =.10. If starting and ending below the peg, cap the time weight at the max incentive for the ending distance Incentive Parity Incentive parity is defined as a boolean expression, which is true when the mint incentive equals its max for the current distance from the peg m . It simplifies down to the following: Parity is used as a trigger condition for reweights in the UniswapPCVController Access Control Minter\ud83d\udcb0 Burner\ud83d\udd25 Events {% tabs %} {% tab title=\"TimeWeightUpdate\" %} Time Weight change type param description uint256 _weight new time weight uint256 _active whether time weight is growing or not {% endtab %} {% tab title=\"GrowthRateUpdate\" %} Governance change of time weight growth weight type param description uint256 _growthRate new growth rate {% endtab %} {% tab title=\"ExemptAddressUpdate\" %} Governance change of an exempt address type param description address indexed _account the address to update bool _isExempt whether the account is exempt or not {% endtab %} {% tab title=\"SellAllowedAddressUpdate\" %} Governance change of a sell allowlisted address type param description address indexed _account the address to update bool _isSellAllowed whether the account is allowlisted or not {% endtab %} {% endtabs %} Read-Only Functions isIncentiveParity function isIncentiveParity() external view returns (bool); returns true if the conditions for incentive parity (see above) are met, otherwise false. isExemptAddress function isExemptAddress(address account) external view returns (bool); returns true if account is exempted from incentives, otherwise false TIME_WEIGHT_GRANULARITY function TIME_WEIGHT_GRANULARITY() external view returns (uint32); returns the granularity of the time weight variable, set as a constant to 100,000 getGrowthRate function getGrowthRate() external view returns (uint32); returns the current time weight growth rate, per block getTimeWeight function getTimeWeight() external view returns (uint32); returns the current time weight isTimeWeightActive function isTimeWeightActive() external view returns (bool); returns true if the time weight is active and growing getBuyIncentive function getBuyIncentive(uint256 amount) external view returns ( uint256 incentive, uint32 weight, Decimal.D256 memory initialDeviation, Decimal.D256 memory finalDeviation ); returns the buy incentive amount incentive for a FEI transfer of amount out of the FEI/ETH incentivized Uniswap pool. Also returns the updated time weight weight and the initialDeviation and finalDeviation which are equal to m start and end, respectively. getSellPenalty function getSellPenalty(uint256 amount) external view returns ( uint256 penalty, Decimal.D256 memory initialDeviation, Decimal.D256 memory finalDeviation ); returns the sell penalty amount penalty a FEI transfer of amount into the FEI/ETH incentivized Uniswap pool. Also returns the initialDeviation and finalDeviation which are equal to m start and end, respectively. getSellPenaltyMultiplier function getSellPenaltyMultiplier( Decimal.D256 calldata initialDeviation, Decimal.D256 calldata finalDeviation ) external view returns (Decimal.D256 memory); Returns the sell penalty multiplier applied to a trade which starts at initialDeviation from the peg and ends at finalDeviation from the peg. To return the instantaneous multiplier, set initial and final equal to each other. getBuyIncentiveMultiplier function getBuyIncentiveMultiplier( Decimal.D256 calldata initialDeviation, Decimal.D256 calldata finalDeviation ) external view returns (Decimal.D256 memory); Returns the buy incentive multiplier applied to a trade which starts at initialDeviation from the peg and ends at finalDeviation from the peg. To return the instantaneous multiplier, set initial and final equal to each other. {% hint style=\"info\" %} getBuyIncentiveMultiplier() uses the current time weight for calculating incentives. {% endhint %} Governor-Only\u2696\ufe0f State-Changing Functions setExemptAddress function setExemptAddress(address account, bool isExempt) external; set account incentive exempt status to isExempt emits ExemptAddressUpdate setTimeWeight function setTimeWeight( uint32 weight, uint32 growth, bool active ) external; set the current time weight to weight , growing at a rate growth and active flag to active starting from the current block. emits TimeWeightUpdate and GrowthRateUpdate if the growth rate changes Fei-Only\ud83c\udf32 incentivize function incentivize( address sender, address receiver, address operator, uint256 amountIn ) external updates the oracle at the beginning of the flow applies the buy reward based on amountIn if: below peg time weight non-zero contract is a Minter\ud83d\udcb0 sender is the ETH/FEI incentivized pair receiver is not exempt applies the sell penalty based on amountIn if: trade ends below peg contract is a Burner\ud83d\udd25 receiver is the ETH/FEI incentivized pair sender is not exempt ABIs {% file src=\"../../.gitbook/assets/uniswapincentive.json\" caption=\"UniswapIncentive ABI\" %} {% file src=\"../../.gitbook/assets/iuniswapincentive.json\" caption=\"UniswapIncentive Interface ABI\" %}","title":"UniswapIncentive"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#uniswapincentive","text":"","title":"UniswapIncentive"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#contract","text":"UniswapIncentive.sol implements IUniswapIncentive , UniRef","title":"Contract"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#description","text":"{% hint style=\"info\" %} Because this contract can be swapped for a new UniswapIncentive, for integrations we recommend calling incentiveContract(0x94B0A3d511b6EcDb17eBF877278Ab030acb0A878) on the FEI token to always read the currently applied UniswapIncentive on the ETH-FEI pair {% endhint %} The FEI incentive contract applied on transfers involving a Uniswap pair. The UniswapIncentive contract assumes that all transfers involving Uniswap are either a sell or a buy. In either case, the hypothetical start and end price are calculated then compared to the peg to capture the magnitude distance m . See UniRef for more details on how these formulas are derived. {% page-ref page=\"../references/uniref.md\" %} These parameters are fed into the incentive function to produce a mint (in the case of buy) or burn (in the case of sell) action. Any address can be exempted from incentives by governance. {% hint style=\"info\" %} The below incentives only apply to the FEI portion of the trade that would be below the peg. When calculating \"x\", the contract uses the \"distance from peg FEI\" method in UniRef . {% endhint %}","title":"Description"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#sell-burn","text":"All FEI transfers going TO the uniswap pool are treated as a sell. This has the counterintuitive effect of treating liquidity provision as a sell. The implementation integrates the burn function from the white paper with respect to the distance from the peg. This creates a nice path independent property where a trader is no better off doing one large trade or many small trades, ignoring fees. The burn formula for sell amount x is: The burn is only applied to trades below the peg when the incentive contract is appointed as a Burner\ud83d\udd25. The burn is taken from the in-flight trade amount. If the burn is 5% on a 100 FEI transfer then the recipient gets 95 FEI. {% hint style=\"info\" %} The entire trade size including the burn is used to calculate the slippage for the end deviation from the peg. This could lead to a higher than expected burn for large trades when below peg. {% endhint %} {% hint style=\"warning\" %} The trade will revert if the burn would be greater than or equal to the entire transfer amount {% endhint %}","title":"Sell (Burn)"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#buy-mint","text":"All transfers going FROM the uniswap pool are treated as a buy. This has the counterintuitive effect of treating liquidity withdrawal events as buys. The initial magnitude m deviation from the peg before the hypothetical trade is used to maximize the potential mint amount. w is the time weight we discuss in the next section. The mint formula for buy amount x is: The incentive formula is normally just the right-hand side of the above min function. It is linear in the time weight w(t) and the distance from the peg m When the incentive function for a trade reaches the same level as the burn for the same trade in reverse , the incentive function maxes out. This is because we don't want a trader to be able to profit by buying and selling with a flash loan under any circumstances. The mint should only apply if the trade starts below the peg and if the incentive contract is appointed as a Minter.","title":"Buy (Mint)"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#incentivized-amount","text":"The incentivized amount on Uniswap FEI-ETH trades is only calculated based on the amount that pushes FEI below the peg for a sell or up to the peg for a buy. For example say a trade starts 1% below the peg and ends 1% above, only approximately half of the trade will get the bonus.","title":"Incentivized Amount"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#time-weight","text":"The time weight w is a scaling factor utilized to make the incentive mint structured like an auction. The trader willing to accept the lowest mint will execute a buy before the reward gets higher. The time weight grows linearly at a rate of 75/100,000 per block, which equals 1 after approximately 5 hours. It should only grow while \"active\" and will only be active when the last trade ended below the peg. The rate can be changed by governance. Trades should update the time weight as follows: If ending above peg, set to 0 and deactivate If ending below the peg but starting above, set to 0 and activate If starting and ending below peg, update pro-rata with a buy based on percent towards peg. E.g., if a trade starts at 10% deviation and ends at 1%, time weight should be scaled by 1%/10% =.10. If starting and ending below the peg, cap the time weight at the max incentive for the ending distance","title":"Time Weight"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#incentive-parity","text":"Incentive parity is defined as a boolean expression, which is true when the mint incentive equals its max for the current distance from the peg m . It simplifies down to the following: Parity is used as a trigger condition for reweights in the UniswapPCVController","title":"Incentive Parity"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#access-control","text":"Minter\ud83d\udcb0 Burner\ud83d\udd25","title":"Access Control"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#events","text":"{% tabs %} {% tab title=\"TimeWeightUpdate\" %} Time Weight change type param description uint256 _weight new time weight uint256 _active whether time weight is growing or not {% endtab %} {% tab title=\"GrowthRateUpdate\" %} Governance change of time weight growth weight type param description uint256 _growthRate new growth rate {% endtab %} {% tab title=\"ExemptAddressUpdate\" %} Governance change of an exempt address type param description address indexed _account the address to update bool _isExempt whether the account is exempt or not {% endtab %} {% tab title=\"SellAllowedAddressUpdate\" %} Governance change of a sell allowlisted address type param description address indexed _account the address to update bool _isSellAllowed whether the account is allowlisted or not {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#isincentiveparity","text":"function isIncentiveParity() external view returns (bool); returns true if the conditions for incentive parity (see above) are met, otherwise false.","title":"isIncentiveParity"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#isexemptaddress","text":"function isExemptAddress(address account) external view returns (bool); returns true if account is exempted from incentives, otherwise false","title":"isExemptAddress"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#time_weight_granularity","text":"function TIME_WEIGHT_GRANULARITY() external view returns (uint32); returns the granularity of the time weight variable, set as a constant to 100,000","title":"TIME_WEIGHT_GRANULARITY"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#getgrowthrate","text":"function getGrowthRate() external view returns (uint32); returns the current time weight growth rate, per block","title":"getGrowthRate"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#gettimeweight","text":"function getTimeWeight() external view returns (uint32); returns the current time weight","title":"getTimeWeight"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#istimeweightactive","text":"function isTimeWeightActive() external view returns (bool); returns true if the time weight is active and growing","title":"isTimeWeightActive"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#getbuyincentive","text":"function getBuyIncentive(uint256 amount) external view returns ( uint256 incentive, uint32 weight, Decimal.D256 memory initialDeviation, Decimal.D256 memory finalDeviation ); returns the buy incentive amount incentive for a FEI transfer of amount out of the FEI/ETH incentivized Uniswap pool. Also returns the updated time weight weight and the initialDeviation and finalDeviation which are equal to m start and end, respectively.","title":"getBuyIncentive"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#getsellpenalty","text":"function getSellPenalty(uint256 amount) external view returns ( uint256 penalty, Decimal.D256 memory initialDeviation, Decimal.D256 memory finalDeviation ); returns the sell penalty amount penalty a FEI transfer of amount into the FEI/ETH incentivized Uniswap pool. Also returns the initialDeviation and finalDeviation which are equal to m start and end, respectively.","title":"getSellPenalty"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#getsellpenaltymultiplier","text":"function getSellPenaltyMultiplier( Decimal.D256 calldata initialDeviation, Decimal.D256 calldata finalDeviation ) external view returns (Decimal.D256 memory); Returns the sell penalty multiplier applied to a trade which starts at initialDeviation from the peg and ends at finalDeviation from the peg. To return the instantaneous multiplier, set initial and final equal to each other.","title":"getSellPenaltyMultiplier"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#getbuyincentivemultiplier","text":"function getBuyIncentiveMultiplier( Decimal.D256 calldata initialDeviation, Decimal.D256 calldata finalDeviation ) external view returns (Decimal.D256 memory); Returns the buy incentive multiplier applied to a trade which starts at initialDeviation from the peg and ends at finalDeviation from the peg. To return the instantaneous multiplier, set initial and final equal to each other. {% hint style=\"info\" %} getBuyIncentiveMultiplier() uses the current time weight for calculating incentives. {% endhint %}","title":"getBuyIncentiveMultiplier"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#governor-only-state-changing-functions","text":"","title":"Governor-Only\u2696\ufe0f State-Changing Functions"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#setexemptaddress","text":"function setExemptAddress(address account, bool isExempt) external; set account incentive exempt status to isExempt emits ExemptAddressUpdate","title":"setExemptAddress"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#settimeweight","text":"function setTimeWeight( uint32 weight, uint32 growth, bool active ) external; set the current time weight to weight , growing at a rate growth and active flag to active starting from the current block. emits TimeWeightUpdate and GrowthRateUpdate if the growth rate changes","title":"setTimeWeight"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#fei-only","text":"","title":"Fei-Only\ud83c\udf32"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#incentivize","text":"function incentivize( address sender, address receiver, address operator, uint256 amountIn ) external updates the oracle at the beginning of the flow applies the buy reward based on amountIn if: below peg time weight non-zero contract is a Minter\ud83d\udcb0 sender is the ETH/FEI incentivized pair receiver is not exempt applies the sell penalty based on amountIn if: trade ends below peg contract is a Burner\ud83d\udd25 receiver is the ETH/FEI incentivized pair sender is not exempt","title":"incentivize"},{"location":"old/protocol/fei-stablecoin/uniswapincentive/#abis","text":"{% file src=\"../../.gitbook/assets/uniswapincentive.json\" caption=\"UniswapIncentive ABI\" %} {% file src=\"../../.gitbook/assets/iuniswapincentive.json\" caption=\"UniswapIncentive Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/genesis/","text":"Genesis Fei Protocol Genesis starts at 12:01 pm PT on March 31, 2021. It will last 3 days, ending April 3, 2021. Additional details about the Genesis event are available in our Medium announcement. Genesis Group The Genesis Group contract is the user entry point for Genesis participation. It provides users the ability to: Enter Genesis with an ETH commitment Optionally pre-swap TRIBE with Genesis FEI Launch Fei Protocol Redeem rewards after launch Emergency exit if the launch fails {% hint style=\"warning\" %} Genesis entry is one-way. There is no way to redeem committed ETH, unless the launch fails. Optional pre-swapping of TRIBE is one-way. There is no way to revert back to uncommitted Genesis ETH. {% endhint %} {% page-ref page=\"genesisgroup.md\" %} Initial DEX Offering (IDO) As part of the Genesis launch, Fei Protocol will supply liquidity for FEI and TRIBE on Uniswap. This will amount to 20% of the TRIBE initial token distribution . The corresponding FEI will be minted by the protocol equal to 20% of the FEI generated by Genesis. This sets the total TRIBE value equal to the value of FEI at Genesis. The liquidity for this IDO will be timelocked and owned by the Fei Core Team. {% page-ref page=\"ido.md\" %} {% page-ref page=\"../references/lineartokentimelock.md\" %} Fei Core Team Timelocks The Fei Core Team and early-backers will own timelocked TRIBE as well as the LP tokens associated with the IDO. These timelocks follow a linear release schedule over a 4 year window on the contract level. The Fei Core Team has elected a back-weighted 5 year timelock period. All tokens follow the 4 year timelock on the contract level. The difference for the team will be managed at the company level. The TRIBE will be held in a special timelock called the TimelockedDelegator which allows for sub-delegation of portions of the held tokens, even while timelocked. If you'd like to be considered as a sponsored delegate, reach out on Discord. {% page-ref page=\"timelockeddelegator.md\" %} {% page-ref page=\"../references/lineartokentimelock.md\" %}","title":"Genesis"},{"location":"old/protocol/genesis/#genesis","text":"Fei Protocol Genesis starts at 12:01 pm PT on March 31, 2021. It will last 3 days, ending April 3, 2021. Additional details about the Genesis event are available in our Medium announcement.","title":"Genesis"},{"location":"old/protocol/genesis/#genesis-group","text":"The Genesis Group contract is the user entry point for Genesis participation. It provides users the ability to: Enter Genesis with an ETH commitment Optionally pre-swap TRIBE with Genesis FEI Launch Fei Protocol Redeem rewards after launch Emergency exit if the launch fails {% hint style=\"warning\" %} Genesis entry is one-way. There is no way to redeem committed ETH, unless the launch fails. Optional pre-swapping of TRIBE is one-way. There is no way to revert back to uncommitted Genesis ETH. {% endhint %} {% page-ref page=\"genesisgroup.md\" %}","title":"Genesis Group"},{"location":"old/protocol/genesis/#initial-dex-offering-ido","text":"As part of the Genesis launch, Fei Protocol will supply liquidity for FEI and TRIBE on Uniswap. This will amount to 20% of the TRIBE initial token distribution . The corresponding FEI will be minted by the protocol equal to 20% of the FEI generated by Genesis. This sets the total TRIBE value equal to the value of FEI at Genesis. The liquidity for this IDO will be timelocked and owned by the Fei Core Team. {% page-ref page=\"ido.md\" %} {% page-ref page=\"../references/lineartokentimelock.md\" %}","title":"Initial DEX Offering (IDO)"},{"location":"old/protocol/genesis/#fei-core-team-timelocks","text":"The Fei Core Team and early-backers will own timelocked TRIBE as well as the LP tokens associated with the IDO. These timelocks follow a linear release schedule over a 4 year window on the contract level. The Fei Core Team has elected a back-weighted 5 year timelock period. All tokens follow the 4 year timelock on the contract level. The difference for the team will be managed at the company level. The TRIBE will be held in a special timelock called the TimelockedDelegator which allows for sub-delegation of portions of the held tokens, even while timelocked. If you'd like to be considered as a sponsored delegate, reach out on Discord. {% page-ref page=\"timelockeddelegator.md\" %} {% page-ref page=\"../references/lineartokentimelock.md\" %}","title":"Fei Core Team Timelocks"},{"location":"old/protocol/genesis/genesisgroup/","text":"GenesisGroup Contract GenesisGroup.sol implements IGenesisGroup , CoreRef , ERC20 , Timed Description The Genesis Group Contract is responsible for launching Fei Protocol. It allows for pro-rata access to the first bonding curve transaction and includes a TRIBE distribution. FGEN The user's Genesis balances are managed by an FGEN ERC-20 token. FGEN are a tokenized version of the committed ETH. FGEN tokens are fungible and can be transferred and even sold if secondary markets arise. FGEN are used to account for the user's final outcome in Genesis. Outcome determination {% hint style=\"info\" %} FGEN maps to \"committed ETH\" and converted-FGEN maps to \"pre-swapping\" TRIBE. {% endhint %} At redemption time, users could have a combination of FGEN and converted-FGEN (cFGEN) tokens. cFGEN are not ERC-20 tokens and are only utilized during Genesis. The ratios of FGEN and cFGEN to the totals determine how much FEI and TRIBE each user receives. The TRIBE can be further split into \"Genesis TRIBE\" which are the additional allocation to the Genesis Group and \"IDO TRIBE\" which come from exchanging pre-converted FEI in the IDO. Genesis allocation formulas: Both the held FGEN and pre-converted balance are used to determine ownership of the Genesis TRIBE. Only the held FGEN is used for determining FEI ownership because the pre-converted FGEN FEI allocation is used to swap for TRIBE. Of the IDO TRIBE allocation, users get the pro-rata percentage of their pre-converted FGEN over all of the pre-converted FGEN. Events {% tabs %} {% tab title=\"Purchase\" %} A purchase into the Genesis Group type param description address indexed _to the address to send Fei Genesis share tokens (FGEN) to uint256 _value the amount of ETH deposited {% endtab %} {% tab title=\"Commit\" %} Pre-commit Genesis share tokens (FGEN) to buy TRIBE in IDO type param description address indexed _from account with the FGEN to commit address indexed _to account to receive and redeem the rewards post-genesis uint256 _amount amount of FGEN committed {% endtab %} {% tab title=\"Redeem\" %} Redeem Fei Genesis share tokens (FGEN) for FEI and TRIBE type param description address indexed _to the address to send TRIBE and FEI to uint256 _amountIn amount of FGEN redeemed uint256 _amountFei amount of FEI received uint256 _amountTribe amount of TRIBE received {% endtab %} {% tab title=\"Launch\" %} The completion of the Genesis Group and launch of Fei Protocol. Only emitted once type param description uint256 _timestamp the block timestamp of deployment {% endtab %} {% endtabs %} Read-Only Functions getAmountOut function getAmountOut(uint256 amountIn, bool inclusive) external view returns (uint256 feiAmount, uint256 tribeAmount); Returns the hypothetical feiAmount of FEI and tribeAmount of TRIBE that the user would receive if they have amountIn FGEN and genesis were to launch immediately. The inclusive flag would signify that the amounIn is already a part of the existing FGEN total supply, otherwise it is added on to simulate a purchase. getAmountsToRedeem function getAmountsToRedeem(address to) external view returns ( uint256 feiAmount, uint256 genesisTribe, uint256 idoTribe ) For an address to , returns how much FEI is available for redemption feiAmount , how much TRIBE is available from the Genesis bonus genesisTribe , and how much TRIBE is available from the IDO pre-commitment idoTribe , if any. {% hint style=\"danger\" %} Reverts if called pre-launch, as there is no way to know the redeemable amount for a user {% endhint %} Public State-Changing Functions purchase function purchase(address to, uint256 value) external payable; Purchase awards the user with an ERC-20 token 1:1 for their ETH called FGEN. This amount equals to value . Only available during the Genesis Period. emits Purchase {% hint style=\"info\" %} purchase() maps to an \"ETH commitment\" which outputs FGEN. {% endhint %} commit function commit( address from, address to, uint256 amount ) external; Pre-commit amount of FGEN to have the associated Genesis FEI participate in the initial DEX offering of TRIBE on Uniswap. Burn FGEN from the from address and grant the pre-commitment rewards to the to address. This can only be done during the Genesis Period. emits Commit {% hint style=\"info\" %} commit () maps conceptually to a \"TRIBE pre-swap\" {% endhint %} {% hint style=\"warning\" %} When a user pre-converts, their FGEN is burned. This makes it a one-way action. {% endhint %} redeem function redeem(address to) external; Redeem FGEN and cFGEN from to for a pro rata share of the FEI purchased on the bonding curve and the Genesis TRIBE allocation. Any contract can redeem on behalf of a user if they have FGEN approval. Redemptions must be for the entire held balance of FGEN and cFGEN. emits Redeem emergencyExit function emergencyExit(address from, address payable to) external; Redeem all FGEN and cFGEN held by the address from for ETH 1:1, sending the ETH to address to . This is intended only for the scenario where the launch functionality is bricked as a way for users to get their ETH back. Only available 3 days AFTER the Genesis Period ends, if launch has not been called. EOA-Only \ud83d\udc64 State-Changing Functions launch function launch() external; Launching is only open at the end of the Genesis Period. The following actions happen at launch: Mark Genesis Group as completed in Core (for other contracts to reference) Initializing the BondingCurveOracle price for thawing Making the first bonding curve purchase of FEI with all held ETH. (needs to happen after oracle init so the FEI is deployed at right ratio on Uniswap) Allocate bonding curve ETH to the PCV deposit Initialize the FEI/TRIBE staking pool Deploy the IDO FEI/TRIBE funds to Uniswap. Execute the swap of FEI for pre-swappingTRIBE on the IDO emits Launch ABIs {% file src=\"../../.gitbook/assets/genesisgroup.json\" caption=\"GenesisGroup ABI\" %} {% file src=\"../../.gitbook/assets/igenesisgroup.json\" caption=\"GenesisGroup Interface ABI\" %}","title":"GenesisGroup"},{"location":"old/protocol/genesis/genesisgroup/#genesisgroup","text":"","title":"GenesisGroup"},{"location":"old/protocol/genesis/genesisgroup/#contract","text":"GenesisGroup.sol implements IGenesisGroup , CoreRef , ERC20 , Timed","title":"Contract"},{"location":"old/protocol/genesis/genesisgroup/#description","text":"The Genesis Group Contract is responsible for launching Fei Protocol. It allows for pro-rata access to the first bonding curve transaction and includes a TRIBE distribution.","title":"Description"},{"location":"old/protocol/genesis/genesisgroup/#fgen","text":"The user's Genesis balances are managed by an FGEN ERC-20 token. FGEN are a tokenized version of the committed ETH. FGEN tokens are fungible and can be transferred and even sold if secondary markets arise. FGEN are used to account for the user's final outcome in Genesis.","title":"FGEN"},{"location":"old/protocol/genesis/genesisgroup/#outcome-determination","text":"{% hint style=\"info\" %} FGEN maps to \"committed ETH\" and converted-FGEN maps to \"pre-swapping\" TRIBE. {% endhint %} At redemption time, users could have a combination of FGEN and converted-FGEN (cFGEN) tokens. cFGEN are not ERC-20 tokens and are only utilized during Genesis. The ratios of FGEN and cFGEN to the totals determine how much FEI and TRIBE each user receives. The TRIBE can be further split into \"Genesis TRIBE\" which are the additional allocation to the Genesis Group and \"IDO TRIBE\" which come from exchanging pre-converted FEI in the IDO. Genesis allocation formulas: Both the held FGEN and pre-converted balance are used to determine ownership of the Genesis TRIBE. Only the held FGEN is used for determining FEI ownership because the pre-converted FGEN FEI allocation is used to swap for TRIBE. Of the IDO TRIBE allocation, users get the pro-rata percentage of their pre-converted FGEN over all of the pre-converted FGEN.","title":"Outcome determination"},{"location":"old/protocol/genesis/genesisgroup/#events","text":"{% tabs %} {% tab title=\"Purchase\" %} A purchase into the Genesis Group type param description address indexed _to the address to send Fei Genesis share tokens (FGEN) to uint256 _value the amount of ETH deposited {% endtab %} {% tab title=\"Commit\" %} Pre-commit Genesis share tokens (FGEN) to buy TRIBE in IDO type param description address indexed _from account with the FGEN to commit address indexed _to account to receive and redeem the rewards post-genesis uint256 _amount amount of FGEN committed {% endtab %} {% tab title=\"Redeem\" %} Redeem Fei Genesis share tokens (FGEN) for FEI and TRIBE type param description address indexed _to the address to send TRIBE and FEI to uint256 _amountIn amount of FGEN redeemed uint256 _amountFei amount of FEI received uint256 _amountTribe amount of TRIBE received {% endtab %} {% tab title=\"Launch\" %} The completion of the Genesis Group and launch of Fei Protocol. Only emitted once type param description uint256 _timestamp the block timestamp of deployment {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/genesis/genesisgroup/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/genesis/genesisgroup/#getamountout","text":"function getAmountOut(uint256 amountIn, bool inclusive) external view returns (uint256 feiAmount, uint256 tribeAmount); Returns the hypothetical feiAmount of FEI and tribeAmount of TRIBE that the user would receive if they have amountIn FGEN and genesis were to launch immediately. The inclusive flag would signify that the amounIn is already a part of the existing FGEN total supply, otherwise it is added on to simulate a purchase.","title":"getAmountOut"},{"location":"old/protocol/genesis/genesisgroup/#getamountstoredeem","text":"function getAmountsToRedeem(address to) external view returns ( uint256 feiAmount, uint256 genesisTribe, uint256 idoTribe ) For an address to , returns how much FEI is available for redemption feiAmount , how much TRIBE is available from the Genesis bonus genesisTribe , and how much TRIBE is available from the IDO pre-commitment idoTribe , if any. {% hint style=\"danger\" %} Reverts if called pre-launch, as there is no way to know the redeemable amount for a user {% endhint %}","title":"getAmountsToRedeem"},{"location":"old/protocol/genesis/genesisgroup/#public-state-changing-functions","text":"","title":"Public State-Changing Functions"},{"location":"old/protocol/genesis/genesisgroup/#purchase","text":"function purchase(address to, uint256 value) external payable; Purchase awards the user with an ERC-20 token 1:1 for their ETH called FGEN. This amount equals to value . Only available during the Genesis Period. emits Purchase {% hint style=\"info\" %} purchase() maps to an \"ETH commitment\" which outputs FGEN. {% endhint %}","title":"purchase"},{"location":"old/protocol/genesis/genesisgroup/#commit","text":"function commit( address from, address to, uint256 amount ) external; Pre-commit amount of FGEN to have the associated Genesis FEI participate in the initial DEX offering of TRIBE on Uniswap. Burn FGEN from the from address and grant the pre-commitment rewards to the to address. This can only be done during the Genesis Period. emits Commit {% hint style=\"info\" %} commit () maps conceptually to a \"TRIBE pre-swap\" {% endhint %} {% hint style=\"warning\" %} When a user pre-converts, their FGEN is burned. This makes it a one-way action. {% endhint %}","title":"commit"},{"location":"old/protocol/genesis/genesisgroup/#redeem","text":"function redeem(address to) external; Redeem FGEN and cFGEN from to for a pro rata share of the FEI purchased on the bonding curve and the Genesis TRIBE allocation. Any contract can redeem on behalf of a user if they have FGEN approval. Redemptions must be for the entire held balance of FGEN and cFGEN. emits Redeem","title":"redeem"},{"location":"old/protocol/genesis/genesisgroup/#emergencyexit","text":"function emergencyExit(address from, address payable to) external; Redeem all FGEN and cFGEN held by the address from for ETH 1:1, sending the ETH to address to . This is intended only for the scenario where the launch functionality is bricked as a way for users to get their ETH back. Only available 3 days AFTER the Genesis Period ends, if launch has not been called.","title":"emergencyExit"},{"location":"old/protocol/genesis/genesisgroup/#eoa-only-state-changing-functions","text":"","title":"EOA-Only \ud83d\udc64 State-Changing Functions"},{"location":"old/protocol/genesis/genesisgroup/#launch","text":"function launch() external; Launching is only open at the end of the Genesis Period. The following actions happen at launch: Mark Genesis Group as completed in Core (for other contracts to reference) Initializing the BondingCurveOracle price for thawing Making the first bonding curve purchase of FEI with all held ETH. (needs to happen after oracle init so the FEI is deployed at right ratio on Uniswap) Allocate bonding curve ETH to the PCV deposit Initialize the FEI/TRIBE staking pool Deploy the IDO FEI/TRIBE funds to Uniswap. Execute the swap of FEI for pre-swappingTRIBE on the IDO emits Launch","title":"launch"},{"location":"old/protocol/genesis/genesisgroup/#abis","text":"{% file src=\"../../.gitbook/assets/genesisgroup.json\" caption=\"GenesisGroup ABI\" %} {% file src=\"../../.gitbook/assets/igenesisgroup.json\" caption=\"GenesisGroup Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/genesis/ido/","text":"IDO Contract IDO.sol implements IDOInterface , UniRef , LinearTokenTimelock Description IDO is an Initial DeFi Offering contract for listing FEI and TRIBE at genesis launch. The IDO is deployed by the GenesisGroup contract. The GenesisGroup sets the initial exchange rate. The IDO should hold TRIBE tokens and mint the appropriate amount of FEI to match the given exchange rate. It will then send the TRIBE and FEI to Uniswap where it should be the only LP for the pair. The LP shares held by the contract timelock linearly to the Fei Core Team and early-backers over a 4 year window from contract creation. Normalization Because of slippage, when a Uniswap transaction occurs the next spot price is always higher than the price payed by the trader. For example, assume there are 100 FEI and 100 USDC in a pool. A trader sends 100 USDC to the pool to buy FEI and gets 50 FEI back. This is a 2:1 exchange rate. However now the reserves are 200 USDC and 50 FEI, implying a 4:1 spot exchange rate. An arbitrageur could estimate the true price is around 2:1 and back-run the trade to profit on the slippage. The IDO pre-swap will likely have a large amount of slippage and create a massive arbitrage opportunity. For this reason we will \"normalize\" the price to what the Genesis Group pays (2:1 in the above example). The IDO simply burns from the pool back to the rate payed and then \"syncs\" the pool using the low level Uniswap utility. Due to the symmetry in Uniswap trades, the burn amount is always equal to the amount of FEI swapped into the pool for TRIBE. Access Control Minter\ud83d\udcb0 Burner\ud83d\udd25 Events {% tabs %} {% tab title=\"Deploy\" %} The IDO initialization with FEI and TRIBE. Only emitted once type param description uint256 _amountFei the amount of FEI deployed in the IDO uint256 _amountTribe the amount of TRIBE deployed in the IDO {% endtab %} {% endtabs %} GenesisGroup-Only\ud83d\ude80 State-Changing Functions deploy function deploy(Decimal.D256 calldata feiRatio) external; Initializes the FEI/TRIBE Uniswap pool with liquidity based on the amount of TRIBE held by the contract and feiRatio times that amount worth of FEI. The FEI for this are minted by the IDO to itself. swapFei function swapFei(uint256 amountFei) external returns (uint256); Swaps amountFei worth of FEI from the GenesisGroup contract to the FEI/TRIBE Uniswap pool and back. The IDO must be approved for the FEI transfer. Includes the \"normalization\" burn after the trade executes. Governor-Only\u2696\ufe0f State-Changing Functions unlockLiquidity function unlockLiquidity() external; Unlocks all of the time-locked liquidity and early vests to the beneficiary. This function is intended to be used when upgrading the primary AMM for FEI-TRIBE liquidity by setting the beneficiary to a pre-set upgrade co ABIs {% file src=\"../../.gitbook/assets/ido (1).json\" caption=\"IDO ABI\" %} {% file src=\"../../.gitbook/assets/idointerface (1).json\" caption=\"IDO Interface ABI\" %}","title":"IDO"},{"location":"old/protocol/genesis/ido/#ido","text":"","title":"IDO"},{"location":"old/protocol/genesis/ido/#contract","text":"IDO.sol implements IDOInterface , UniRef , LinearTokenTimelock","title":"Contract"},{"location":"old/protocol/genesis/ido/#description","text":"IDO is an Initial DeFi Offering contract for listing FEI and TRIBE at genesis launch. The IDO is deployed by the GenesisGroup contract. The GenesisGroup sets the initial exchange rate. The IDO should hold TRIBE tokens and mint the appropriate amount of FEI to match the given exchange rate. It will then send the TRIBE and FEI to Uniswap where it should be the only LP for the pair. The LP shares held by the contract timelock linearly to the Fei Core Team and early-backers over a 4 year window from contract creation.","title":"Description"},{"location":"old/protocol/genesis/ido/#normalization","text":"Because of slippage, when a Uniswap transaction occurs the next spot price is always higher than the price payed by the trader. For example, assume there are 100 FEI and 100 USDC in a pool. A trader sends 100 USDC to the pool to buy FEI and gets 50 FEI back. This is a 2:1 exchange rate. However now the reserves are 200 USDC and 50 FEI, implying a 4:1 spot exchange rate. An arbitrageur could estimate the true price is around 2:1 and back-run the trade to profit on the slippage. The IDO pre-swap will likely have a large amount of slippage and create a massive arbitrage opportunity. For this reason we will \"normalize\" the price to what the Genesis Group pays (2:1 in the above example). The IDO simply burns from the pool back to the rate payed and then \"syncs\" the pool using the low level Uniswap utility. Due to the symmetry in Uniswap trades, the burn amount is always equal to the amount of FEI swapped into the pool for TRIBE.","title":"Normalization"},{"location":"old/protocol/genesis/ido/#access-control","text":"Minter\ud83d\udcb0 Burner\ud83d\udd25","title":"Access Control"},{"location":"old/protocol/genesis/ido/#events","text":"{% tabs %} {% tab title=\"Deploy\" %} The IDO initialization with FEI and TRIBE. Only emitted once type param description uint256 _amountFei the amount of FEI deployed in the IDO uint256 _amountTribe the amount of TRIBE deployed in the IDO {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/genesis/ido/#genesisgroup-only-state-changing-functions","text":"","title":"GenesisGroup-Only\ud83d\ude80 State-Changing Functions"},{"location":"old/protocol/genesis/ido/#deploy","text":"function deploy(Decimal.D256 calldata feiRatio) external; Initializes the FEI/TRIBE Uniswap pool with liquidity based on the amount of TRIBE held by the contract and feiRatio times that amount worth of FEI. The FEI for this are minted by the IDO to itself.","title":"deploy"},{"location":"old/protocol/genesis/ido/#swapfei","text":"function swapFei(uint256 amountFei) external returns (uint256); Swaps amountFei worth of FEI from the GenesisGroup contract to the FEI/TRIBE Uniswap pool and back. The IDO must be approved for the FEI transfer. Includes the \"normalization\" burn after the trade executes.","title":"swapFei"},{"location":"old/protocol/genesis/ido/#governor-only-state-changing-functions","text":"","title":"Governor-Only\u2696\ufe0f State-Changing Functions"},{"location":"old/protocol/genesis/ido/#unlockliquidity","text":"function unlockLiquidity() external; Unlocks all of the time-locked liquidity and early vests to the beneficiary. This function is intended to be used when upgrading the primary AMM for FEI-TRIBE liquidity by setting the beneficiary to a pre-set upgrade co","title":"unlockLiquidity"},{"location":"old/protocol/genesis/ido/#abis","text":"{% file src=\"../../.gitbook/assets/ido (1).json\" caption=\"IDO ABI\" %} {% file src=\"../../.gitbook/assets/idointerface (1).json\" caption=\"IDO Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/genesis/timelockeddelegator/","text":"TimelockedDelegator Contract TimelockedDelegator.sol implements ITimelockedDelegator , LinearTokenTimelock Description A TRIBE token timelock which allows subdelegation. Managed by the Fei Core Team to distribute vested TRIBE and voting rights to team members and investors. The contract receives TRIBE tokens that vest linearly over a 4 year schedule to a beneficiary. {% page-ref page=\"../references/lineartokentimelock.md\" %} Sub-Delegation During the elected timelock period, any TRIBE in the timelock can be sub-delegated to any address. The TimelockedDelegator creates a proxy delegate contract which escrows the TRIBE and sub-delegates. It can then withdraw voting rights at any time. The beneficiary decides where to delegate and undelegate. All TRIBE held in the timelock that is not sub-delegated is delegated to the beneficiary. Events {% tabs %} {% tab title=\"Delegate\" %} delegate TRIBE tokens from timelock type param description address indexed _delegatee delegatee to recieve the TRIBE votes uint256 _amount amount of TRIBE delegated {% endtab %} {% tab title=\"Undelegate\" %} Remove TRIBE votes from delegatee type param description address indexed _delegatee delegatee to remove TRIBE votes uint256 _amount amount of TRIBE undelegated {% endtab %} {% endtabs %} Read-Only Functions delegateContract function delegateContract(address delegatee) external view returns (address); Returns the contract address escrowing and delegating the TRIBE for delegatee . delegateAmount function delegateAmount(address delegatee) external view returns (uint256); Returns the amount of TRIBE delegated in the escrow contract for delegatee totalDelegated function totalDelegated() external view returns (uint256); Returns the total amount of TRIBE delegated in proxy contracts, excluding the TRIBE held natively in the TimelockedDelegator. tribe function tribe() external view returns (ITribe); A reference to the TRIBE contract. State-Changing Functions Beneficiary-Only\ud83d\udc51 delegate function delegate(address delegatee, uint256 amount) external; Delegates amount of TRIBE from the TimelockedDelegator to delegatee by creating a proxy and transferring TRIBE to it. If delegatee already has delegation, the TimelockedDelegator undelegates it and increments amount before sending to the proxy. emits Delegate and Undelegate if the delegatee already has some delegated undelegate function undelegate(address delegatee) external returns (uint256); Withdraws all TRIBE from the delegate proxy contract associated with delegatee and returns the amount received. emits Undelegate ABIs {% file src=\"../../.gitbook/assets/timelockeddelegator.json\" caption=\"TimelockedDelegator ABI\" %} {% file src=\"../../.gitbook/assets/itimelockeddelegator.json\" caption=\"TimelockedDelegator Interface ABI\" %}","title":"TimelockedDelegator"},{"location":"old/protocol/genesis/timelockeddelegator/#timelockeddelegator","text":"","title":"TimelockedDelegator"},{"location":"old/protocol/genesis/timelockeddelegator/#contract","text":"TimelockedDelegator.sol implements ITimelockedDelegator , LinearTokenTimelock","title":"Contract"},{"location":"old/protocol/genesis/timelockeddelegator/#description","text":"A TRIBE token timelock which allows subdelegation. Managed by the Fei Core Team to distribute vested TRIBE and voting rights to team members and investors. The contract receives TRIBE tokens that vest linearly over a 4 year schedule to a beneficiary. {% page-ref page=\"../references/lineartokentimelock.md\" %}","title":"Description"},{"location":"old/protocol/genesis/timelockeddelegator/#sub-delegation","text":"During the elected timelock period, any TRIBE in the timelock can be sub-delegated to any address. The TimelockedDelegator creates a proxy delegate contract which escrows the TRIBE and sub-delegates. It can then withdraw voting rights at any time. The beneficiary decides where to delegate and undelegate. All TRIBE held in the timelock that is not sub-delegated is delegated to the beneficiary.","title":"Sub-Delegation"},{"location":"old/protocol/genesis/timelockeddelegator/#events","text":"{% tabs %} {% tab title=\"Delegate\" %} delegate TRIBE tokens from timelock type param description address indexed _delegatee delegatee to recieve the TRIBE votes uint256 _amount amount of TRIBE delegated {% endtab %} {% tab title=\"Undelegate\" %} Remove TRIBE votes from delegatee type param description address indexed _delegatee delegatee to remove TRIBE votes uint256 _amount amount of TRIBE undelegated {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/genesis/timelockeddelegator/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/genesis/timelockeddelegator/#delegatecontract","text":"function delegateContract(address delegatee) external view returns (address); Returns the contract address escrowing and delegating the TRIBE for delegatee .","title":"delegateContract"},{"location":"old/protocol/genesis/timelockeddelegator/#delegateamount","text":"function delegateAmount(address delegatee) external view returns (uint256); Returns the amount of TRIBE delegated in the escrow contract for delegatee","title":"delegateAmount"},{"location":"old/protocol/genesis/timelockeddelegator/#totaldelegated","text":"function totalDelegated() external view returns (uint256); Returns the total amount of TRIBE delegated in proxy contracts, excluding the TRIBE held natively in the TimelockedDelegator.","title":"totalDelegated"},{"location":"old/protocol/genesis/timelockeddelegator/#tribe","text":"function tribe() external view returns (ITribe); A reference to the TRIBE contract.","title":"tribe"},{"location":"old/protocol/genesis/timelockeddelegator/#state-changing-functions","text":"","title":"State-Changing Functions "},{"location":"old/protocol/genesis/timelockeddelegator/#beneficiary-only","text":"","title":"Beneficiary-Only\ud83d\udc51"},{"location":"old/protocol/genesis/timelockeddelegator/#delegate","text":"function delegate(address delegatee, uint256 amount) external; Delegates amount of TRIBE from the TimelockedDelegator to delegatee by creating a proxy and transferring TRIBE to it. If delegatee already has delegation, the TimelockedDelegator undelegates it and increments amount before sending to the proxy. emits Delegate and Undelegate if the delegatee already has some delegated","title":"delegate"},{"location":"old/protocol/genesis/timelockeddelegator/#undelegate","text":"function undelegate(address delegatee) external returns (uint256); Withdraws all TRIBE from the delegate proxy contract associated with delegatee and returns the amount received. emits Undelegate","title":"undelegate"},{"location":"old/protocol/genesis/timelockeddelegator/#abis","text":"{% file src=\"../../.gitbook/assets/timelockeddelegator.json\" caption=\"TimelockedDelegator ABI\" %} {% file src=\"../../.gitbook/assets/itimelockeddelegator.json\" caption=\"TimelockedDelegator Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/oracles/","text":"Oracles Fei Protocol has two distinct oracles that different components in the system point to. The primary oracle reads the USDC/ETH 10 minute time-weighted average price (TWAP). This oracle uses a snapshot approach, so for each 10-minute interval the peg is fixed from the Fei Protocol perspective. The only contract in Fei Protocol that uses this primary oracle is the bonding curve . {% embed url=\"https://uniswap.org/docs/v2/core-concepts/oracles/\" caption=\"Uniswap Oracles\" %} All other components in the system use the secondary oracle, \"bonding curve oracle\". Pre-Scale, this oracle references the bonding curve price rather than the primary oracle price. E.g., if the bonding curve is at a multiplier of $0.75, then the direct peg incentives on uniswap are targeting the distance from a $0.75 FEI price rather than the long-term intended $1. Thawing An important feature of the bonding curve oracle is the ability to \"thaw\" from a lower target price up to the target bonding curve price. Thawing is used to mitigate arbitrage opportunities that arise due to Genesis participation. This type of arbitrage is a general feature of any system which has the following properties: A group of user transactions are bundled together There is open participation in the group There is slippage in the price The inverse transaction can be made immediately after the bundled transaction An arbitrageur could participate in the grouped transaction. The average price of the group transaction would necessarily be lower than the very next listing price. The arbitrageur, if first to sell, would capitalize on the spread between these two prices. E.g., a naive approach to the FEI bonding curve: The Genesis Group makes it to the Scale target with an average price of $0.80. If Fei Protocol immediately lists FEI at the current bonding curve price of $1.00, then an arbitrageur can participate in Genesis expecting to make a 20% profit, if able to sell first right after Genesis. The implemented thawing solution is to initiate the bonding curve oracle reporting the average Genesis price as opposed to the next bonding curve price. This mitigates any pure arbitrage opportunities for participating in Genesis. The bonding curve will linearly shift towards reporting the intended bonding curve peg price over a 2 week window. This means that all incentives and PCV deposits will apply to this lower price. The peg will gradually increase until the thawing period is over.","title":"Oracles"},{"location":"old/protocol/oracles/#oracles","text":"Fei Protocol has two distinct oracles that different components in the system point to. The primary oracle reads the USDC/ETH 10 minute time-weighted average price (TWAP). This oracle uses a snapshot approach, so for each 10-minute interval the peg is fixed from the Fei Protocol perspective. The only contract in Fei Protocol that uses this primary oracle is the bonding curve . {% embed url=\"https://uniswap.org/docs/v2/core-concepts/oracles/\" caption=\"Uniswap Oracles\" %} All other components in the system use the secondary oracle, \"bonding curve oracle\". Pre-Scale, this oracle references the bonding curve price rather than the primary oracle price. E.g., if the bonding curve is at a multiplier of $0.75, then the direct peg incentives on uniswap are targeting the distance from a $0.75 FEI price rather than the long-term intended $1.","title":"Oracles"},{"location":"old/protocol/oracles/#thawing","text":"An important feature of the bonding curve oracle is the ability to \"thaw\" from a lower target price up to the target bonding curve price. Thawing is used to mitigate arbitrage opportunities that arise due to Genesis participation. This type of arbitrage is a general feature of any system which has the following properties: A group of user transactions are bundled together There is open participation in the group There is slippage in the price The inverse transaction can be made immediately after the bundled transaction An arbitrageur could participate in the grouped transaction. The average price of the group transaction would necessarily be lower than the very next listing price. The arbitrageur, if first to sell, would capitalize on the spread between these two prices. E.g., a naive approach to the FEI bonding curve: The Genesis Group makes it to the Scale target with an average price of $0.80. If Fei Protocol immediately lists FEI at the current bonding curve price of $1.00, then an arbitrageur can participate in Genesis expecting to make a 20% profit, if able to sell first right after Genesis. The implemented thawing solution is to initiate the bonding curve oracle reporting the average Genesis price as opposed to the next bonding curve price. This mitigates any pure arbitrage opportunities for participating in Genesis. The bonding curve will linearly shift towards reporting the intended bonding curve peg price over a 2 week window. This means that all incentives and PCV deposits will apply to this lower price. The peg will gradually increase until the thawing period is over.","title":"Thawing"},{"location":"old/protocol/oracles/bondingcurveoracle/","text":"BondingCurveOracle Contract BondingCurveOracle.sol implements IBondingCurveOracle , CoreRef , Timed Description The BondingCurveOracle contract pegs to a linked bonding curve price pre Scale and to a normal UniswapOracle post Scale. The contract stores the bonding curve (pre-Scale) and Uniswap (post-scale) oracle contracts to reference. Updates to the bonding curve oracle update the linked uniswap oracle. Thawing Additionally, the contract includes the \"thawing\" process. Thawing implements the initial pegged price lower than the target uniswap/bonding curve price. The reported peg linearly converges on the target peg over a preset duration window. The duration window d is 2 weeks. At the beginning of the window it reports the peg at the initial price I and at the end it will report the peg at the target price T . Let t be the timestamp between [0,d]. The reported oracle price O during the thawing period is: Events {% tabs %} {% tab title=\"Update\" %} new reported peg type param description uint256 _peg new peg value {% endtab %} {% endtabs %} Read-Only Functions read function read() external view returns (Decimal.D256 memory, bool); Reads the oracle value and reports the peg as FEI per underlying. The boolean value returned informs whether the reported oracle value is valid. Invalid value means the oracle is uninitialized or the contract is paused. {% hint style=\"info\" %} This method is pausable . If paused, it won't revert but it will return valid as false {% endhint %} isOutdated function isOutdated() external view returns (bool); Pass through calls uniswapOracle.isOutdated() , if false, then multiple read functions relying on the oracle would be inaccurate. uniswapOracle function uniswapOracle() external returns (IOracle); The referenced Uniswap Oracle bondingCurve function bondingCurve() external returns (IBondingCurve); The referenced Bonding Curve initialUSDPrice function initialUSDPrice() external returns (Decimal.D256 memory); The initial price to thaw from during the thawing period reported as USD per FEI. {% hint style=\"info\" %} This is capped at $1 even if the genesis group pays more than $1 due to the buffer {% endhint %} Public State-Changing Functions update function update() external returns (bool); Pass-through updates uniswapOracle GenesisGroup-Only\ud83d\ude80 State-Changing Functions init function init(Decimal.D256 calldata initialPrice) external; called by the GenesisGroup with the initial price to thaw from ABIs {% file src=\"../../.gitbook/assets/bondingcurveoracle.json\" caption=\"BondingCurveOracle ABI\" %} {% file src=\"../../.gitbook/assets/ibondingcurveoracle.json\" caption=\"BondingCurveOracle Interface ABI\" %} {% file src=\"../../.gitbook/assets/ioracle.json\" caption=\"Oracle Interface ABI\" %}","title":"BondingCurveOracle"},{"location":"old/protocol/oracles/bondingcurveoracle/#bondingcurveoracle","text":"","title":"BondingCurveOracle"},{"location":"old/protocol/oracles/bondingcurveoracle/#contract","text":"BondingCurveOracle.sol implements IBondingCurveOracle , CoreRef , Timed","title":"Contract"},{"location":"old/protocol/oracles/bondingcurveoracle/#description","text":"The BondingCurveOracle contract pegs to a linked bonding curve price pre Scale and to a normal UniswapOracle post Scale. The contract stores the bonding curve (pre-Scale) and Uniswap (post-scale) oracle contracts to reference. Updates to the bonding curve oracle update the linked uniswap oracle.","title":"Description"},{"location":"old/protocol/oracles/bondingcurveoracle/#thawing","text":"Additionally, the contract includes the \"thawing\" process. Thawing implements the initial pegged price lower than the target uniswap/bonding curve price. The reported peg linearly converges on the target peg over a preset duration window. The duration window d is 2 weeks. At the beginning of the window it reports the peg at the initial price I and at the end it will report the peg at the target price T . Let t be the timestamp between [0,d]. The reported oracle price O during the thawing period is:","title":"Thawing"},{"location":"old/protocol/oracles/bondingcurveoracle/#events","text":"{% tabs %} {% tab title=\"Update\" %} new reported peg type param description uint256 _peg new peg value {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/oracles/bondingcurveoracle/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/oracles/bondingcurveoracle/#read","text":"function read() external view returns (Decimal.D256 memory, bool); Reads the oracle value and reports the peg as FEI per underlying. The boolean value returned informs whether the reported oracle value is valid. Invalid value means the oracle is uninitialized or the contract is paused. {% hint style=\"info\" %} This method is pausable . If paused, it won't revert but it will return valid as false {% endhint %}","title":"read"},{"location":"old/protocol/oracles/bondingcurveoracle/#isoutdated","text":"function isOutdated() external view returns (bool); Pass through calls uniswapOracle.isOutdated() , if false, then multiple read functions relying on the oracle would be inaccurate.","title":"isOutdated"},{"location":"old/protocol/oracles/bondingcurveoracle/#uniswaporacle","text":"function uniswapOracle() external returns (IOracle); The referenced Uniswap Oracle","title":"uniswapOracle"},{"location":"old/protocol/oracles/bondingcurveoracle/#bondingcurve","text":"function bondingCurve() external returns (IBondingCurve); The referenced Bonding Curve","title":"bondingCurve"},{"location":"old/protocol/oracles/bondingcurveoracle/#initialusdprice","text":"function initialUSDPrice() external returns (Decimal.D256 memory); The initial price to thaw from during the thawing period reported as USD per FEI. {% hint style=\"info\" %} This is capped at $1 even if the genesis group pays more than $1 due to the buffer {% endhint %}","title":"initialUSDPrice"},{"location":"old/protocol/oracles/bondingcurveoracle/#public-state-changing-functions","text":"","title":"Public State-Changing Functions"},{"location":"old/protocol/oracles/bondingcurveoracle/#update","text":"function update() external returns (bool); Pass-through updates uniswapOracle","title":"update"},{"location":"old/protocol/oracles/bondingcurveoracle/#genesisgroup-only-state-changing-functions","text":"","title":"GenesisGroup-Only\ud83d\ude80 State-Changing Functions"},{"location":"old/protocol/oracles/bondingcurveoracle/#init","text":"function init(Decimal.D256 calldata initialPrice) external; called by the GenesisGroup with the initial price to thaw from","title":"init"},{"location":"old/protocol/oracles/bondingcurveoracle/#abis","text":"{% file src=\"../../.gitbook/assets/bondingcurveoracle.json\" caption=\"BondingCurveOracle ABI\" %} {% file src=\"../../.gitbook/assets/ibondingcurveoracle.json\" caption=\"BondingCurveOracle Interface ABI\" %} {% file src=\"../../.gitbook/assets/ioracle.json\" caption=\"Oracle Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/oracles/uniswaporacle/","text":"UniswapOracle Contract UniswapOracle.sol implements IUniswapOracle , CoreRef Description The UniswapOracle contract maintains a uniswap TWAP. It maintains a pair contract to reference and a flag for whether the target price is token0 or token1 of the pair. Has a timestamp duration that must be exceeded between oracle updates. The duration is set to 10 minutes at launch. Updates should: take the difference between the current and prior timestamp and make sure it exceeds the duration get the cumulative price difference between Eth and USDC and normalize by 10**12 (the decimal difference between them) divide the ratio between the cumulative price and timestamp to get a peg price, then divide by 2^112 to resolve an integer from the stored fixed point 112x112 that Uniswap uses. update the peg and prior cumulative and timestamp The Governor \u2696\ufe0fcan change the duration. Events {% tabs %} {% tab title=\"Update\" %} new reported peg type param description uint256 _peg new peg value {% endtab %} {% tab title=\"DurationUpdate\" %} New TWAP duration type param description uint256 _duration new value of the TWAP duration {% endtab %} {% endtabs %} Read-Only Functions read function read() external view returns (Decimal.D256 memory, bool); Reads the oracle value and reports the peg as FEI per underlying. The boolean value returned informs whether the reported value is valid. Invalid means the oracle is uninitialized or the contract is paused. {% hint style=\"info\" %} This method is pausable . If paused, it won't revert but it will return valid as false {% endhint %} isOutdated function isOutdated() external view returns (bool); Returns true, if the oracle is still within the duration window. If false, then most read functions relying on the oracle would be inaccurate. priorTimestamp function priorTimestamp() external returns (uint32); Returns the prior timestamp used in the time-weighted average price calculation from the Uniswap pair. priorCumulative function priorCumulative() external returns (uint256); Returns the prior cumulative price used in the time-weighted average price calculation from the Uniswap pair. duration function duration() external returns (uint256); Returns the duration of the time-weighted average price. pair function pair() external returns (IUniswapV2Pair); Returns the referenced Uniswap pair for the oracle. Public State-Changing Functions update function update() external returns (bool); Updates the oracle with new time-weighted average price data from Uniswap if the duration window has passed since the last update. Returns true if updated, and false otherwise. emits Update {% hint style=\"info\" %} This method is pausable {% endhint %} Governor-Only\u2696\ufe0f State-Changing Functions setDuration function setDuration(uint256 _duration) external; Changes the time-weighted average price to _duration second snapshots emits DurationUpdate ABIs {% file src=\"../../.gitbook/assets/uniswaporacle.json\" caption=\"Uniswap Oracle ABI\" %} {% file src=\"../../.gitbook/assets/iuniswaporacle.json\" caption=\"Uniswap Oracle Interface ABI\" %} {% file src=\"../../.gitbook/assets/ioracle.json\" caption=\"Oracle Interface ABI\" %}","title":"UniswapOracle"},{"location":"old/protocol/oracles/uniswaporacle/#uniswaporacle","text":"","title":"UniswapOracle"},{"location":"old/protocol/oracles/uniswaporacle/#contract","text":"UniswapOracle.sol implements IUniswapOracle , CoreRef","title":"Contract"},{"location":"old/protocol/oracles/uniswaporacle/#description","text":"The UniswapOracle contract maintains a uniswap TWAP. It maintains a pair contract to reference and a flag for whether the target price is token0 or token1 of the pair. Has a timestamp duration that must be exceeded between oracle updates. The duration is set to 10 minutes at launch. Updates should: take the difference between the current and prior timestamp and make sure it exceeds the duration get the cumulative price difference between Eth and USDC and normalize by 10**12 (the decimal difference between them) divide the ratio between the cumulative price and timestamp to get a peg price, then divide by 2^112 to resolve an integer from the stored fixed point 112x112 that Uniswap uses. update the peg and prior cumulative and timestamp The Governor \u2696\ufe0fcan change the duration.","title":"Description"},{"location":"old/protocol/oracles/uniswaporacle/#events","text":"{% tabs %} {% tab title=\"Update\" %} new reported peg type param description uint256 _peg new peg value {% endtab %} {% tab title=\"DurationUpdate\" %} New TWAP duration type param description uint256 _duration new value of the TWAP duration {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/oracles/uniswaporacle/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/oracles/uniswaporacle/#read","text":"function read() external view returns (Decimal.D256 memory, bool); Reads the oracle value and reports the peg as FEI per underlying. The boolean value returned informs whether the reported value is valid. Invalid means the oracle is uninitialized or the contract is paused. {% hint style=\"info\" %} This method is pausable . If paused, it won't revert but it will return valid as false {% endhint %}","title":"read"},{"location":"old/protocol/oracles/uniswaporacle/#isoutdated","text":"function isOutdated() external view returns (bool); Returns true, if the oracle is still within the duration window. If false, then most read functions relying on the oracle would be inaccurate.","title":"isOutdated"},{"location":"old/protocol/oracles/uniswaporacle/#priortimestamp","text":"function priorTimestamp() external returns (uint32); Returns the prior timestamp used in the time-weighted average price calculation from the Uniswap pair.","title":"priorTimestamp"},{"location":"old/protocol/oracles/uniswaporacle/#priorcumulative","text":"function priorCumulative() external returns (uint256); Returns the prior cumulative price used in the time-weighted average price calculation from the Uniswap pair.","title":"priorCumulative"},{"location":"old/protocol/oracles/uniswaporacle/#duration","text":"function duration() external returns (uint256); Returns the duration of the time-weighted average price.","title":"duration"},{"location":"old/protocol/oracles/uniswaporacle/#pair","text":"function pair() external returns (IUniswapV2Pair); Returns the referenced Uniswap pair for the oracle.","title":"pair"},{"location":"old/protocol/oracles/uniswaporacle/#public-state-changing-functions","text":"","title":"Public State-Changing Functions"},{"location":"old/protocol/oracles/uniswaporacle/#update","text":"function update() external returns (bool); Updates the oracle with new time-weighted average price data from Uniswap if the duration window has passed since the last update. Returns true if updated, and false otherwise. emits Update {% hint style=\"info\" %} This method is pausable {% endhint %}","title":"update"},{"location":"old/protocol/oracles/uniswaporacle/#governor-only-state-changing-functions","text":"","title":"Governor-Only\u2696\ufe0f State-Changing Functions"},{"location":"old/protocol/oracles/uniswaporacle/#setduration","text":"function setDuration(uint256 _duration) external; Changes the time-weighted average price to _duration second snapshots emits DurationUpdate","title":"setDuration"},{"location":"old/protocol/oracles/uniswaporacle/#abis","text":"{% file src=\"../../.gitbook/assets/uniswaporacle.json\" caption=\"Uniswap Oracle ABI\" %} {% file src=\"../../.gitbook/assets/iuniswaporacle.json\" caption=\"Uniswap Oracle Interface ABI\" %} {% file src=\"../../.gitbook/assets/ioracle.json\" caption=\"Oracle Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/protocol-controlled-value/","text":"Protocol Controlled Value Protocol Controlled Value ****(PCV) is a categorization of Total Value Locked (TVL) which represents all assets that are ultimately not redeemable by users. Commonly used examples of PCV are DAO treasuries and insurance funds. PCV can be conceptually extended to include any algorithmic management of the protocol-owned assets in order to facilitate protocol goals such as liquidity and stability. PCV Funding Generally, there are two ways for a protocol to fund PCV: Fees for functionality e.g., Compound and Aave insurance pools funded by a spread on borrowing interest rates Issuing a token e.g., NXM token issuance, or other governance tokens in which the protocol holds some as a DAO treasury The Fei Protocol primarily funds PCV via bonding curve FEI issuance. The bonding curve mints FEI in exchange for PCV at an oracle determined ETH exchange rate. It escrows this PCV until a keeper (Section 5.1.1) allocates it to various PCV Deposit contracts. {% page-ref page=\"../bondingcurve/\" %} Generalized PCV Fei Protocol is designed to support generalized Protocol Controlled Value. The protocol can fundraise PCV in any ERC-20 token by issuing a bonding curve denominated in that asset, contingent upon a reliable oracle to handle asset pricing. PCV Controllers manage PCV among the various PCV Deposits. Future Fei Protocol upgrades can algorithmically adjust PCV based on market conditions or include unique two-way integrations with other protocols. These integrations can leverage the utility tokens of other platforms or their functionality with other ERC-20 tokens held by the protocol.","title":"Protocol Controlled Value"},{"location":"old/protocol/protocol-controlled-value/#protocol-controlled-value","text":"Protocol Controlled Value ****(PCV) is a categorization of Total Value Locked (TVL) which represents all assets that are ultimately not redeemable by users. Commonly used examples of PCV are DAO treasuries and insurance funds. PCV can be conceptually extended to include any algorithmic management of the protocol-owned assets in order to facilitate protocol goals such as liquidity and stability.","title":"Protocol Controlled Value"},{"location":"old/protocol/protocol-controlled-value/#pcv-funding","text":"Generally, there are two ways for a protocol to fund PCV: Fees for functionality e.g., Compound and Aave insurance pools funded by a spread on borrowing interest rates Issuing a token e.g., NXM token issuance, or other governance tokens in which the protocol holds some as a DAO treasury The Fei Protocol primarily funds PCV via bonding curve FEI issuance. The bonding curve mints FEI in exchange for PCV at an oracle determined ETH exchange rate. It escrows this PCV until a keeper (Section 5.1.1) allocates it to various PCV Deposit contracts. {% page-ref page=\"../bondingcurve/\" %}","title":"PCV Funding"},{"location":"old/protocol/protocol-controlled-value/#generalized-pcv","text":"Fei Protocol is designed to support generalized Protocol Controlled Value. The protocol can fundraise PCV in any ERC-20 token by issuing a bonding curve denominated in that asset, contingent upon a reliable oracle to handle asset pricing. PCV Controllers manage PCV among the various PCV Deposits. Future Fei Protocol upgrades can algorithmically adjust PCV based on market conditions or include unique two-way integrations with other protocols. These integrations can leverage the utility tokens of other platforms or their functionality with other ERC-20 tokens held by the protocol.","title":"Generalized PCV"},{"location":"old/protocol/protocol-controlled-value/ethpcvdepositadapter/","text":"EthPCVDepositAdapter Contract EthPCVDepositAdapter Description Allows contracts which can receive ETH but do not conform to the IPCVDeposit interface to still receive those ETH deposits in a PCV compatible way. Likewise allows native ETH transfers to conform to the IPCVDeposit interface of a contract that does conform to that interface. e.g. sending ETH to the EthPCVDripper from the EthBondingCurve Access Control None Events None Read-Only Functions target function target() external view returns (address); Returns the target address to transfer ETH to Public State-Changing Functions deposit function deposit(uint256 amount) public payable; sends amount ETH to target ABIs {% file src=\"../../.gitbook/assets/ethpcvdepositadapter.json\" caption=\"EthPCVDepositAdapter\" %}","title":"EthPCVDepositAdapter"},{"location":"old/protocol/protocol-controlled-value/ethpcvdepositadapter/#ethpcvdepositadapter","text":"","title":"EthPCVDepositAdapter"},{"location":"old/protocol/protocol-controlled-value/ethpcvdepositadapter/#contract","text":"EthPCVDepositAdapter","title":"Contract"},{"location":"old/protocol/protocol-controlled-value/ethpcvdepositadapter/#description","text":"Allows contracts which can receive ETH but do not conform to the IPCVDeposit interface to still receive those ETH deposits in a PCV compatible way. Likewise allows native ETH transfers to conform to the IPCVDeposit interface of a contract that does conform to that interface. e.g. sending ETH to the EthPCVDripper from the EthBondingCurve","title":"Description"},{"location":"old/protocol/protocol-controlled-value/ethpcvdepositadapter/#access-control","text":"None","title":"Access Control"},{"location":"old/protocol/protocol-controlled-value/ethpcvdepositadapter/#events","text":"None","title":"Events"},{"location":"old/protocol/protocol-controlled-value/ethpcvdepositadapter/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/protocol-controlled-value/ethpcvdepositadapter/#target","text":"function target() external view returns (address); Returns the target address to transfer ETH to","title":"target"},{"location":"old/protocol/protocol-controlled-value/ethpcvdepositadapter/#public-state-changing-functions","text":"","title":"Public State-Changing Functions"},{"location":"old/protocol/protocol-controlled-value/ethpcvdepositadapter/#deposit","text":"function deposit(uint256 amount) public payable; sends amount ETH to target","title":"deposit"},{"location":"old/protocol/protocol-controlled-value/ethpcvdepositadapter/#abis","text":"{% file src=\"../../.gitbook/assets/ethpcvdepositadapter.json\" caption=\"EthPCVDepositAdapter\" %}","title":"ABIs"},{"location":"old/protocol/protocol-controlled-value/ethpcvdripper/","text":"EthPCVDripper Contract EthPCVDripper implements CoreRef , Timed Description Drips fixed size batches of held ETH to a target contract with a certain frequency. {% hint style=\"info\" %} If the target has at least the batch size ( amountToDrip ) then the drip will fail {% endhint %} The dripper prevents a target contract from holding more than 2x the batch size of ETH effectively allowing a smoother release of potentially large amounts of ETH to target contracts. This has a few advantages: Allowing the Guardian to intervene in the event of an issue Mitigating oracle manipulation risk Preventing large ETH supply shocks to happen instantaneously Parameterization Param Value amountToDrip 5000000000000000000000 (5000 ETH) duration 3600 (1 hour) target 0xa08A721dFB595753FFf335636674D76C455B275C ( EthReserveStabilizer ) Access Control None Events {% tabs %} {% tab title=\"Dripped\" %} A drip to the target type param description uint256 amount amount ETH dripped {% endtab %} {% tab title=\"Withdrawal\" %} Withdrawal of PCV type param description address indexed _to the recipient address of the PCV uint256 _amount amount withdrawn {% endtab %} {% endtabs %} Read-Only Functions isTargetBalanceLow function isTargetBalanceLow() external view returns (bool); Returns true when the target balance is less than amountToDrip target function target() external view returns (address); Returns the target address to drip to amountToDrip Returns the amount dripped to the target on each drip call Public State-Changing Functions drip function drip() external; Sends amountToDrip() ETH to target() if the following conditions are met: duration seconds have passed since the last drip the contract is not paused by the Guardian isTargetBalanceLow() is true emits Dripped PCV Controller-Only \u2699\ufe0f State-Changing Functions withdraw function withdrawETH(address payable to, uint256 amount) external; Withdraws amount ETH to address to from the EthPCVDripper emits Withdrawal ABIs {% file src=\"../../.gitbook/assets/ethpcvdripper.json\" caption=\"EthPCVDripper ABI\" %}","title":"EthPCVDripper"},{"location":"old/protocol/protocol-controlled-value/ethpcvdripper/#ethpcvdripper","text":"","title":"EthPCVDripper"},{"location":"old/protocol/protocol-controlled-value/ethpcvdripper/#contract","text":"EthPCVDripper implements CoreRef , Timed","title":"Contract"},{"location":"old/protocol/protocol-controlled-value/ethpcvdripper/#description","text":"Drips fixed size batches of held ETH to a target contract with a certain frequency. {% hint style=\"info\" %} If the target has at least the batch size ( amountToDrip ) then the drip will fail {% endhint %} The dripper prevents a target contract from holding more than 2x the batch size of ETH effectively allowing a smoother release of potentially large amounts of ETH to target contracts. This has a few advantages: Allowing the Guardian to intervene in the event of an issue Mitigating oracle manipulation risk Preventing large ETH supply shocks to happen instantaneously","title":"Description"},{"location":"old/protocol/protocol-controlled-value/ethpcvdripper/#parameterization","text":"Param Value amountToDrip 5000000000000000000000 (5000 ETH) duration 3600 (1 hour) target 0xa08A721dFB595753FFf335636674D76C455B275C ( EthReserveStabilizer )","title":"Parameterization"},{"location":"old/protocol/protocol-controlled-value/ethpcvdripper/#access-control","text":"None","title":"Access Control"},{"location":"old/protocol/protocol-controlled-value/ethpcvdripper/#events","text":"{% tabs %} {% tab title=\"Dripped\" %} A drip to the target type param description uint256 amount amount ETH dripped {% endtab %} {% tab title=\"Withdrawal\" %} Withdrawal of PCV type param description address indexed _to the recipient address of the PCV uint256 _amount amount withdrawn {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/protocol-controlled-value/ethpcvdripper/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/protocol-controlled-value/ethpcvdripper/#istargetbalancelow","text":"function isTargetBalanceLow() external view returns (bool); Returns true when the target balance is less than amountToDrip","title":"isTargetBalanceLow"},{"location":"old/protocol/protocol-controlled-value/ethpcvdripper/#target","text":"function target() external view returns (address); Returns the target address to drip to","title":"target"},{"location":"old/protocol/protocol-controlled-value/ethpcvdripper/#amounttodrip","text":"Returns the amount dripped to the target on each drip call","title":"amountToDrip"},{"location":"old/protocol/protocol-controlled-value/ethpcvdripper/#public-state-changing-functions","text":"","title":"Public State-Changing Functions"},{"location":"old/protocol/protocol-controlled-value/ethpcvdripper/#drip","text":"function drip() external; Sends amountToDrip() ETH to target() if the following conditions are met: duration seconds have passed since the last drip the contract is not paused by the Guardian isTargetBalanceLow() is true emits Dripped","title":"drip"},{"location":"old/protocol/protocol-controlled-value/ethpcvdripper/#pcv-controller-only-state-changing-functions","text":"","title":"PCV Controller-Only \u2699\ufe0f State-Changing Functions"},{"location":"old/protocol/protocol-controlled-value/ethpcvdripper/#withdraw","text":"function withdrawETH(address payable to, uint256 amount) external; Withdraws amount ETH to address to from the EthPCVDripper emits Withdrawal","title":"withdraw"},{"location":"old/protocol/protocol-controlled-value/ethpcvdripper/#abis","text":"{% file src=\"../../.gitbook/assets/ethpcvdripper.json\" caption=\"EthPCVDripper ABI\" %}","title":"ABIs"},{"location":"old/protocol/protocol-controlled-value/ethreservestabilizer/","text":"EthReserveStabilizer Contract EthReserveStabilizer.sol implements IReserveStabilizer , OracleRef Description A contract for exchanging FEI for ETH from reserves at some USD price relative to an oracle. For example if ETH is $2500 and the usd exchange rate for FEI is $0.90 then ~2777 FEI can be exchanged for 1 ETH. Receives ETH from the EthPCVDripper in batches {% page-ref page=\"ethpcvdripper.md\" %} Parameterization Param Value usdPerFeiBasisPoints 95000 (95%) oracle 0x087F35bd241e41Fc28E43f0E8C58d283DD55bD65 (UniswapOracle) Access Control Burner\ud83d\udd25 Events {% tabs %} {% tab title=\"FeiExchange\" %} Exchange FEI for ETH from the PCV type param description address indexed to address of the exchanger uint256 feiAmount amount of FEI exchanged uint256 amountOut amount of ETH received {% endtab %} {% tab title=\"Withdrawal\" %} Withdrawal of PCV type param description address indexed _caller the PCV controller calling this function address indexed _to the recipient address of the PCV uint256 _amount amount withdrawn {% endtab %} {% tab title=\"UsdPerFeiRateUpdate\" %} Update of the conversion rate between USD and FEI type param description uint256 basisPoints amount of basis points in USD per FEI terms {% endtab %} {% endtabs %} Read-Only Functions getAmountOut function getAmountOut(uint256 amountFeiIn) external view returns (uint256); Returns the amount of ETH received for a FEI exchange of size amountFeiIn Multiplies the amountFeiIn by the inverted peg and the usdPerFeiBasisPoints / 10000 {% hint style=\"warning\" %} Can be inaccurate if outdated, need to call oracle().isOutdated() to check {% endhint %} usdPerFeiBasisPoints function usdPerFeiBasisPoints() external view returns (uint256); returns the usdPerFeiBasisPoints exchange rate between FEI and $1 worth of ETH denominated in basis points (1/10000) Public State-Changing Functions exchangeFei function exchangeFei(uint256 feiAmount) external returns (uint256); Burns feiAmount FEI from the caller then sends getAmountOut(feiAmount) of ETH to the caller and returns that value emits FeiExchange PCV Controller-Only \u2699\ufe0f State-Changing Functions withdraw function withdraw(address to, uint256 amount) external; Withdraws amount ETH to address to from the EthReserveStabilizer emits Withdrawal Governor-Only\u2696\ufe0f State-Changing Functions function setUsdPerFeiRate(uint256 exchangeRateBasisPoints) external; Sets the usdPerFeiBasisPoints to exchangeRateBasisPoints emits UsdPerFeiRateUpdate ABIs {% file src=\"../../.gitbook/assets/ethreservestabilizer.json\" caption=\"EthReserveStabilizer ABI\" %} {% file src=\"../../.gitbook/assets/ireservestabilizer.json\" caption=\"IReserveStabilizer ABI\" %}","title":"EthReserveStabilizer"},{"location":"old/protocol/protocol-controlled-value/ethreservestabilizer/#ethreservestabilizer","text":"","title":"EthReserveStabilizer"},{"location":"old/protocol/protocol-controlled-value/ethreservestabilizer/#contract","text":"EthReserveStabilizer.sol implements IReserveStabilizer , OracleRef","title":"Contract"},{"location":"old/protocol/protocol-controlled-value/ethreservestabilizer/#description","text":"A contract for exchanging FEI for ETH from reserves at some USD price relative to an oracle. For example if ETH is $2500 and the usd exchange rate for FEI is $0.90 then ~2777 FEI can be exchanged for 1 ETH. Receives ETH from the EthPCVDripper in batches {% page-ref page=\"ethpcvdripper.md\" %}","title":"Description"},{"location":"old/protocol/protocol-controlled-value/ethreservestabilizer/#parameterization","text":"Param Value usdPerFeiBasisPoints 95000 (95%) oracle 0x087F35bd241e41Fc28E43f0E8C58d283DD55bD65 (UniswapOracle)","title":"Parameterization"},{"location":"old/protocol/protocol-controlled-value/ethreservestabilizer/#access-control","text":"Burner\ud83d\udd25","title":"Access Control"},{"location":"old/protocol/protocol-controlled-value/ethreservestabilizer/#events","text":"{% tabs %} {% tab title=\"FeiExchange\" %} Exchange FEI for ETH from the PCV type param description address indexed to address of the exchanger uint256 feiAmount amount of FEI exchanged uint256 amountOut amount of ETH received {% endtab %} {% tab title=\"Withdrawal\" %} Withdrawal of PCV type param description address indexed _caller the PCV controller calling this function address indexed _to the recipient address of the PCV uint256 _amount amount withdrawn {% endtab %} {% tab title=\"UsdPerFeiRateUpdate\" %} Update of the conversion rate between USD and FEI type param description uint256 basisPoints amount of basis points in USD per FEI terms {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/protocol-controlled-value/ethreservestabilizer/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/protocol-controlled-value/ethreservestabilizer/#getamountout","text":"function getAmountOut(uint256 amountFeiIn) external view returns (uint256); Returns the amount of ETH received for a FEI exchange of size amountFeiIn Multiplies the amountFeiIn by the inverted peg and the usdPerFeiBasisPoints / 10000 {% hint style=\"warning\" %} Can be inaccurate if outdated, need to call oracle().isOutdated() to check {% endhint %}","title":"getAmountOut"},{"location":"old/protocol/protocol-controlled-value/ethreservestabilizer/#usdperfeibasispoints","text":"function usdPerFeiBasisPoints() external view returns (uint256); returns the usdPerFeiBasisPoints exchange rate between FEI and $1 worth of ETH denominated in basis points (1/10000)","title":"usdPerFeiBasisPoints"},{"location":"old/protocol/protocol-controlled-value/ethreservestabilizer/#public-state-changing-functions","text":"","title":"Public State-Changing Functions"},{"location":"old/protocol/protocol-controlled-value/ethreservestabilizer/#exchangefei","text":"function exchangeFei(uint256 feiAmount) external returns (uint256); Burns feiAmount FEI from the caller then sends getAmountOut(feiAmount) of ETH to the caller and returns that value emits FeiExchange","title":"exchangeFei"},{"location":"old/protocol/protocol-controlled-value/ethreservestabilizer/#pcv-controller-only-state-changing-functions","text":"","title":"PCV Controller-Only \u2699\ufe0f State-Changing Functions"},{"location":"old/protocol/protocol-controlled-value/ethreservestabilizer/#withdraw","text":"function withdraw(address to, uint256 amount) external; Withdraws amount ETH to address to from the EthReserveStabilizer emits Withdrawal","title":"withdraw"},{"location":"old/protocol/protocol-controlled-value/ethreservestabilizer/#governor-only-state-changing-functions","text":"function setUsdPerFeiRate(uint256 exchangeRateBasisPoints) external; Sets the usdPerFeiBasisPoints to exchangeRateBasisPoints emits UsdPerFeiRateUpdate","title":"Governor-Only\u2696\ufe0f State-Changing Functions"},{"location":"old/protocol/protocol-controlled-value/ethreservestabilizer/#abis","text":"{% file src=\"../../.gitbook/assets/ethreservestabilizer.json\" caption=\"EthReserveStabilizer ABI\" %} {% file src=\"../../.gitbook/assets/ireservestabilizer.json\" caption=\"IReserveStabilizer ABI\" %}","title":"ABIs"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/","text":"EthUniswapPCVController Contract EthUniswapPCVController.sol implements IUniswapPCVController , UniRef Description A contract for moving reweighting Uniswap prices to the peg from a Uniswap PCV Deposit. ETH specific implementation. Reweight Reweights are used to return the Uniswap spot price of an associated PCV Deposit to the peg. The algorithm is as follows: withdraw 99% of the ETH from the UniswapPCVDeposit execute a trade with held ETH to bring the spot price back up to peg deposit remaining ETH balance back into the Uniswap PCV Deposit burn excess held FEI {% hint style=\"info\" %} Only 99% is withdrawn because if there are no other LPs there could be rounding errors against dust {% endhint %} Reweight eligibility The reweight is open to a keeper when both of the following conditions are met: the distance from the peg is at least the minimum (initially 1%) the UniswapIncentive contract is at incentive parity Governor\u2696\ufe0fand Guardian\ud83d\udee1contracts can force a reweight at any time, or update the minimum distance requirement. Reweight incentives Reweight executions are incentivized with 500 FEI if the controller is appointed as a Minter\ud83d\udcb0. Governance can adjust this incentive amount. Access Control Minter\ud83d\udcb0 PCV Controller\u2699\ufe0f Events {% tabs %} {% tab title=\"Reweight\" %} A Uniswap Reweight event type param description address indexed _caller the address triggering the reweight {% endtab %} {% tab title=\"PCVDepositUpdate\" %} Change the PCV Deposit contract type param description address indexed _pcvDeposit new pcv deposit contract {% endtab %} {% tab title=\"ReweightIncentiveUpdate\" %} Change the FEI reward for reweighting type param description uint256 _amount FEI reward amount {% endtab %} {% tab title=\"ReweightMinDistanceUpdate\" %} Change the min distance for a reweight type param description uint256 _basisPoints Minimum reweight amount in basis points (i.e. 1/10000) {% endtab %} {% tab title=\"ReweightWithdrawBPsUpdate\" %} Change the amount of PCV withdrawn during a reweight type param description uint256 _reweightWithdrawBPs amount of PCV withdrawn for a reweight in basis point terms (1/10000). {% endtab %} {% endtabs %} Read-Only Functions pcvDeposit function pcvDeposit() external returns (IPCVDeposit); Returns the PCV Deposit address this controller focuses on reweighting. incentiveContract function incentiveContract() external returns (IUniswapIncentive); Returns the UniswapIncentive contract used to determine reweight eligibility. reweightIncentiveAmount function reweightIncentiveAmount() external returns (uint256); Returns the amount of FEI received by any keeper who successfully executes a reweight. reweightWithdrawBPs function reweightWithdrawBPs() external returns (uint256); Returns the amount of PCV withdrawn during a reweight in basis points terms. reweightEligible function reweightEligible() external view returns (bool); Returns true when the distance from the peg is at least the minimum (initially 1%) and the UniswapIncentive contract is at incentive parity, otherwise false. minDistanceForReweight function minDistanceForReweight() external view returns (Decimal.D256 memory); Returns the minimum percent distance from the peg needed for keepers to reweight the peg. EOA-Only \ud83d\udc64 State-Changing Functions reweight function reweight() external; Executes a reweight if reweightEligible. Rewards the caller with 500 FEI. {% hint style=\"info\" %} This method is pausable {% endhint %} Governor- Or Guardian-Only\u2696\ufe0f\ud83d\udee1 State-Changing Functions forceReweight function forceReweight() external; Forces a reweight execution. No FEI incentive for doing this. Fails if the Uniswap spot price is already at or above the peg. Governor-Only\u2696\ufe0f State-Changing Functions setReweightMinDistance function setReweightMinDistance(uint256 basisPoints) external; Sets the minimum distance from the peg for a reweight to be eligible to basisPoints , measured in basis points (i.e. 1/10000). emits ReweightMinDistanceUpdate setReweightWithdrawBPs function setReweightWithdrawBPs(uint256 _reweightWithdrawBPs) external; Sets the percentage of the PCV withdrawn when executing a reweight in terms of basis points emits ReweightWithdrawBPsUpdate setPCVDeposit function setPCVDeposit(address _pcvDeposit) external; Sets the target PCV Deposit contract for reweight to _pcvDeposit emits PCVDepositUpdate setReweightIncentive function setReweightIncentive(uint256 amount) external; Sets the keeper incentive for executing a reweight to amount of FEI emits ReweightIncentiveUpdate ABIs {% file src=\"../../.gitbook/assets/ethuniswappcvcontroller.json\" caption=\"EthUniswapPCVController ABI\" %} {% file src=\"../../.gitbook/assets/iuniswappcvcontroller.json\" caption=\"UniswapPCVController Interface ABI\" %}","title":"EthUniswapPCVController"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#ethuniswappcvcontroller","text":"","title":"EthUniswapPCVController"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#contract","text":"EthUniswapPCVController.sol implements IUniswapPCVController , UniRef","title":"Contract"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#description","text":"A contract for moving reweighting Uniswap prices to the peg from a Uniswap PCV Deposit. ETH specific implementation.","title":"Description"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#reweight","text":"Reweights are used to return the Uniswap spot price of an associated PCV Deposit to the peg. The algorithm is as follows: withdraw 99% of the ETH from the UniswapPCVDeposit execute a trade with held ETH to bring the spot price back up to peg deposit remaining ETH balance back into the Uniswap PCV Deposit burn excess held FEI {% hint style=\"info\" %} Only 99% is withdrawn because if there are no other LPs there could be rounding errors against dust {% endhint %}","title":"Reweight"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#reweight-eligibility","text":"The reweight is open to a keeper when both of the following conditions are met: the distance from the peg is at least the minimum (initially 1%) the UniswapIncentive contract is at incentive parity Governor\u2696\ufe0fand Guardian\ud83d\udee1contracts can force a reweight at any time, or update the minimum distance requirement.","title":"Reweight eligibility"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#reweight-incentives","text":"Reweight executions are incentivized with 500 FEI if the controller is appointed as a Minter\ud83d\udcb0. Governance can adjust this incentive amount.","title":"Reweight incentives"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#access-control","text":"Minter\ud83d\udcb0 PCV Controller\u2699\ufe0f","title":"Access Control"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#events","text":"{% tabs %} {% tab title=\"Reweight\" %} A Uniswap Reweight event type param description address indexed _caller the address triggering the reweight {% endtab %} {% tab title=\"PCVDepositUpdate\" %} Change the PCV Deposit contract type param description address indexed _pcvDeposit new pcv deposit contract {% endtab %} {% tab title=\"ReweightIncentiveUpdate\" %} Change the FEI reward for reweighting type param description uint256 _amount FEI reward amount {% endtab %} {% tab title=\"ReweightMinDistanceUpdate\" %} Change the min distance for a reweight type param description uint256 _basisPoints Minimum reweight amount in basis points (i.e. 1/10000) {% endtab %} {% tab title=\"ReweightWithdrawBPsUpdate\" %} Change the amount of PCV withdrawn during a reweight type param description uint256 _reweightWithdrawBPs amount of PCV withdrawn for a reweight in basis point terms (1/10000). {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#pcvdeposit","text":"function pcvDeposit() external returns (IPCVDeposit); Returns the PCV Deposit address this controller focuses on reweighting.","title":"pcvDeposit"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#incentivecontract","text":"function incentiveContract() external returns (IUniswapIncentive); Returns the UniswapIncentive contract used to determine reweight eligibility.","title":"incentiveContract"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#reweightincentiveamount","text":"function reweightIncentiveAmount() external returns (uint256); Returns the amount of FEI received by any keeper who successfully executes a reweight.","title":"reweightIncentiveAmount"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#reweightwithdrawbps","text":"function reweightWithdrawBPs() external returns (uint256); Returns the amount of PCV withdrawn during a reweight in basis points terms.","title":"reweightWithdrawBPs"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#reweighteligible","text":"function reweightEligible() external view returns (bool); Returns true when the distance from the peg is at least the minimum (initially 1%) and the UniswapIncentive contract is at incentive parity, otherwise false.","title":"reweightEligible"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#mindistanceforreweight","text":"function minDistanceForReweight() external view returns (Decimal.D256 memory); Returns the minimum percent distance from the peg needed for keepers to reweight the peg.","title":"minDistanceForReweight"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#eoa-only-state-changing-functions","text":"","title":"EOA-Only \ud83d\udc64 State-Changing Functions"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#reweight_1","text":"function reweight() external; Executes a reweight if reweightEligible. Rewards the caller with 500 FEI. {% hint style=\"info\" %} This method is pausable {% endhint %}","title":"reweight"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#governor-or-guardian-only-state-changing-functions","text":"","title":"Governor- Or Guardian-Only\u2696\ufe0f\ud83d\udee1 State-Changing Functions"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#forcereweight","text":"function forceReweight() external; Forces a reweight execution. No FEI incentive for doing this. Fails if the Uniswap spot price is already at or above the peg.","title":"forceReweight"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#governor-only-state-changing-functions","text":"","title":"Governor-Only\u2696\ufe0f State-Changing Functions"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#setreweightmindistance","text":"function setReweightMinDistance(uint256 basisPoints) external; Sets the minimum distance from the peg for a reweight to be eligible to basisPoints , measured in basis points (i.e. 1/10000). emits ReweightMinDistanceUpdate","title":"setReweightMinDistance"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#setreweightwithdrawbps","text":"function setReweightWithdrawBPs(uint256 _reweightWithdrawBPs) external; Sets the percentage of the PCV withdrawn when executing a reweight in terms of basis points emits ReweightWithdrawBPsUpdate","title":"setReweightWithdrawBPs"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#setpcvdeposit","text":"function setPCVDeposit(address _pcvDeposit) external; Sets the target PCV Deposit contract for reweight to _pcvDeposit emits PCVDepositUpdate","title":"setPCVDeposit"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#setreweightincentive","text":"function setReweightIncentive(uint256 amount) external; Sets the keeper incentive for executing a reweight to amount of FEI emits ReweightIncentiveUpdate","title":"setReweightIncentive"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvcontroller/#abis","text":"{% file src=\"../../.gitbook/assets/ethuniswappcvcontroller.json\" caption=\"EthUniswapPCVController ABI\" %} {% file src=\"../../.gitbook/assets/iuniswappcvcontroller.json\" caption=\"UniswapPCVController Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvdeposit/","text":"EthUniswapPCVDeposit Contract EthUniswapPCVDeposit.sol implements UniswapPCVDeposit Description An ETH implementation of UniswapPCVDeposit. {% page-ref page=\"uniswappcvdeposit.md\" %} Access Control Minter\ud83d\udcb0 ABIs {% file src=\"../../.gitbook/assets/ethuniswappcvdeposit.json\" caption=\"EthUniswapPCVDeposit ABI\" %}","title":"EthUniswapPCVDeposit"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvdeposit/#ethuniswappcvdeposit","text":"","title":"EthUniswapPCVDeposit"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvdeposit/#contract","text":"EthUniswapPCVDeposit.sol implements UniswapPCVDeposit","title":"Contract"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvdeposit/#description","text":"An ETH implementation of UniswapPCVDeposit. {% page-ref page=\"uniswappcvdeposit.md\" %}","title":"Description"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvdeposit/#access-control","text":"Minter\ud83d\udcb0","title":"Access Control"},{"location":"old/protocol/protocol-controlled-value/ethuniswappcvdeposit/#abis","text":"{% file src=\"../../.gitbook/assets/ethuniswappcvdeposit.json\" caption=\"EthUniswapPCVDeposit ABI\" %}","title":"ABIs"},{"location":"old/protocol/protocol-controlled-value/ratiopcvcontroller/","text":"RatioPCVController Contract RatioPCVController implements CoreRef Description Enables withdrawing a percentage of PCV from a IPCVDeposit contract. This is useful when the amount of PCV in the contract can change during the voting and execution windows of a proposal. e.g. sending ETH to the EthPCVDripper from the EthBondingCurve Access Control PCVController\u2699\ufe0f Events {% tabs %} {% tab title=\"Withdraw\" %} A withdrawal of PCV to a target type param description address indexed pcvDeposit The PCV deposit to withdraw from address indexed to the target to send PCV to uint256 amount amount withdrawn {% endtab %} {% endtabs %} Public State-Changing Functions withdrawRatio function withdrawRatio(IPCVDeposit pcvDeposit, address to, uint256 basisPoints) public; Withdraws basisPoints / 10000 PCV from pcvDeposit and sends to address to Calculates the amount of PCV by calling totalValue() on the pcvDeposit and multiplying by the ratio emits Withdraw","title":"RatioPCVController"},{"location":"old/protocol/protocol-controlled-value/ratiopcvcontroller/#ratiopcvcontroller","text":"","title":"RatioPCVController"},{"location":"old/protocol/protocol-controlled-value/ratiopcvcontroller/#contract","text":"RatioPCVController implements CoreRef","title":"Contract"},{"location":"old/protocol/protocol-controlled-value/ratiopcvcontroller/#description","text":"Enables withdrawing a percentage of PCV from a IPCVDeposit contract. This is useful when the amount of PCV in the contract can change during the voting and execution windows of a proposal. e.g. sending ETH to the EthPCVDripper from the EthBondingCurve","title":"Description"},{"location":"old/protocol/protocol-controlled-value/ratiopcvcontroller/#access-control","text":"PCVController\u2699\ufe0f","title":"Access Control"},{"location":"old/protocol/protocol-controlled-value/ratiopcvcontroller/#events","text":"{% tabs %} {% tab title=\"Withdraw\" %} A withdrawal of PCV to a target type param description address indexed pcvDeposit The PCV deposit to withdraw from address indexed to the target to send PCV to uint256 amount amount withdrawn {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/protocol-controlled-value/ratiopcvcontroller/#public-state-changing-functions","text":"","title":"Public State-Changing Functions"},{"location":"old/protocol/protocol-controlled-value/ratiopcvcontroller/#withdrawratio","text":"function withdrawRatio(IPCVDeposit pcvDeposit, address to, uint256 basisPoints) public; Withdraws basisPoints / 10000 PCV from pcvDeposit and sends to address to Calculates the amount of PCV by calling totalValue() on the pcvDeposit and multiplying by the ratio emits Withdraw","title":"withdrawRatio"},{"location":"old/protocol/protocol-controlled-value/uniswappcvdeposit/","text":"UniswapPCVDeposit Contract UniswapPCVDeposit.sol implements IPCVDeposit , UniRef Description An abstract contract for storing PCV in a Uniswap FEI liquidity pair Uniswap PCV deposits receive PCV, mint the corresponding amount of FEI to match the Uniswap spot price, and deposit to Uniswap. They can withdraw and read in the amount of non-FEI PCV on Uniswap held in the contract. When withdrawing, any excess FEI held is burned. When depositing, if no existing LP exists, the oracle price is used. The oracle is a BondingCurveOracle subject to thawing and the bonding curve price. Access Control Minter\ud83d\udcb0 Events {% tabs %} {% tab title=\"Deposit\" %} Deposit to the PCV type param description address indexed _from address of the depositor uint256 _amount amount deposited {% endtab %} {% tab title=\"Withdrawal\" %} Withdrawal of PCV type param description address indexed _caller the PCV controller calling this function address indexed _to the recipient address of the PCV uint256 _amount amount withdrawn {% endtab %} {% tab title=\"MaxBasisPointsFromPegLPUpdate\" %} update to maxBasisPointsFromPegLP type param description uint256 oldMaxBasisPointsFromPegLP old maxBasisPointsFromPegLP uint256 newMaxBasisPointsFromPegLP new maxBasisPointsFromPegLP {% endtab %} {% endtabs %} Read-Only Functions totalValue function totalValue() external view returns (uint256); Returns the effective amount of non-FEI PCV held by the contract. E.g., if the deposit holds 50% of all ETH/FEI liquidity on Uniswap, and there are 100,000 ETH in Uniswap, the function should return 50,000e18 wei. maxBasisPointsFromPegLP function maxBasisPointsFromPegLP() external view returns (uint256); Returns an amount of basis points (1/10000) beyond which if the FEI-ETH spot price is trading outside of the peg, the deposit function will fail. Public State-Changing Functions deposit function deposit(uint256 amount) external payable; Deposits amount PCV into Uniswap by minting the necessary amount of FEI to make the liquidity provision. E.g., if there are 50,000 ETH and 100,000,000 FEI on Uniswap, and the protocol receives another 500 ETH to deposit, the protocol will mint another 1,000,000 FEI to deposit at the current 2000 FEI/ETH spot price. PCV Controller-Only \u2699\ufe0f State-Changing Functions withdraw function withdraw(address to, uint256 amount) external; Withdraws amount PCV from Uniswap to address to by withdrawing the necessary amount of liquidity and burning the corresponding FEI. E.g., if the protocol owns 50,000 ETH and 100,000,000 FEI worth of liquidity on Uniswap, a withdrawal of 500 ETH would liquidate 1% of the LP shares and burn the extra 1,000,000 FEI received before transferring the 500 ETH. Governor-Only\u2696\ufe0f State-Changing Functions setMaxBasisPointsFromPegLP function setMaxBasisPointsFromPegLP(uint256 _maxBasisPointsFromPegLP) external view; Sets the new maxBasisPointsFromPegLP emits MaxBasisPointsFromPegLPUpdate ABIs {% file src=\"../../.gitbook/assets/uniswappcvdeposit.json\" caption=\"UniswapPCVDeposit ABI\" %} {% file src=\"../../.gitbook/assets/ipcvdeposit.json\" caption=\"PCVDeposit Interface ABI\" %}","title":"UniswapPCVDeposit"},{"location":"old/protocol/protocol-controlled-value/uniswappcvdeposit/#uniswappcvdeposit","text":"","title":"UniswapPCVDeposit"},{"location":"old/protocol/protocol-controlled-value/uniswappcvdeposit/#contract","text":"UniswapPCVDeposit.sol implements IPCVDeposit , UniRef","title":"Contract"},{"location":"old/protocol/protocol-controlled-value/uniswappcvdeposit/#description","text":"An abstract contract for storing PCV in a Uniswap FEI liquidity pair Uniswap PCV deposits receive PCV, mint the corresponding amount of FEI to match the Uniswap spot price, and deposit to Uniswap. They can withdraw and read in the amount of non-FEI PCV on Uniswap held in the contract. When withdrawing, any excess FEI held is burned. When depositing, if no existing LP exists, the oracle price is used. The oracle is a BondingCurveOracle subject to thawing and the bonding curve price.","title":"Description"},{"location":"old/protocol/protocol-controlled-value/uniswappcvdeposit/#access-control","text":"Minter\ud83d\udcb0","title":"Access Control"},{"location":"old/protocol/protocol-controlled-value/uniswappcvdeposit/#events","text":"{% tabs %} {% tab title=\"Deposit\" %} Deposit to the PCV type param description address indexed _from address of the depositor uint256 _amount amount deposited {% endtab %} {% tab title=\"Withdrawal\" %} Withdrawal of PCV type param description address indexed _caller the PCV controller calling this function address indexed _to the recipient address of the PCV uint256 _amount amount withdrawn {% endtab %} {% tab title=\"MaxBasisPointsFromPegLPUpdate\" %} update to maxBasisPointsFromPegLP type param description uint256 oldMaxBasisPointsFromPegLP old maxBasisPointsFromPegLP uint256 newMaxBasisPointsFromPegLP new maxBasisPointsFromPegLP {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/protocol-controlled-value/uniswappcvdeposit/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/protocol-controlled-value/uniswappcvdeposit/#totalvalue","text":"function totalValue() external view returns (uint256); Returns the effective amount of non-FEI PCV held by the contract. E.g., if the deposit holds 50% of all ETH/FEI liquidity on Uniswap, and there are 100,000 ETH in Uniswap, the function should return 50,000e18 wei.","title":"totalValue"},{"location":"old/protocol/protocol-controlled-value/uniswappcvdeposit/#maxbasispointsfrompeglp","text":"function maxBasisPointsFromPegLP() external view returns (uint256); Returns an amount of basis points (1/10000) beyond which if the FEI-ETH spot price is trading outside of the peg, the deposit function will fail.","title":"maxBasisPointsFromPegLP"},{"location":"old/protocol/protocol-controlled-value/uniswappcvdeposit/#public-state-changing-functions","text":"","title":"Public State-Changing Functions"},{"location":"old/protocol/protocol-controlled-value/uniswappcvdeposit/#deposit","text":"function deposit(uint256 amount) external payable; Deposits amount PCV into Uniswap by minting the necessary amount of FEI to make the liquidity provision. E.g., if there are 50,000 ETH and 100,000,000 FEI on Uniswap, and the protocol receives another 500 ETH to deposit, the protocol will mint another 1,000,000 FEI to deposit at the current 2000 FEI/ETH spot price.","title":"deposit"},{"location":"old/protocol/protocol-controlled-value/uniswappcvdeposit/#pcv-controller-only-state-changing-functions","text":"","title":"PCV Controller-Only \u2699\ufe0f State-Changing Functions"},{"location":"old/protocol/protocol-controlled-value/uniswappcvdeposit/#withdraw","text":"function withdraw(address to, uint256 amount) external; Withdraws amount PCV from Uniswap to address to by withdrawing the necessary amount of liquidity and burning the corresponding FEI. E.g., if the protocol owns 50,000 ETH and 100,000,000 FEI worth of liquidity on Uniswap, a withdrawal of 500 ETH would liquidate 1% of the LP shares and burn the extra 1,000,000 FEI received before transferring the 500 ETH.","title":"withdraw"},{"location":"old/protocol/protocol-controlled-value/uniswappcvdeposit/#governor-only-state-changing-functions","text":"","title":"Governor-Only\u2696\ufe0f State-Changing Functions"},{"location":"old/protocol/protocol-controlled-value/uniswappcvdeposit/#setmaxbasispointsfrompeglp","text":"function setMaxBasisPointsFromPegLP(uint256 _maxBasisPointsFromPegLP) external view; Sets the new maxBasisPointsFromPegLP emits MaxBasisPointsFromPegLPUpdate","title":"setMaxBasisPointsFromPegLP"},{"location":"old/protocol/protocol-controlled-value/uniswappcvdeposit/#abis","text":"{% file src=\"../../.gitbook/assets/uniswappcvdeposit.json\" caption=\"UniswapPCVDeposit ABI\" %} {% file src=\"../../.gitbook/assets/ipcvdeposit.json\" caption=\"PCVDeposit Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/references/","text":"References/Utils References Reference contracts (refs) are extensions to feature contracts that provide utilities related to certain functionality. There are 3 reference contracts in Fei Protocol: {% page-ref page=\"coreref.md\" %} {% page-ref page=\"oracleref.md\" %} {% page-ref page=\"uniref.md\" %} Utils The two main utility contracts are the LinearTokenTimelock, which is used for storing Fei Core Team and investor tokens, and the Timed contract which is used to add time windows to various protocol functionality (including the timelock) {% page-ref page=\"lineartokentimelock.md\" %} {% page-ref page=\"timed.md\" %}","title":"References/Utils"},{"location":"old/protocol/references/#referencesutils","text":"","title":"References/Utils"},{"location":"old/protocol/references/#references","text":"Reference contracts (refs) are extensions to feature contracts that provide utilities related to certain functionality. There are 3 reference contracts in Fei Protocol: {% page-ref page=\"coreref.md\" %} {% page-ref page=\"oracleref.md\" %} {% page-ref page=\"uniref.md\" %}","title":"References"},{"location":"old/protocol/references/#utils","text":"The two main utility contracts are the LinearTokenTimelock, which is used for storing Fei Core Team and investor tokens, and the Timed contract which is used to add time windows to various protocol functionality (including the timelock) {% page-ref page=\"lineartokentimelock.md\" %} {% page-ref page=\"timed.md\" %}","title":"Utils"},{"location":"old/protocol/references/coreref/","text":"CoreRef Contract CoreRef.sol implements ICoreRef , Pausable Description CoreRef is an abstract contract which references Core. It defines basic modifiers and utilities useful for contracts referencing Core. Most of all Fei Protocol contracts implement the CoreRef contract. The contract defines modifiers of the following types: restrict access to certain roles conditional execution if a role is held restrict access to certain contracts (Fei, Core, GenesisGroup) restrict access to post genesis period It allows the governor of a currently referenced Core contract to update to a new referenced Core contract It can read in referenced contract addresses including Core, Fei, Tribe or get token balances. {% page-ref page=\"../access-control/core.md\" %} Events {% tabs %} {% tab title=\"CoreUpdate\" %} Referenced Fei Core contract update type param description address indexed _core new Fei Core {% endtab %} {% endtabs %} Read-Only Functions core function core() external view returns (ICore); Returns the referenced Fei Core address as an interface. fei function fei() external view returns (IFei); Returns the FEI token address as an interface. tribe function tribe() external view returns (IERC20); Returns the TRIBE token address as an interface. feiBalance function feiBalance() external view returns (uint256); Returns the amount of FEI held by this contract tribeBalance function tribeBalance() external view returns (uint256); Returns the amount of TRIBE held by this contract Governor-Only\u2696\ufe0f State-Changing Functions setCore function setCore(address core) external; Sets the currently referenced Fei Core contract to core emits CoreUpdate Guardian- Or Governor-Only\ud83d\udee1\u2696\ufe0f State-Changing Functions pause function pause() external; Puts the contract in the paused state which can shut down pausable external functions unpause function unpause() external; Puts the contract in the unpaused state which can reopen pausable external functions ABIs {% file src=\"../../.gitbook/assets/coreref.json\" caption=\"CoreRef ABI\" %} {% file src=\"../../.gitbook/assets/icoreref.json\" caption=\"CoreRef Interface ABI\" %}","title":"CoreRef"},{"location":"old/protocol/references/coreref/#coreref","text":"","title":"CoreRef"},{"location":"old/protocol/references/coreref/#contract","text":"CoreRef.sol implements ICoreRef , Pausable","title":"Contract"},{"location":"old/protocol/references/coreref/#description","text":"CoreRef is an abstract contract which references Core. It defines basic modifiers and utilities useful for contracts referencing Core. Most of all Fei Protocol contracts implement the CoreRef contract. The contract defines modifiers of the following types: restrict access to certain roles conditional execution if a role is held restrict access to certain contracts (Fei, Core, GenesisGroup) restrict access to post genesis period It allows the governor of a currently referenced Core contract to update to a new referenced Core contract It can read in referenced contract addresses including Core, Fei, Tribe or get token balances. {% page-ref page=\"../access-control/core.md\" %}","title":"Description"},{"location":"old/protocol/references/coreref/#events","text":"{% tabs %} {% tab title=\"CoreUpdate\" %} Referenced Fei Core contract update type param description address indexed _core new Fei Core {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/references/coreref/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/references/coreref/#core","text":"function core() external view returns (ICore); Returns the referenced Fei Core address as an interface.","title":"core"},{"location":"old/protocol/references/coreref/#fei","text":"function fei() external view returns (IFei); Returns the FEI token address as an interface.","title":"fei"},{"location":"old/protocol/references/coreref/#tribe","text":"function tribe() external view returns (IERC20); Returns the TRIBE token address as an interface.","title":"tribe"},{"location":"old/protocol/references/coreref/#feibalance","text":"function feiBalance() external view returns (uint256); Returns the amount of FEI held by this contract","title":"feiBalance"},{"location":"old/protocol/references/coreref/#tribebalance","text":"function tribeBalance() external view returns (uint256); Returns the amount of TRIBE held by this contract","title":"tribeBalance"},{"location":"old/protocol/references/coreref/#governor-only-state-changing-functions","text":"","title":"Governor-Only\u2696\ufe0f State-Changing Functions"},{"location":"old/protocol/references/coreref/#setcore","text":"function setCore(address core) external; Sets the currently referenced Fei Core contract to core emits CoreUpdate","title":"setCore"},{"location":"old/protocol/references/coreref/#guardian-or-governor-only-state-changing-functions","text":"","title":"Guardian- Or Governor-Only\ud83d\udee1\u2696\ufe0f State-Changing Functions"},{"location":"old/protocol/references/coreref/#pause","text":"function pause() external; Puts the contract in the paused state which can shut down pausable external functions","title":"pause"},{"location":"old/protocol/references/coreref/#unpause","text":"function unpause() external; Puts the contract in the unpaused state which can reopen pausable external functions","title":"unpause"},{"location":"old/protocol/references/coreref/#abis","text":"{% file src=\"../../.gitbook/assets/coreref.json\" caption=\"CoreRef ABI\" %} {% file src=\"../../.gitbook/assets/icoreref.json\" caption=\"CoreRef Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/references/lineartokentimelock/","text":"LinearTokenTimelock Contract LinearTokenTimelock.sol implements Timed Description A timelock for releasing tokens over a continuous linear schedule. There is an appointed beneficiary who controls the tokens when vested. The beneficiary can set a new one if needed using the offer-accept pattern. Release Calculation Uses Timed to have a fixed period d of release. The elapsed time t is on the range [0,d]. The contract maintains the following: T - a total token amount which includes any already released and locked tokens. It can increase if new tokens enter the timelock but it cannot decrease. C - the current held tokens in the contract The portion of T available for release is T*t/d . The already released amount is T - C . The net amount available for release is the total available minus already released. The beneficiary can claim these at any time, and distribute to any address. Events {% tabs %} {% tab title=\"Release\" %} A release of timelocked tokens type param description address indexed _beneficiary the address that owns the timelocked tokens address indexed _recipient the address receiving this unlocked distribution uint256 _amount the amount of unlocked tokens released {% endtab %} {% tab title=\"BeneficiaryUpdate\" %} A change in beneficiary to the timelock type param description address indexed _beneficiary the new beneficiary address {% endtab %} {% tab title=\"PendingBeneficiaryUpdate\" %} A change in pending beneficiary to the timelock type param description address indexed _pendingBeneficiary the new beneficiary address {% endtab %} {% endtabs %} Read-Only Functions lockedToken function lockedToken() external view returns (IERC20); Returns the address of the locked token casted as an IERC20 interface. beneficiary function beneficiary() external view returns (address); Returns the current beneficiary address. pendingBeneficiary function pendingBeneficiary() external view returns (address); Returns the pending beneficiary, which could assume the beneficiary role at any time by calling acceptBeneficiary() initialBalance function initialBalance() external view returns (uint256); Returns the initial total amount of locked tokens. If new tokens are dropped into the timelock, this number increases to prevent accounting errors. availableForRelease function availableForRelease() external view returns (uint256); The amount of lockedToken available to be released by the beneficiary. totalToken function totalToken() external view returns(uint256); Returns the total amount of tokens held by the timelock pending release. alreadyReleasedAmount function alreadyReleasedAmount() external view returns (uint256); The amount of lockedToken already released by the beneficiary. Public State-Changing Functions acceptBeneficiary function acceptBeneficiary() external; Accepts the beneficiary role for msg.sender . Must already be the pending beneficiary. emits BeneficiaryUpdate Beneficiary-Only\ud83d\udc51 State-Changing Functions function release(address to, uint amount) external; Releases amount of timelocked tokens to address to . The amount must be less than or equal to the released amount of tokens. emits Release setPendingBeneficiary function setPendingBeneficiary(address _pendingBeneficiary) external; Sets the pending beneficiary to _pendingBeneficiary . emits PendingBeneficiaryUpdate ABIs {% file src=\"../../.gitbook/assets/lineartokentimelock.json\" caption=\"LinearTokenTimelock ABI\" %} {% file src=\"../../.gitbook/assets/ilineartokentimelock.json\" caption=\"LinearTokenTimelock Interface ABI\" %}","title":"LinearTokenTimelock"},{"location":"old/protocol/references/lineartokentimelock/#lineartokentimelock","text":"","title":"LinearTokenTimelock"},{"location":"old/protocol/references/lineartokentimelock/#contract","text":"LinearTokenTimelock.sol implements Timed","title":"Contract"},{"location":"old/protocol/references/lineartokentimelock/#description","text":"A timelock for releasing tokens over a continuous linear schedule. There is an appointed beneficiary who controls the tokens when vested. The beneficiary can set a new one if needed using the offer-accept pattern.","title":"Description"},{"location":"old/protocol/references/lineartokentimelock/#release-calculation","text":"Uses Timed to have a fixed period d of release. The elapsed time t is on the range [0,d]. The contract maintains the following: T - a total token amount which includes any already released and locked tokens. It can increase if new tokens enter the timelock but it cannot decrease. C - the current held tokens in the contract The portion of T available for release is T*t/d . The already released amount is T - C . The net amount available for release is the total available minus already released. The beneficiary can claim these at any time, and distribute to any address.","title":"Release Calculation"},{"location":"old/protocol/references/lineartokentimelock/#events","text":"{% tabs %} {% tab title=\"Release\" %} A release of timelocked tokens type param description address indexed _beneficiary the address that owns the timelocked tokens address indexed _recipient the address receiving this unlocked distribution uint256 _amount the amount of unlocked tokens released {% endtab %} {% tab title=\"BeneficiaryUpdate\" %} A change in beneficiary to the timelock type param description address indexed _beneficiary the new beneficiary address {% endtab %} {% tab title=\"PendingBeneficiaryUpdate\" %} A change in pending beneficiary to the timelock type param description address indexed _pendingBeneficiary the new beneficiary address {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/references/lineartokentimelock/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/references/lineartokentimelock/#lockedtoken","text":"function lockedToken() external view returns (IERC20); Returns the address of the locked token casted as an IERC20 interface.","title":"lockedToken"},{"location":"old/protocol/references/lineartokentimelock/#beneficiary","text":"function beneficiary() external view returns (address); Returns the current beneficiary address.","title":"beneficiary"},{"location":"old/protocol/references/lineartokentimelock/#pendingbeneficiary","text":"function pendingBeneficiary() external view returns (address); Returns the pending beneficiary, which could assume the beneficiary role at any time by calling acceptBeneficiary()","title":"pendingBeneficiary"},{"location":"old/protocol/references/lineartokentimelock/#initialbalance","text":"function initialBalance() external view returns (uint256); Returns the initial total amount of locked tokens. If new tokens are dropped into the timelock, this number increases to prevent accounting errors.","title":"initialBalance"},{"location":"old/protocol/references/lineartokentimelock/#availableforrelease","text":"function availableForRelease() external view returns (uint256); The amount of lockedToken available to be released by the beneficiary.","title":"availableForRelease"},{"location":"old/protocol/references/lineartokentimelock/#totaltoken","text":"function totalToken() external view returns(uint256); Returns the total amount of tokens held by the timelock pending release.","title":"totalToken"},{"location":"old/protocol/references/lineartokentimelock/#alreadyreleasedamount","text":"function alreadyReleasedAmount() external view returns (uint256); The amount of lockedToken already released by the beneficiary.","title":"alreadyReleasedAmount"},{"location":"old/protocol/references/lineartokentimelock/#public-state-changing-functions","text":"","title":"Public State-Changing Functions"},{"location":"old/protocol/references/lineartokentimelock/#acceptbeneficiary","text":"function acceptBeneficiary() external; Accepts the beneficiary role for msg.sender . Must already be the pending beneficiary. emits BeneficiaryUpdate","title":"acceptBeneficiary"},{"location":"old/protocol/references/lineartokentimelock/#beneficiary-only-state-changing-functions","text":"function release(address to, uint amount) external; Releases amount of timelocked tokens to address to . The amount must be less than or equal to the released amount of tokens. emits Release","title":"Beneficiary-Only\ud83d\udc51 State-Changing Functions"},{"location":"old/protocol/references/lineartokentimelock/#setpendingbeneficiary","text":"function setPendingBeneficiary(address _pendingBeneficiary) external; Sets the pending beneficiary to _pendingBeneficiary . emits PendingBeneficiaryUpdate","title":"setPendingBeneficiary"},{"location":"old/protocol/references/lineartokentimelock/#abis","text":"{% file src=\"../../.gitbook/assets/lineartokentimelock.json\" caption=\"LinearTokenTimelock ABI\" %} {% file src=\"../../.gitbook/assets/ilineartokentimelock.json\" caption=\"LinearTokenTimelock Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/references/oracleref/","text":"OracleRef Contract OracleRef.sol implements IOracleRef , CoreRef Description OracleRef is an abstract contract which references an oracle. It defines some basic utilities useful for contracts referencing an oracle. The contract allows for updating or reading from the oracle. The oracle price is reported as FEI per X where X is some other asset like ETH, USDC, or USD depending on the oracle needs. It allows Governor\u2696\ufe0fto change the referenced Oracle {% page-ref page=\"../oracles/\" %} Events {% tabs %} {% tab title=\"OracleUpdate\" %} Referenced oracle contract update type param description address indexed _oracle new oracle {% endtab %} {% endtabs %} Read-Only Functions oracle function oracle() external view returns (IOracle); Returns the address of the referenced oracle as an interface. peg function peg() external view returns (Decimal.D256 memory); Returns the output of oracle().read() , reverts if the oracle is invalid. invert function invert(Decimal.D256 calldata price) external pure returns (Decimal.D256 memory); Inverts a price to be reported in the reverse direction. When applied to peg it reports X per FEI wher X is some underlying asset. Public State-Changing Functions updateOracle function updateOracle() external returns (bool); Pass-through updates the referenced oracle. Governor-Only\u2696\ufe0f State-Changing Functions setOracle function setOracle(address _oracle) external; Sets the address of the referenced oracle to _oracle . emits OracleUpdate ABIs {% file src=\"../../.gitbook/assets/oracleref.json\" caption=\"OracleRef ABI\" %} {% file src=\"../../.gitbook/assets/ioracleref.json\" caption=\"OracleRef Interface ABI\" %}","title":"OracleRef"},{"location":"old/protocol/references/oracleref/#oracleref","text":"","title":"OracleRef"},{"location":"old/protocol/references/oracleref/#contract","text":"OracleRef.sol implements IOracleRef , CoreRef","title":"Contract"},{"location":"old/protocol/references/oracleref/#description","text":"OracleRef is an abstract contract which references an oracle. It defines some basic utilities useful for contracts referencing an oracle. The contract allows for updating or reading from the oracle. The oracle price is reported as FEI per X where X is some other asset like ETH, USDC, or USD depending on the oracle needs. It allows Governor\u2696\ufe0fto change the referenced Oracle {% page-ref page=\"../oracles/\" %}","title":"Description"},{"location":"old/protocol/references/oracleref/#events","text":"{% tabs %} {% tab title=\"OracleUpdate\" %} Referenced oracle contract update type param description address indexed _oracle new oracle {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/references/oracleref/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/references/oracleref/#oracle","text":"function oracle() external view returns (IOracle); Returns the address of the referenced oracle as an interface.","title":"oracle"},{"location":"old/protocol/references/oracleref/#peg","text":"function peg() external view returns (Decimal.D256 memory); Returns the output of oracle().read() , reverts if the oracle is invalid.","title":"peg"},{"location":"old/protocol/references/oracleref/#invert","text":"function invert(Decimal.D256 calldata price) external pure returns (Decimal.D256 memory); Inverts a price to be reported in the reverse direction. When applied to peg it reports X per FEI wher X is some underlying asset.","title":"invert"},{"location":"old/protocol/references/oracleref/#public-state-changing-functions","text":"","title":"Public State-Changing Functions"},{"location":"old/protocol/references/oracleref/#updateoracle","text":"function updateOracle() external returns (bool); Pass-through updates the referenced oracle.","title":"updateOracle"},{"location":"old/protocol/references/oracleref/#governor-only-state-changing-functions","text":"","title":"Governor-Only\u2696\ufe0f State-Changing Functions"},{"location":"old/protocol/references/oracleref/#setoracle","text":"function setOracle(address _oracle) external; Sets the address of the referenced oracle to _oracle . emits OracleUpdate","title":"setOracle"},{"location":"old/protocol/references/oracleref/#abis","text":"{% file src=\"../../.gitbook/assets/oracleref.json\" caption=\"OracleRef ABI\" %} {% file src=\"../../.gitbook/assets/ioracleref.json\" caption=\"OracleRef Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/references/timed/","text":"Timed Contract Timed.sol Description Abstract contract for managing timed events that complete after a period The contract has a duration d denominated in seconds. It has an effective timestamp t on the range [0,d]. After the period has ended, t stays fixed at d . When it is initialized, it sets the current block timestamp to t=0 . The remaining time is d-t and the completion condition is remaining = 0 ( t=d ). Events {% tabs %} {% tab title=\"DurationUpdate\" %} Change in the duration of the timer type param description uint256 _duration new duration {% endtab %} {% tab title=\"TimerReset\" %} A reset of the timer type param description uint256 _startTime new timer start {% endtab %} {% endtabs %} Read-Only Functions isTimeEnded function isTimeEnded() external view returns (bool); Returns true if elapsed time t is equal to the duration d. startTime function startTime() external view returns (uint256); Returns the starting block timestamp of the window. duration function duration() external view returns (uint256); Returns the duration d of the window. timeSinceStart function timeSinceStart() external view returns (uint256); Returns the elapsed time t since the startTime, with d as the maximum. remainingTime function remainingTime() external view returns (uint256); Returns the time remaining in the window t - d . ABIs {% file src=\"../../.gitbook/assets/timed.json\" caption=\"Timed\" %}","title":"Timed"},{"location":"old/protocol/references/timed/#timed","text":"","title":"Timed"},{"location":"old/protocol/references/timed/#contract","text":"Timed.sol","title":"Contract"},{"location":"old/protocol/references/timed/#description","text":"Abstract contract for managing timed events that complete after a period The contract has a duration d denominated in seconds. It has an effective timestamp t on the range [0,d]. After the period has ended, t stays fixed at d . When it is initialized, it sets the current block timestamp to t=0 . The remaining time is d-t and the completion condition is remaining = 0 ( t=d ).","title":"Description"},{"location":"old/protocol/references/timed/#events","text":"{% tabs %} {% tab title=\"DurationUpdate\" %} Change in the duration of the timer type param description uint256 _duration new duration {% endtab %} {% tab title=\"TimerReset\" %} A reset of the timer type param description uint256 _startTime new timer start {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/references/timed/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/references/timed/#istimeended","text":"function isTimeEnded() external view returns (bool); Returns true if elapsed time t is equal to the duration d.","title":"isTimeEnded"},{"location":"old/protocol/references/timed/#starttime","text":"function startTime() external view returns (uint256); Returns the starting block timestamp of the window.","title":"startTime"},{"location":"old/protocol/references/timed/#duration","text":"function duration() external view returns (uint256); Returns the duration d of the window.","title":"duration"},{"location":"old/protocol/references/timed/#timesincestart","text":"function timeSinceStart() external view returns (uint256); Returns the elapsed time t since the startTime, with d as the maximum.","title":"timeSinceStart"},{"location":"old/protocol/references/timed/#remainingtime","text":"function remainingTime() external view returns (uint256); Returns the time remaining in the window t - d .","title":"remainingTime"},{"location":"old/protocol/references/timed/#abis","text":"{% file src=\"../../.gitbook/assets/timed.json\" caption=\"Timed\" %}","title":"ABIs"},{"location":"old/protocol/references/uniref/","text":"UniRef Contract UniRef.sol implements IUniRef , OracleRef Description UniRef is an abstract contract which references a Uniswap pool. It defines basic utilities for contracts referencing Uniswap. It leverages the OracleRef contract to calculate various quantities relating to spot vs peg price. Let R be the reserves of the referenced Uniswap pair, FEI/ETH for example. The UniRef calculates the price at the start and end of a hypothetical trade of size x via the below formulas. It can then calculate the magnitude of the distance from the peg m given an oracle price O: It has other utilities relating to the peg O : Check whether below peg or not Get amount of a certain asset (fei or other) to trade to bring back to peg. This can be done by setting the end price in the above formula to O and solving for x , replacing the FEI reserves with the target asset reserves and ETH reserves with the other asset reserves. We take the absolute value here and infer the direction based on whether above or below peg. {% hint style=\"info\" %} When calculating the magnitude distance from the peg, the protocol only needs to know the deviation when underpegged. Therefore at or above the peg UniRef returns 0 for the deviation. {% endhint %} Events {% tabs %} {% tab title=\"PairUpdate\" %} Referenced Uniswap pair contract update type param description address indexed _pair new Uniswap pair contract {% endtab %} {% endtabs %} Read-Only Functions router function router() external view returns (IUniswapV2Router02); Returns the address of the UniswapV2Router as an interface. {% embed url=\"https://uniswap.org/docs/v2/smart-contracts/router02/\" caption=\"UniswapV2Router02\" %} pair function pair() external view returns (IUniswapV2Pair); Returns the referenced UniswapV2Pair contract as an interface. {% embed url=\"https://uniswap.org/docs/v2/smart-contracts/pair/\" caption=\"UniswapV2Pair\" %} token function token() external view returns (address); Returns the address of the ERC-20 token held in the UniswapV2Pair that is not FEI. getReserves function getReserves() external view returns (uint256 feiReserves, uint256 tokenReserves); Returns the reserves of the referenced UniswapV2Pair contract, ordered as FEI, and the other token. liquidityOwned function liquidityOwned() external view returns (uint256); Returns the amount of UniswapV2Pair liquidity provider tokens owned by this contract. deviationBelowPeg function deviationBelowPeg( Decimal.D256 calldata price, Decimal.D256 calldata peg ) external pure returns (Decimal.D256 memory); Returns the percent deviation from the peg \"m\" in the above formulas. Assumes prices are reported as FEI per X e.g. 1720.95 FEI per ETH and pegs are reported as USD per X. If the price of FEI is above the peg (meaning the input value is below the input peg), then the function returns 0; Governor-Only\u2696\ufe0f State-Changing Functions setPair function setPair(address _pair) external; Sets the referenced Uniswap pair contract to _pair emits PairUpdate ABIs {% file src=\"../../.gitbook/assets/uniref.json\" caption=\"UniRef ABI\" %} {% file src=\"../../.gitbook/assets/iuniref.json\" caption=\"UniRef Interface ABI\" %}","title":"UniRef"},{"location":"old/protocol/references/uniref/#uniref","text":"","title":"UniRef"},{"location":"old/protocol/references/uniref/#contract","text":"UniRef.sol implements IUniRef , OracleRef","title":"Contract"},{"location":"old/protocol/references/uniref/#description","text":"UniRef is an abstract contract which references a Uniswap pool. It defines basic utilities for contracts referencing Uniswap. It leverages the OracleRef contract to calculate various quantities relating to spot vs peg price. Let R be the reserves of the referenced Uniswap pair, FEI/ETH for example. The UniRef calculates the price at the start and end of a hypothetical trade of size x via the below formulas. It can then calculate the magnitude of the distance from the peg m given an oracle price O: It has other utilities relating to the peg O : Check whether below peg or not Get amount of a certain asset (fei or other) to trade to bring back to peg. This can be done by setting the end price in the above formula to O and solving for x , replacing the FEI reserves with the target asset reserves and ETH reserves with the other asset reserves. We take the absolute value here and infer the direction based on whether above or below peg. {% hint style=\"info\" %} When calculating the magnitude distance from the peg, the protocol only needs to know the deviation when underpegged. Therefore at or above the peg UniRef returns 0 for the deviation. {% endhint %}","title":"Description"},{"location":"old/protocol/references/uniref/#events","text":"{% tabs %} {% tab title=\"PairUpdate\" %} Referenced Uniswap pair contract update type param description address indexed _pair new Uniswap pair contract {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/references/uniref/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/references/uniref/#router","text":"function router() external view returns (IUniswapV2Router02); Returns the address of the UniswapV2Router as an interface. {% embed url=\"https://uniswap.org/docs/v2/smart-contracts/router02/\" caption=\"UniswapV2Router02\" %}","title":"router"},{"location":"old/protocol/references/uniref/#pair","text":"function pair() external view returns (IUniswapV2Pair); Returns the referenced UniswapV2Pair contract as an interface. {% embed url=\"https://uniswap.org/docs/v2/smart-contracts/pair/\" caption=\"UniswapV2Pair\" %}","title":"pair"},{"location":"old/protocol/references/uniref/#token","text":"function token() external view returns (address); Returns the address of the ERC-20 token held in the UniswapV2Pair that is not FEI.","title":"token"},{"location":"old/protocol/references/uniref/#getreserves","text":"function getReserves() external view returns (uint256 feiReserves, uint256 tokenReserves); Returns the reserves of the referenced UniswapV2Pair contract, ordered as FEI, and the other token.","title":"getReserves"},{"location":"old/protocol/references/uniref/#liquidityowned","text":"function liquidityOwned() external view returns (uint256); Returns the amount of UniswapV2Pair liquidity provider tokens owned by this contract.","title":"liquidityOwned"},{"location":"old/protocol/references/uniref/#deviationbelowpeg","text":"function deviationBelowPeg( Decimal.D256 calldata price, Decimal.D256 calldata peg ) external pure returns (Decimal.D256 memory); Returns the percent deviation from the peg \"m\" in the above formulas. Assumes prices are reported as FEI per X e.g. 1720.95 FEI per ETH and pegs are reported as USD per X. If the price of FEI is above the peg (meaning the input value is below the input peg), then the function returns 0;","title":"deviationBelowPeg"},{"location":"old/protocol/references/uniref/#governor-only-state-changing-functions","text":"","title":"Governor-Only\u2696\ufe0f State-Changing Functions"},{"location":"old/protocol/references/uniref/#setpair","text":"function setPair(address _pair) external; Sets the referenced Uniswap pair contract to _pair emits PairUpdate","title":"setPair"},{"location":"old/protocol/references/uniref/#abis","text":"{% file src=\"../../.gitbook/assets/uniref.json\" caption=\"UniRef ABI\" %} {% file src=\"../../.gitbook/assets/iuniref.json\" caption=\"UniRef Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/staking/","text":"Staking Fei Protocol has a staking pool in which FEI/TRIBE Uniswap LP tokens are deposited and TRIBE is earned over time. Rewards Distribution As of FIP-2, the total reward balance is 200,000,000 TRIBE, distributed over 2 years. This represents 20% of the initial TRIBE supply. The rewards distribution rate decreases linearly. Distribution is gated by the FeiRewardsDistributor. It calculates the amount which should be released at any given time and drips it to FeiStakingRewards weekly. {% hint style=\"success\" %} The drip can be called by any user or contract, the caller is rewarded a 500 FEI incentive for triggering the call. {% endhint %} Staking Fei Protocol staking allows users to earn TRIBE tokens while providing liquidity for TRIBE. This is commonly referred to as a Pool 2 in terms of yield farming. The rewards are split evenly among all participants at any given time. Staking is completely fluid. Users can deposit liquidity assets (stake), earn TRIBE for a few blocks, claim earned TRIBE, then withdraw staked tokens at will. There are no lockups on staked tokens. Users are staking FEI/TRIBE Uniswap v2 LP tokens to earn the TRIBE rewards. The Fei DAO can adjust the distribution rate and the staked token if the need arises. {% hint style=\"info\" %} Fei Protocol uses the StakingRewards contract used by Synthetix, Yams, and Set Protocol among others. {% endhint %}","title":"Staking"},{"location":"old/protocol/staking/#staking","text":"Fei Protocol has a staking pool in which FEI/TRIBE Uniswap LP tokens are deposited and TRIBE is earned over time.","title":"Staking"},{"location":"old/protocol/staking/#rewards-distribution","text":"As of FIP-2, the total reward balance is 200,000,000 TRIBE, distributed over 2 years. This represents 20% of the initial TRIBE supply. The rewards distribution rate decreases linearly. Distribution is gated by the FeiRewardsDistributor. It calculates the amount which should be released at any given time and drips it to FeiStakingRewards weekly. {% hint style=\"success\" %} The drip can be called by any user or contract, the caller is rewarded a 500 FEI incentive for triggering the call. {% endhint %}","title":"Rewards Distribution"},{"location":"old/protocol/staking/#staking_1","text":"Fei Protocol staking allows users to earn TRIBE tokens while providing liquidity for TRIBE. This is commonly referred to as a Pool 2 in terms of yield farming. The rewards are split evenly among all participants at any given time. Staking is completely fluid. Users can deposit liquidity assets (stake), earn TRIBE for a few blocks, claim earned TRIBE, then withdraw staked tokens at will. There are no lockups on staked tokens. Users are staking FEI/TRIBE Uniswap v2 LP tokens to earn the TRIBE rewards. The Fei DAO can adjust the distribution rate and the staked token if the need arises. {% hint style=\"info\" %} Fei Protocol uses the StakingRewards contract used by Synthetix, Yams, and Set Protocol among others. {% endhint %}","title":"Staking"},{"location":"old/protocol/staking/feirewardsdistributor/","text":"FeiRewardsDistributor Contract FeiRewardsDistributor.sol implements IRewardsDistributor , CoreRef , Timed Description The FeiRewardsDistributor contract is responsible for sending rewards to the FeiStakingRewards contract each week. It has one public method exposed for keepers to execute this drip functionality, which rewards the caller with a fixed amount of FEI . {% page-ref page=\"feistakingrewards.md\" %} Release Schedule The release schedule for the total reward amount R of TRIBE is a linearly decreasing TRIBE distribution. The distribution function is: This function has a duration of d before it hits a 0 distribution rate. The area under the curve is R, because the y-intercept is 2R/d, by simply multiplying base times height times 1/2. Set the \"unreleased function\" U(t) equal to the area under this curve between the current elapsed time t and the total duration d. Note that for t=d the output is equal to 0 as all of the TRIBE should be released. The formula is: Events {% tabs %} {% tab title=\"Drip\" %} Sent TRIBE to the FeiStakingRewards contract type param description address indexed _caller account that triggered the drip uint256 _amount amount of TRIBE dripped {% endtab %} {% tab title=\"TribeWithdraw\" %} A withdrawal of TRIBE from the distributor type param description uint256 _amount amount withdrawn {% endtab %} {% tab title=\"FrequencyUpdate\" %} Change the drip frequency type param description uint256 _amountReward new drip frequency {% endtab %} {% tab title=\"IncentiveUpdate\" %} Change in the FEI reward for dripping type param description uint256 _incentiveAmount new incentive amount {% endtab %} {% tab title=\"StakingContractUpdate\" %} A change in the staking contract to send TRIBE to. type param description address indexed _stakingContract the new staking contract {% endtab %} {% endtabs %} Read-Only Functions incentiveAmount function incentiveAmount() external view returns (uint256); Returns the amount of FEI sent to the caller of drip() . dripFrequency function dripFrequency() external view returns (uint256); The minimum frequency allowed between rewards distribution. isDripAvailable function isDripAvailable() external view returns (bool); Returns true if nextDripAvailable() preceeds the current block timestamp nextDripAvailable function nextDripAvailable() external view returns (uint256); The next block timestamp when reward distribution is allowed by the contract. Equals lastDistributionTime() + dripFrequency() lastDistributionTime function lastDistributionTime() external view returns (uint256); The last block timestamp when rewards were distributed from the contract. stakingContract function stakingContract() external view returns (IStakingRewards); The FeiStakingRewards contract address totalReward function totalReward() external view returns (uint256); Returns the total amount of rewards released over the entire window, including claimed, released, and unreleased. releasedReward function releasedReward() external view returns (uint256); Returns the amount of rewardToken available for claiming by the pool. Calculated as rewardBalance() - unreleasedReward() . unreleasedReward function unreleasedReward() external view returns (uint256); The unreleased reward function following the formula shown in the Release Schedule section above. It starts at the totalReward() amount and then wind down to 0 over the duration of the window. rewardBalance function rewardBalance() external view returns (uint256); The amount of TRIBE held by the contract, released or unreleased. distributedRewards function distributedRewards() external view returns (uint256); The total amount of TRIBE already distributed to FeiStakingRewards . EOA-Only \ud83d\udc64 State-Changing Functions drip function drip() external returns (uint256); Sends releasedReward() TRIBE to the stakingRewards() contract and updates the reward rate. Incentivizes the caller with incentiveAmount() FEI . {% hint style=\"info\" %} Only callable when nextDripAvailable() is below the current block timestamp and the contract is not paused {% endhint %} Governor-Only\u2696\ufe0f State-Changing Functions governorWithdrawTribe function governorWithdraw(uint256 amount) external; Withdraws amount TRIBE tokens from the pool to Fei Core. governorRecover function governorRecover(address tokenAddress, address to, uint256 amount) external; Recovers tokenAddress ERC20 tokens from the FeiStakingRewards contract to address to . This is used if there were AMM rewards distributed. setDripFrequency function setDripFrequency(uint256 _frequency) external; Sets the frequency with which the contract calls the FeiStakingRewards. setIncentiveAmount function setIncentiveAmount(uint256 _incentiveAmount) external; Sets the incentive amount for calling drip() . setStakingContract function setStakingContract(address _stakingRewards) external; Sets the staking contract to send TRIBE to. ABIs {% file src=\"../../.gitbook/assets/feirewardsdistributor.json\" caption=\"FeiRewardsDistributor ABI\" %} {% file src=\"../../.gitbook/assets/irewardsdistributor.json\" caption=\"RewardsDistributor Interface ABI\" %}","title":"FeiRewardsDistributor"},{"location":"old/protocol/staking/feirewardsdistributor/#feirewardsdistributor","text":"","title":"FeiRewardsDistributor"},{"location":"old/protocol/staking/feirewardsdistributor/#contract","text":"FeiRewardsDistributor.sol implements IRewardsDistributor , CoreRef , Timed","title":"Contract"},{"location":"old/protocol/staking/feirewardsdistributor/#description","text":"The FeiRewardsDistributor contract is responsible for sending rewards to the FeiStakingRewards contract each week. It has one public method exposed for keepers to execute this drip functionality, which rewards the caller with a fixed amount of FEI . {% page-ref page=\"feistakingrewards.md\" %}","title":"Description"},{"location":"old/protocol/staking/feirewardsdistributor/#release-schedule","text":"The release schedule for the total reward amount R of TRIBE is a linearly decreasing TRIBE distribution. The distribution function is: This function has a duration of d before it hits a 0 distribution rate. The area under the curve is R, because the y-intercept is 2R/d, by simply multiplying base times height times 1/2. Set the \"unreleased function\" U(t) equal to the area under this curve between the current elapsed time t and the total duration d. Note that for t=d the output is equal to 0 as all of the TRIBE should be released. The formula is:","title":"Release Schedule"},{"location":"old/protocol/staking/feirewardsdistributor/#events","text":"{% tabs %} {% tab title=\"Drip\" %} Sent TRIBE to the FeiStakingRewards contract type param description address indexed _caller account that triggered the drip uint256 _amount amount of TRIBE dripped {% endtab %} {% tab title=\"TribeWithdraw\" %} A withdrawal of TRIBE from the distributor type param description uint256 _amount amount withdrawn {% endtab %} {% tab title=\"FrequencyUpdate\" %} Change the drip frequency type param description uint256 _amountReward new drip frequency {% endtab %} {% tab title=\"IncentiveUpdate\" %} Change in the FEI reward for dripping type param description uint256 _incentiveAmount new incentive amount {% endtab %} {% tab title=\"StakingContractUpdate\" %} A change in the staking contract to send TRIBE to. type param description address indexed _stakingContract the new staking contract {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/staking/feirewardsdistributor/#read-only-functions","text":"","title":"Read-Only Functions"},{"location":"old/protocol/staking/feirewardsdistributor/#incentiveamount","text":"function incentiveAmount() external view returns (uint256); Returns the amount of FEI sent to the caller of drip() .","title":"incentiveAmount"},{"location":"old/protocol/staking/feirewardsdistributor/#dripfrequency","text":"function dripFrequency() external view returns (uint256); The minimum frequency allowed between rewards distribution.","title":"dripFrequency"},{"location":"old/protocol/staking/feirewardsdistributor/#isdripavailable","text":"function isDripAvailable() external view returns (bool); Returns true if nextDripAvailable() preceeds the current block timestamp","title":"isDripAvailable"},{"location":"old/protocol/staking/feirewardsdistributor/#nextdripavailable","text":"function nextDripAvailable() external view returns (uint256); The next block timestamp when reward distribution is allowed by the contract. Equals lastDistributionTime() + dripFrequency()","title":"nextDripAvailable"},{"location":"old/protocol/staking/feirewardsdistributor/#lastdistributiontime","text":"function lastDistributionTime() external view returns (uint256); The last block timestamp when rewards were distributed from the contract.","title":"lastDistributionTime"},{"location":"old/protocol/staking/feirewardsdistributor/#stakingcontract","text":"function stakingContract() external view returns (IStakingRewards); The FeiStakingRewards contract address","title":"stakingContract"},{"location":"old/protocol/staking/feirewardsdistributor/#totalreward","text":"function totalReward() external view returns (uint256); Returns the total amount of rewards released over the entire window, including claimed, released, and unreleased.","title":"totalReward"},{"location":"old/protocol/staking/feirewardsdistributor/#releasedreward","text":"function releasedReward() external view returns (uint256); Returns the amount of rewardToken available for claiming by the pool. Calculated as rewardBalance() - unreleasedReward() .","title":"releasedReward"},{"location":"old/protocol/staking/feirewardsdistributor/#unreleasedreward","text":"function unreleasedReward() external view returns (uint256); The unreleased reward function following the formula shown in the Release Schedule section above. It starts at the totalReward() amount and then wind down to 0 over the duration of the window.","title":"unreleasedReward"},{"location":"old/protocol/staking/feirewardsdistributor/#rewardbalance","text":"function rewardBalance() external view returns (uint256); The amount of TRIBE held by the contract, released or unreleased.","title":"rewardBalance"},{"location":"old/protocol/staking/feirewardsdistributor/#distributedrewards","text":"function distributedRewards() external view returns (uint256); The total amount of TRIBE already distributed to FeiStakingRewards .","title":"distributedRewards"},{"location":"old/protocol/staking/feirewardsdistributor/#eoa-only-state-changing-functions","text":"","title":"EOA-Only \ud83d\udc64 State-Changing Functions"},{"location":"old/protocol/staking/feirewardsdistributor/#drip","text":"function drip() external returns (uint256); Sends releasedReward() TRIBE to the stakingRewards() contract and updates the reward rate. Incentivizes the caller with incentiveAmount() FEI . {% hint style=\"info\" %} Only callable when nextDripAvailable() is below the current block timestamp and the contract is not paused {% endhint %}","title":"drip"},{"location":"old/protocol/staking/feirewardsdistributor/#governor-only-state-changing-functions","text":"","title":"Governor-Only\u2696\ufe0f State-Changing Functions"},{"location":"old/protocol/staking/feirewardsdistributor/#governorwithdrawtribe","text":"function governorWithdraw(uint256 amount) external; Withdraws amount TRIBE tokens from the pool to Fei Core.","title":"governorWithdrawTribe"},{"location":"old/protocol/staking/feirewardsdistributor/#governorrecover","text":"function governorRecover(address tokenAddress, address to, uint256 amount) external; Recovers tokenAddress ERC20 tokens from the FeiStakingRewards contract to address to . This is used if there were AMM rewards distributed.","title":"governorRecover"},{"location":"old/protocol/staking/feirewardsdistributor/#setdripfrequency","text":"function setDripFrequency(uint256 _frequency) external; Sets the frequency with which the contract calls the FeiStakingRewards.","title":"setDripFrequency"},{"location":"old/protocol/staking/feirewardsdistributor/#setincentiveamount","text":"function setIncentiveAmount(uint256 _incentiveAmount) external; Sets the incentive amount for calling drip() .","title":"setIncentiveAmount"},{"location":"old/protocol/staking/feirewardsdistributor/#setstakingcontract","text":"function setStakingContract(address _stakingRewards) external; Sets the staking contract to send TRIBE to.","title":"setStakingContract"},{"location":"old/protocol/staking/feirewardsdistributor/#abis","text":"{% file src=\"../../.gitbook/assets/feirewardsdistributor.json\" caption=\"FeiRewardsDistributor ABI\" %} {% file src=\"../../.gitbook/assets/irewardsdistributor.json\" caption=\"RewardsDistributor Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/staking/feistakingrewards/","text":"FeiStakingRewards Contract FeiStakingRewards implements StakingRewardsV2 Events {% tabs %} {% tab title=\"RewardAdded\" %} Amount of reward token added to contract type param description uint256 reward account of rewards sent to the contract {% endtab %} {% tab title=\"Staked\" %} Tokens staked by user type param description address indexed user account staked to uint256 amount amount staked {% endtab %} {% tab title=\"Withdrawn\" %} Staked tokens withdrawn by user type param description address indexed user account withdrawn from uint256 amount amount withdrawn {% endtab %} {% tab title=\"RewardPaid\" %} Rewards redeemed by user type param description address indexed user account receiving rewards uint256 reward amount of reward {% endtab %} {% tab title=\"Recovered\" %} ERC20 recovered by the distributor type param description address indexed tokenAddress ERC-20 address address indexed to destination for tokens uint256 amount amount recovered {% endtab %} {% endtabs %} Functions Documented on the Synthetix website: {% embed url=\"https://docs.synthetix.io/contracts/source/contracts/StakingRewards/\" %} ABIs {% file src=\"../../.gitbook/assets/feistakingrewards.json\" caption=\"FeiStakingRewards ABI\" %} {% file src=\"../../.gitbook/assets/istakingrewards.json\" caption=\"StakingRewards Interface ABI\" %}","title":"FeiStakingRewards"},{"location":"old/protocol/staking/feistakingrewards/#feistakingrewards","text":"","title":"FeiStakingRewards"},{"location":"old/protocol/staking/feistakingrewards/#contract","text":"FeiStakingRewards implements StakingRewardsV2","title":"Contract"},{"location":"old/protocol/staking/feistakingrewards/#events","text":"{% tabs %} {% tab title=\"RewardAdded\" %} Amount of reward token added to contract type param description uint256 reward account of rewards sent to the contract {% endtab %} {% tab title=\"Staked\" %} Tokens staked by user type param description address indexed user account staked to uint256 amount amount staked {% endtab %} {% tab title=\"Withdrawn\" %} Staked tokens withdrawn by user type param description address indexed user account withdrawn from uint256 amount amount withdrawn {% endtab %} {% tab title=\"RewardPaid\" %} Rewards redeemed by user type param description address indexed user account receiving rewards uint256 reward amount of reward {% endtab %} {% tab title=\"Recovered\" %} ERC20 recovered by the distributor type param description address indexed tokenAddress ERC-20 address address indexed to destination for tokens uint256 amount amount recovered {% endtab %} {% endtabs %}","title":"Events"},{"location":"old/protocol/staking/feistakingrewards/#functions","text":"Documented on the Synthetix website: {% embed url=\"https://docs.synthetix.io/contracts/source/contracts/StakingRewards/\" %}","title":"Functions"},{"location":"old/protocol/staking/feistakingrewards/#abis","text":"{% file src=\"../../.gitbook/assets/feistakingrewards.json\" caption=\"FeiStakingRewards ABI\" %} {% file src=\"../../.gitbook/assets/istakingrewards.json\" caption=\"StakingRewards Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/trading/","text":"Trading This section applies to buying and selling FEI from the protocol or on incentivized FEI Uniswap pools. Users can always buy and sell on secondary markets where they exist. Buying FEI Users can acquire FEI in the following (non-exhaustive) ways: Using the FeiRouter , exposed on app.fei.money Buying from the bonding curve Buying directly on the ETH/FEI Uniswap pool The bonding curve is currently not exposed via app.fei.money . The Fei Core Team is considering a feature to optimize the trading price of Fei Protocol UI by going to the bonding curve if offers a better deal. Selling FEI The router is exposed on app.fei.money , with parameters to protect against slippage and bound penalties.","title":"Trading"},{"location":"old/protocol/trading/#trading","text":"This section applies to buying and selling FEI from the protocol or on incentivized FEI Uniswap pools. Users can always buy and sell on secondary markets where they exist.","title":"Trading"},{"location":"old/protocol/trading/#buying-fei","text":"Users can acquire FEI in the following (non-exhaustive) ways: Using the FeiRouter , exposed on app.fei.money Buying from the bonding curve Buying directly on the ETH/FEI Uniswap pool The bonding curve is currently not exposed via app.fei.money . The Fei Core Team is considering a feature to optimize the trading price of Fei Protocol UI by going to the bonding curve if offers a better deal.","title":"Buying FEI"},{"location":"old/protocol/trading/#selling-fei","text":"The router is exposed on app.fei.money , with parameters to protect against slippage and bound penalties.","title":"Selling FEI"},{"location":"old/protocol/trading/feirouter/","text":"FeiRouter Contract FeiRouter.sol implements IFeiRouter Description A router for swapping FEI and ETH The router implements methods for buying and selling FEI with a single added slippage parameter to bound Direct Incentives. For the buyFei method the minReward parameter is the minimum amount of FEI mint the contract should allow without reverting. This is the mint applied by the UniswapIncentive contract. For the sellFei method the maxPenalty parameter is the maximum amount of FEI burn the contract should allow without reverting. This is the burn applied by the UniswapIncentive contract. Public State-Changing Functions buyFei function buyFei( uint256 minReward, uint256 amountOutMin, address to, uint256 deadline ) external payable returns (uint256 amountOut); Buy at least amountOutMin FEI for ETH and send the FEI to address to before the block timestamp exceeds deadline . Calculates the reward received by calculating how much the balance of \"to\" increased beyond the expected amountOut. Revert if the FEI reward received is less than minReward . {% hint style=\"warning\" %} If you get a UNISWAP_V2:TRANSFER _ FAILED error then you may have ran out of gas, or there was another error inside the UniswapIncentive hook execution for the FEI transfer {% endhint %} sellFei function sellFei( uint256 maxPenalty, uint256 amountIn, uint256 amountOutMin, address to, uint256 deadline ) external returns (uint256 amountOut); Sell amountIn FEI to receive at least amountOutMin ETH and send the ETH to address to before the block timestamp exceeds deadline . Calculates the penalty by calculating the amount that was removed from in-flight after the FEI transfer to Uniswap. Revert if the FEI penalty received is more than maxPenalty . ABIs {% file src=\"../../.gitbook/assets/feirouter.json\" caption=\"FeiRouter ABI\" %} {% file src=\"../../.gitbook/assets/ifeirouter.json\" caption=\"FeiRouter Interface ABI\" %}","title":"FeiRouter"},{"location":"old/protocol/trading/feirouter/#feirouter","text":"","title":"FeiRouter"},{"location":"old/protocol/trading/feirouter/#contract","text":"FeiRouter.sol implements IFeiRouter","title":"Contract"},{"location":"old/protocol/trading/feirouter/#description","text":"A router for swapping FEI and ETH The router implements methods for buying and selling FEI with a single added slippage parameter to bound Direct Incentives. For the buyFei method the minReward parameter is the minimum amount of FEI mint the contract should allow without reverting. This is the mint applied by the UniswapIncentive contract. For the sellFei method the maxPenalty parameter is the maximum amount of FEI burn the contract should allow without reverting. This is the burn applied by the UniswapIncentive contract.","title":"Description"},{"location":"old/protocol/trading/feirouter/#public-state-changing-functions","text":"","title":"Public State-Changing Functions"},{"location":"old/protocol/trading/feirouter/#buyfei","text":"function buyFei( uint256 minReward, uint256 amountOutMin, address to, uint256 deadline ) external payable returns (uint256 amountOut); Buy at least amountOutMin FEI for ETH and send the FEI to address to before the block timestamp exceeds deadline . Calculates the reward received by calculating how much the balance of \"to\" increased beyond the expected amountOut. Revert if the FEI reward received is less than minReward . {% hint style=\"warning\" %} If you get a UNISWAP_V2:TRANSFER _ FAILED error then you may have ran out of gas, or there was another error inside the UniswapIncentive hook execution for the FEI transfer {% endhint %}","title":"buyFei"},{"location":"old/protocol/trading/feirouter/#sellfei","text":"function sellFei( uint256 maxPenalty, uint256 amountIn, uint256 amountOutMin, address to, uint256 deadline ) external returns (uint256 amountOut); Sell amountIn FEI to receive at least amountOutMin ETH and send the ETH to address to before the block timestamp exceeds deadline . Calculates the penalty by calculating the amount that was removed from in-flight after the FEI transfer to Uniswap. Revert if the FEI penalty received is more than maxPenalty .","title":"sellFei"},{"location":"old/protocol/trading/feirouter/#abis","text":"{% file src=\"../../.gitbook/assets/feirouter.json\" caption=\"FeiRouter ABI\" %} {% file src=\"../../.gitbook/assets/ifeirouter.json\" caption=\"FeiRouter Interface ABI\" %}","title":"ABIs"},{"location":"old/protocol/trading/uniswapsingleethrouter/","text":"UniswapSingleEthRouter Contract UniswapSingleEthRouter.sol implements IUniswapSingleEthRouter Description A router for swapping tokens and ETH on a single predetermined Uniswap pair. The router implements only two of the standard Uniswap router methods: swapExactETHForTokens swapExactTokensForETH Both have the same standard behavior as the Uniswap router, specifying a amountOutMin to protect against slippage and a deadline to timebox trades. State-Changing Functions Public swapExactETHForTokens function swapExactETHForTokens( uint256 amountOutMin, address to, uint256 deadline ) external payable returns (uint256 amountOut); Buy at least amountOutMin tokens for ETH and send the ETH to address to before the block timestamp exceeds deadline . swapExactTokensForETH function swapExactTokensForETH( uint256 amountIn, uint256 amountOutMin, address to, uint256 deadline ) external returns (uint256 amountOut); Sell amountIn FEI to receive at least amountOutMin ETH and send the FEI to address to before the block timestamp exceeds deadline .","title":"UniswapSingleEthRouter"},{"location":"old/protocol/trading/uniswapsingleethrouter/#uniswapsingleethrouter","text":"","title":"UniswapSingleEthRouter"},{"location":"old/protocol/trading/uniswapsingleethrouter/#contract","text":"UniswapSingleEthRouter.sol implements IUniswapSingleEthRouter","title":"Contract"},{"location":"old/protocol/trading/uniswapsingleethrouter/#description","text":"A router for swapping tokens and ETH on a single predetermined Uniswap pair. The router implements only two of the standard Uniswap router methods: swapExactETHForTokens swapExactTokensForETH Both have the same standard behavior as the Uniswap router, specifying a amountOutMin to protect against slippage and a deadline to timebox trades.","title":"Description"},{"location":"old/protocol/trading/uniswapsingleethrouter/#state-changing-functions","text":"","title":"State-Changing Functions "},{"location":"old/protocol/trading/uniswapsingleethrouter/#public","text":"","title":"Public"},{"location":"old/protocol/trading/uniswapsingleethrouter/#swapexactethfortokens","text":"function swapExactETHForTokens( uint256 amountOutMin, address to, uint256 deadline ) external payable returns (uint256 amountOut); Buy at least amountOutMin tokens for ETH and send the ETH to address to before the block timestamp exceeds deadline .","title":"swapExactETHForTokens"},{"location":"old/protocol/trading/uniswapsingleethrouter/#swapexacttokensforeth","text":"function swapExactTokensForETH( uint256 amountIn, uint256 amountOutMin, address to, uint256 deadline ) external returns (uint256 amountOut); Sell amountIn FEI to receive at least amountOutMin ETH and send the FEI to address to before the block timestamp exceeds deadline .","title":"swapExactTokensForETH"},{"location":"old/staking-fei-tribe-lp/","text":"Staking FEI:TRIBE LP TRIBE is the Fei Protocol governance token. You can earn TRIBE staking rewards by providing liquidity to Uniswap\u2019s FEI-TRIBE pool . To participate in this staking pool, you need to acquire FEI-TRIBE LP Tokens . Before participating in LP Pool Staking you should further research and explore the risks and potential rewards associated with providing staking pool liquidity. Loss of funds is possible due to a number of factors such as IL (Impermanent Loss), reward token (TRIBE) volatility, and associated transaction ( gas fees ) costs. Fei Protocol staking pool is set for 2 years, with a linearly decreasing rate for reward release of 200M TRIBE tokens. Additional program details and contracts available here . Currently, the Fei Protocol staking pool only accepts LP Tokens from the Fei-Tribe Uniswap v2 pool. Please ensure that you are using Uniswap v2 when making LP's. {% page-ref page=\"steps-for-staking.md\" %} {% page-ref page=\"unstaking.md\" %}","title":"Staking FEI:TRIBE LP"},{"location":"old/staking-fei-tribe-lp/#staking-feitribe-lp","text":"TRIBE is the Fei Protocol governance token. You can earn TRIBE staking rewards by providing liquidity to Uniswap\u2019s FEI-TRIBE pool . To participate in this staking pool, you need to acquire FEI-TRIBE LP Tokens . Before participating in LP Pool Staking you should further research and explore the risks and potential rewards associated with providing staking pool liquidity. Loss of funds is possible due to a number of factors such as IL (Impermanent Loss), reward token (TRIBE) volatility, and associated transaction ( gas fees ) costs. Fei Protocol staking pool is set for 2 years, with a linearly decreasing rate for reward release of 200M TRIBE tokens. Additional program details and contracts available here . Currently, the Fei Protocol staking pool only accepts LP Tokens from the Fei-Tribe Uniswap v2 pool. Please ensure that you are using Uniswap v2 when making LP's. {% page-ref page=\"steps-for-staking.md\" %} {% page-ref page=\"unstaking.md\" %}","title":"Staking FEI:TRIBE LP"},{"location":"old/staking-fei-tribe-lp/steps-for-staking/","text":"Steps for Staking 1. Acquire FEI: To acquire FEI, we recommend using the Fei app : 2. Acquire TRIBE: To acquire TRIBE, you need to use Uniswap or another secondary market. Add TRIBE as a token by clicking on \u201cselect a token\u201d: {% hint style=\"info\" %} If TRIBE is not an option in the drop down menu, paste in the contract address (0xc7283b66Eb1EB5FB86327f08e1B5816b0720212B) to add TRIBE: {% endhint %} Now you will have the ability to insert the desired amount of TRIBE. 3. Approve FEI and TRIBE on Uniswap : Once you have 50/50 TRIBE and FEI in value, you can add them as liquidity here . But first , approve Uniswap FEI and TRIBE as they are ERC-20 tokens: 4. Supply FEI and TRIBE in order to receive FEI-TRIBE LP tokens: After you approve your tokens, you can supply the desired amount: 5. Staking the LP tokens: Following receipt of FEI-TRIBE LP Tokens, you can supply the tokens on the Fei app staking tab , start by allowing your LP tokens: Now you can stake your tokens: 6. Claiming rewards: You can view the status of your staking rewards as well as claim rewards: {% hint style=\"info\" %} * You can claim rewards at any time, and they will never disappear. * We recommend that you consider the cost of gas fees relative to your reward amount when claiming rewards. * For smaller investors, the current gas price might be of interest when claiming the reward. * The cadence at which to claim is up to you, rewards will not disappear over time. {% endhint %}","title":"Steps for Staking"},{"location":"old/staking-fei-tribe-lp/steps-for-staking/#steps-for-staking","text":"1. Acquire FEI: To acquire FEI, we recommend using the Fei app : 2. Acquire TRIBE: To acquire TRIBE, you need to use Uniswap or another secondary market. Add TRIBE as a token by clicking on \u201cselect a token\u201d: {% hint style=\"info\" %} If TRIBE is not an option in the drop down menu, paste in the contract address (0xc7283b66Eb1EB5FB86327f08e1B5816b0720212B) to add TRIBE: {% endhint %} Now you will have the ability to insert the desired amount of TRIBE. 3. Approve FEI and TRIBE on Uniswap : Once you have 50/50 TRIBE and FEI in value, you can add them as liquidity here . But first , approve Uniswap FEI and TRIBE as they are ERC-20 tokens: 4. Supply FEI and TRIBE in order to receive FEI-TRIBE LP tokens: After you approve your tokens, you can supply the desired amount: 5. Staking the LP tokens: Following receipt of FEI-TRIBE LP Tokens, you can supply the tokens on the Fei app staking tab , start by allowing your LP tokens: Now you can stake your tokens: 6. Claiming rewards: You can view the status of your staking rewards as well as claim rewards: {% hint style=\"info\" %} * You can claim rewards at any time, and they will never disappear. * We recommend that you consider the cost of gas fees relative to your reward amount when claiming rewards. * For smaller investors, the current gas price might be of interest when claiming the reward. * The cadence at which to claim is up to you, rewards will not disappear over time. {% endhint %}","title":"Steps for Staking"},{"location":"old/staking-fei-tribe-lp/unstaking/","text":"Unstaking {% hint style=\"warning\" %} If you would like to participate in the on-chain DAO vote, you must withdraw your LP tokens, and have TRIBE in your wallet, as LP tokens are not eligible for on-chain voting. {% endhint %} When you decide to unstake and exchange your LP tokens into FEI and TRIBE, you should follow these simple steps: 1. Unstake from Fei app : 2. Remove liquidity on Uniswap : Removing your liquidity is straightforward, click on remove and you can swap your FEI and TRIBE again:","title":"Unstaking"},{"location":"old/staking-fei-tribe-lp/unstaking/#unstaking","text":"{% hint style=\"warning\" %} If you would like to participate in the on-chain DAO vote, you must withdraw your LP tokens, and have TRIBE in your wallet, as LP tokens are not eligible for on-chain voting. {% endhint %} When you decide to unstake and exchange your LP tokens into FEI and TRIBE, you should follow these simple steps: 1. Unstake from Fei app : 2. Remove liquidity on Uniswap : Removing your liquidity is straightforward, click on remove and you can swap your FEI and TRIBE again:","title":"Unstaking"},{"location":"operator/operator/","text":"Fei Operator Documentation Table of Contents Fei Improvement Proposals - TODO Optimistic Approval - TODO Moderation - TODO","title":"Operator"},{"location":"operator/operator/#fei-operator-documentation","text":"","title":"Fei Operator Documentation"},{"location":"operator/operator/#table-of-contents","text":"Fei Improvement Proposals - TODO Optimistic Approval - TODO Moderation - TODO","title":"Table of Contents"},{"location":"user/user/","text":"Fei User Documentation Table of Contents Fei Improvement Proposals - TODO Optimistic Approval - TODO Moderation - TODO","title":"User"},{"location":"user/user/#fei-user-documentation","text":"","title":"Fei User Documentation"},{"location":"user/user/#table-of-contents","text":"Fei Improvement Proposals - TODO Optimistic Approval - TODO Moderation - TODO","title":"Table of Contents"}]}